<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title> on CoderZh Blog</title>
        <link>http://blog.coderzh.com/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Sun, 15 May 2016 11:32:15 CST</updated>
        
        <item>
            <title>善良比聪明更难</title>
            <link>http://blog.coderzh.com/2016/05/15/kind-or-clever/</link>
            <pubDate>Sun, 15 May 2016 11:32:15 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/05/15/kind-or-clever/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;Jeff, one day you&amp;rsquo;ll understand that it&amp;rsquo;s harder to be kind than clever.&lt;/p&gt;

&lt;p&gt;杰夫，总有一天你会明白，善良比聪明更难。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jeff Bezos 毕业于普林斯顿大学，是美国亚马逊的创始人。在 2010 年普林斯顿大学学士毕业典礼上，贝索斯发表了演讲《善良比聪明更难》。&lt;/p&gt;

&lt;p&gt;演讲中，他提到在 10 岁时一次家庭房车旅游中，祖父一边开着车，祖母在旁一边抽着烟。贝索斯不喜欢烟的味道，于是自作主张的根据一个吸烟广告的数据计算了起来。最后他得意的拍了拍祖母的肩膀，骄傲的宣称：「如果两分钟就吸一口烟的话，你就会少活 9 年！」&lt;/p&gt;

&lt;p&gt;贝索斯很聪明，他本以为会得到家人的赞许，因为里面涉及了很多数学计算。然而他的自作聪明，却伤害了他的祖母，祖母开始哭泣起来。&lt;/p&gt;

&lt;p&gt;下车后，祖父对贝索斯说：「杰夫，总有一天你会明白，善良比聪明更难。」&lt;/p&gt;

&lt;p&gt;演讲视频很容易在网上找到，建议有兴趣的同学都去看看原版视频，因为我发现很多持有反对意见的人是没有看过原版视频的。&lt;/p&gt;

&lt;p&gt;首先，贝索斯的演讲对象是普林斯顿大学的毕业生，毫无疑问，是一群聪明绝伦的人。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;聪明是一种天赋，而善良是一种选择。天赋得来很容易——毕竟它们与生俱来。而选择则颇为不易。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;聪明的人面临选择时，是选择一条伤害他人获利自己的路，还是选择一条即使更难但始终保持善良的路？&lt;/p&gt;

&lt;p&gt;这是贝索斯抛出的问题。&lt;/p&gt;

&lt;p&gt;不聪明的人作恶，很容易被发现或被制止，他们往往做些小恶，贪图一些小便宜，如果做大恶，代价太大，容易被识破或触犯法律，当然也不排除铤而走险的人。&lt;/p&gt;

&lt;p&gt;聪明的人作恶更容易，他们知道如何在获取巨大利益的同时，掩盖自己的恶。比如《笑傲江湖》里的岳不群。&lt;/p&gt;

&lt;p&gt;人之初，性本善。作恶之人会把原因归咎于社会，归咎于环境，他们擅长寻找心里慰藉，很多人甚至不认为那是恶，他们会说：「人为财死，鸟为食亡」。他们会为自己做的恶找很多借口，他们会说：「我顶多只能算推波助澜，真正作恶的是别人。」&lt;/p&gt;

&lt;p&gt;社会不如我们想象中的美好，通过作恶获取巨大利益给了聪明人巨大的诱惑，而且他们善于掩盖和包装所做的恶，直到催眠自己，把一切都看作理所当然。&lt;/p&gt;

&lt;p&gt;社会也不像我们想象中的那么差，依然有大量心怀善意的人，他们影响着他人，甚至改变着世界。&lt;/p&gt;

&lt;p&gt;贝索斯的演讲就是告诉我们，当我们面临选择时，请选择一条善意的路，尽管它更难。&lt;/p&gt;

&lt;p&gt;有人会问，选择善良会容易吃亏吗？&lt;/p&gt;

&lt;p&gt;不聪明的人对你做恶，往往只是想占你一点小便宜。聪明的人对你作恶，错的不是你太善良，而是你不够聪明。&lt;/p&gt;

&lt;p&gt;我也曾在百度搜过几种疾病，本能的我会意识到其中的广告成分，我会选择不去相信。当然，作为国内最大的搜索引擎，想靠用户去甄别真的很难。&lt;/p&gt;

&lt;p&gt;于是我再聪明一点，我选择不用百度。尽管很难，我坚持使用 Google，因为这是一家推崇「不作恶」的公司。&lt;/p&gt;

&lt;p&gt;再举个栗子：&lt;/p&gt;

&lt;p&gt;《琅琊榜》里，梁王谋反篡位，陷害忠良，东宫太子和誉王为夺皇位无恶不作。誉王、夏江、秦般弱都是聪明之人，手段也很毒辣，怎奈还是敌不过更加聪明一等，并且保持善良的梅长苏！这个剧被热播，也正好说明了人们人心向善的愿望，能有个梅长苏替自己给险恶之人以沉痛一击，岂不快哉！&lt;/p&gt;

&lt;p&gt;「To be or not to be, 这不是一个问题。」&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Swift 语言学习及速查手册</title>
            <link>http://blog.coderzh.com/2016/04/24/swift-tips/</link>
            <pubDate>Sun, 24 Apr 2016 23:21:16 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/04/24/swift-tips/</guid>
            <description>&lt;p&gt;学习一门新的编程语言要多久？答案是随着你的经验的增加，学习花费的时间越来越短。当然，这也和新语言的不断演变进化有关系。&lt;/p&gt;

&lt;p&gt;我利用周末两天时间，把《Swift Programming Language》中文版整整的细看了一遍，然后为了总结提取 Swift 的主要语言特性，又把这本书快速过了第二遍。&lt;/p&gt;

&lt;p&gt;根据我的番茄钟粗略统计，我看书学习第一遍大约花了 5 小时（包括边学，边在 XCode 试验的时间），第二遍主要是快速过一遍主要特性，将主要示例代码提取出来，大约花了 3.5 小时。&lt;/p&gt;

&lt;p&gt;连我自己都觉得有点难以置信，总共只需要 8 小时，就可以基本入门一门新语言了。&lt;/p&gt;

&lt;p&gt;很多时候，我们想学习某个东西，但是却一直停留在想一想的状态，迟迟都未动手。究其原因，大概是如下几个原因吧：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;恐惧未知。对未知的东西没有把握，怕太难，怕需要太长时间学，所以能拖就拖。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意力不能集中。连续玩几个小时游戏一点不累，看半小时书就感觉身心俱疲。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;番茄工作法在这个时候就起作用了，告诉自己，不想太多，开始一个番茄钟试试，在这 25 分钟内，只关注这 25 分钟内要看的内容。然后，很自然的，障碍被逐个击破，番茄钟一个接着一个。&lt;/p&gt;

&lt;p&gt;以下是我学习 Swift 的代码总结，可用于之后速查。&lt;/p&gt;

&lt;p&gt;代码：&lt;a href=&#34;https://github.com/coderzh/CodeTips/blob/master/swift.swift&#34;&gt;https://github.com/coderzh/CodeTips/blob/master/swift.swift&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 swift.swift:
 Swift 速学速查速用代码手册
 Source: github.com/coderzh/CodeTips/blob/master/swift.swift
 Author: coderzh(github.com/coderzh)
 Blog: http://blog.coderzh.com
 参考：《Swift Programming Language》
 */

import Cocoa

// 0. 注释
/*
块注释
行尾分号可不用
*/

// 1. Hello World
print(&amp;quot;Hello Swift&amp;quot;)

// 2. 常量变量类型
let constValue = 3.14
var variable = 18

variable += 1

// 指定类型
let age: Int = 18
// 多重赋值
var (a, b) = (1, 2)
// 匿名占位符
(_, b) = (3, 4)

// 类型会自动推导
let name = &amp;quot;It&#39;s a string&amp;quot;
let gravity = 0.98 // 默认 double

// 永远不做隐式转换，必须自己强转
let sum = Double(age) + gravity

// 运算：+, -, *, /, % 求余
// 比较：&amp;lt;, &amp;gt;, ==, &amp;gt;=, &amp;lt;=, !=
// === 恒等，是否为同一个对象
// !== 不恒等
// 位运算：~x 取反，&amp;amp; 与，| 或，^ 异或，&amp;lt;&amp;lt; 左移动，&amp;gt;&amp;gt; 右移
// 溢出运算符 &amp;amp;+ &amp;amp;- &amp;amp;* &amp;amp;/ &amp;amp;% ，这样溢出部分就会丢掉，不会出错，比如：
var willOverflow = UInt8.max
willOverflow = willOverflow &amp;amp;+ 1 // = 0

// 类型
let b1 = true
let i32: Int32 = 6
let f64: Float64 = 3.1415

// 字符串
let str = &amp;quot;swift&amp;quot;
// 字符串连接，使用\()
var hello = &amp;quot;hello \(str)&amp;quot;
let count = str.characters.count
let c = hello[hello.startIndex]
for i in hello.characters.indices {
    print(&amp;quot;\(hello[i])&amp;quot;)
}

hello.insert(&amp;quot;!&amp;quot;, atIndex: hello.endIndex)
hello.insertContentsOf(&amp;quot; there&amp;quot;.characters, at: hello.endIndex.predecessor())
hello.removeAtIndex(hello.endIndex.predecessor())
hello.hasPrefix(&amp;quot;hello&amp;quot;)
hello.hasSuffix(&amp;quot;swift&amp;quot;)

let unicode = &amp;quot;你好 swift&amp;quot;
unicode.characters.count // 8

for codeUnit in unicode.utf8 {
    print(&amp;quot;\(codeUnit)&amp;quot;, terminator: &amp;quot;&amp;quot;)
}
if hello == unicode{

}

// 数组
var shoppingList = [&amp;quot;test&amp;quot;, &amp;quot;book&amp;quot;, &amp;quot;bike&amp;quot;]
shoppingList[2] = &amp;quot;joke&amp;quot;
shoppingList.append(&amp;quot;bus&amp;quot;)
shoppingList.insert(&amp;quot;foo&amp;quot;, atIndex: 0)
shoppingList.removeAtIndex(0)

// 类似 slice
shoppingList[0..&amp;lt;2] // [&amp;quot;test&amp;quot;, &amp;quot;book&amp;quot;]
shoppingList[0...2] // [&amp;quot;test&amp;quot;, &amp;quot;book&amp;quot;, &amp;quot;joke&amp;quot;]

for item in shoppingList {
    print(item)
}

for (index, value) in shoppingList.enumerate() {
    print(&amp;quot;\(index): \(value)&amp;quot;)
}

let emptyArray = [String]()
var someInts = [Int]()
var someInts2 = [Int](count: 3, repeatedValue: 8) // [8, 8, 8]
var someInts3 = [Int](count: 3, repeatedValue: 2)

// 任意类型数组
var anyArray = [Any]()
anyArray.append(1)
anyArray.append(&amp;quot;book&amp;quot;)

someInts = someInts2 + someInts3 // [8, 8, 8, 2, 2, 2]

// 元组
let httpResponse = (404, &amp;quot;Not Found&amp;quot;)
print(httpResponse.0)

// 集合 Sets
var setBooks: Set&amp;lt;String&amp;gt; = [&amp;quot;book1&amp;quot;, &amp;quot;book2&amp;quot;]
// 自动推导
var setBooks2: Set = [&amp;quot;book1&amp;quot;, &amp;quot;book2&amp;quot;, &amp;quot;book3&amp;quot;]

setBooks.intersect(setBooks2)  // 交集
setBooks.exclusiveOr(setBooks2)  // 非交集
setBooks.union(setBooks2)  // 并集
setBooks.subtract(setBooks2)  // 减集

setBooks.isSubsetOf(setBooks2)
setBooks2.isSupersetOf(setBooks)
setBooks.isStrictSubsetOf(setBooks2)  // 被包含且不相等

// 字典
var map = [
    &amp;quot;Malcolm&amp;quot;: &amp;quot;hehe&amp;quot;,
    &amp;quot;Keylee&amp;quot;: 123,
]
map[&amp;quot;Keylee&amp;quot;] = 166

var namesOfInt = [Int: String]()
namesOfInt[10] = &amp;quot;ten&amp;quot;

if let oldValue = namesOfInt.updateValue(&amp;quot;Ten&amp;quot;, forKey: 10) {
    print(&amp;quot;\(oldValue)&amp;quot;)
}

if let name = namesOfInt[8] {
    print(&amp;quot;\(name)&amp;quot;)
} else {
    print(&amp;quot;not exist 8&amp;quot;)
}

for (intKey, strValue) in namesOfInt {
    print(&amp;quot;\(intKey):\(strValue)&amp;quot;)
}

// namsOfInt.values
for intKeys in namesOfInt.keys {

}

let intKeys = [Int](namesOfInt.keys)

// 可空变量，用 ?
var optionalString: String? = nil

if let name = optionalString {
    print(&amp;quot;hello \(name)&amp;quot;)
}

// 3. 流程控制
// 循环
// [0, 4)
for i in 0..&amp;lt;4 {
    print(&amp;quot;print \(i)&amp;quot;)  // 4 times
}

// [0, 4]
for i in 0...4 {
    print(&amp;quot;print \(i)&amp;quot;)  // 5 times
}

var i = 0
while i &amp;lt; 2 {
    print(&amp;quot;\(i)&amp;quot;)
    i += 1
}

repeat {
    print(&amp;quot;\(i)&amp;quot;)
    i += 1
} while i &amp;lt; 5

// 判断
if i &amp;lt; 5 {

} else if i &amp;lt; 10 {

} else {

}

// 强大的 switch
// 不需要 break
switch i {
case 1, 2, 3:
    print(&amp;quot;123&amp;quot;)
case 5:
    print(&amp;quot;5&amp;quot;)
case 6..&amp;lt;10:
    print(&amp;quot;6-9&amp;quot;)
default:
    print(&amp;quot;default&amp;quot;)
}

let somePoint = (1, 1)

switch somePoint {
case (0, 0):
    print(&amp;quot;0, 0&amp;quot;)
case (_, 1):
    print(&amp;quot;y is 1&amp;quot;)
case (-2...2, -2...2): // 区间
    print(&amp;quot;from (-2,-2) to (2, 2)&amp;quot;)
case (let x, 0):  // 值绑定
    print(&amp;quot;\(x)&amp;quot;)
case let (x, y) where x == y:  // where
    print(&amp;quot;x == y&amp;quot;)
case (10, 11):
    fallthrough  // 贯穿，继续向下
default:
    print(&amp;quot;default&amp;quot;)
}

// 控制转移
// continue break fallthrough retrun throw

// 带标签
i = 0
gameLoop: while i &amp;gt; -1 {
    i = i + 1
    if i &amp;gt; 3 {
        break gameLoop
    }
}

// 提前退出(提前返回)
func greet(person: [String:String]) {
    guard let name = person[&amp;quot;name&amp;quot;] else {
        return
    }
    print(&amp;quot;\(name)&amp;quot;)
}

greet([&amp;quot;age&amp;quot;:&amp;quot;18&amp;quot;])

// 4. 函数
func greet(name: String, day: String) {
    print(&amp;quot;Hello \(name), today is \(day)&amp;quot;)
}

// 第二个参数默认需要指定名称
greet(&amp;quot;tom&amp;quot;, day: &amp;quot;2016&amp;quot;)

func sum(a: Int, b: Int) -&amp;gt; Int {
    return a + b
}

sum(1, b: 2)

// 多重返回值
func minMax(array: [Int]) -&amp;gt; (min: Int, max: Int) {
    // ...
    return (0, 1)
}

// 可选返回值加 ?
func minMax2(array: [Int]) -&amp;gt; (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    return (0, 1)
}

// 指定外部参数名
func sayHello(to person: String, and anotherPerson: String) {
    print(&amp;quot;Hello \(person) and \(anotherPerson)&amp;quot;)
}

sayHello(to: &amp;quot;coderzh&amp;quot;, and: &amp;quot;tom&amp;quot;)

// 忽略外部参数名，使用 _
func sayHello2(person: String, _ anotherPerson: String) {
    print(&amp;quot;Hello \(person) and \(anotherPerson)&amp;quot;)
}

sayHello2(&amp;quot;coderzh&amp;quot;, &amp;quot;jack&amp;quot;)

// 默认参数
func someFunction(p: Int = 10) {
    print(&amp;quot;\(p)&amp;quot;)
}

someFunction()

// 可变参数
func sum(numbers: Int...) -&amp;gt; Int {
    var total = 0
    for n in numbers {
        total += n
    }

    return total
}

sum(1, 2, 3, 4, 5)

// 参数默认是常量类型，如需指定变量类型，前面加 var（swift 3 将移除 var）
func alignRight(var string: String, totalLength: Int, pad: Character) -&amp;gt; String {
    string = string + &amp;quot;!&amp;quot;
    return string
}

// 传入传出参数 inout
func swap(inout a: Int, inout _ b: Int) {
    let temp = a
    a = b
    b = temp
}

var someInt = 7
var anotherInt = 8

// inout 参数必须加 &amp;amp;
swap(&amp;amp;someInt, &amp;amp;anotherInt)

// 函数类型，函数变量
var sumFunc: (Int, Int) -&amp;gt; Int = sum
sumFunc(1, 2)

// 函数可做参数
func doSum(handler:(Int, Int) -&amp;gt; Int, _ a: Int, _ b: Int) {
    handler(a, b)
}

// 函数可做返回值
func getSum() -&amp;gt; (Int, Int) -&amp;gt; Int {
    // 函数可嵌套
    func someFunc(a: Int, b: Int) -&amp;gt; Int { return a + b }
    return someFunc
}

doSum(sum, 2, 3)

// 闭包
// 闭包是引用类型
let reversed2 = shoppingList.sort({a, b in a &amp;lt; b})
let r = shoppingList.sort({ $0 &amp;lt; $1 })
let r2 = shoppingList.sort(&amp;lt;)
let r3 = shoppingList.sort{ $0 &amp;lt; $1 }

// 非逃逸闭包（noescape closure）
// 闭包只能在函数内执行，不能「逃逸」出去
func someClosure(@noescape closure: () -&amp;gt; Void) {
    closure()
}

// 自动闭包（这样不用写花括号了？）
func autoClosure(@autoclosure provider: () -&amp;gt; String) {
    provider()
}

autoClosure(shoppingList.removeAtIndex(0))

// 5. 枚举（一等公民，十分强大）
// 值类型
enum Rank: Int {
    case Ace = 1
    case Two, Three
}

var ace = Rank.Ace  // Ace
Rank.Ace.rawValue  // 1
let ace1 = Rank(rawValue: 1)  // Ace
ace = .Two

enum ServerResponse {
    case Result(String, String)
    case Error(String)
}

// 可失败构造器
enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case &amp;quot;K&amp;quot;:
            self = .Kelvin
        case &amp;quot;C&amp;quot;:
            self = .Celsius
        case &amp;quot;F&amp;quot;:
            self = .Fahrenheit
        default:
            return nil
        }
    }
}


let success = ServerResponse.Result(&amp;quot;6:00am&amp;quot;, &amp;quot;6:00pm&amp;quot;)
let failure = ServerResponse.Error(&amp;quot;Out of cheese&amp;quot;)

switch success {
case let .Result(sunrise, sunset):
    let serverResponse = &amp;quot;sunrise at \(sunrise), sunset at \(sunset)&amp;quot;
case let .Error(error):
    let serverResponse = &amp;quot;Error \(error)&amp;quot;
}

// 枚举递归...
enum ArithmeticExpression {
    case Number(Int)
    indirect case Addition(ArithmeticExpression, ArithmeticExpression)
    indirect case Multiplication(ArithmeticExpression, ArithmeticExpression)
}

func evaluate(expression: ArithmeticExpression) -&amp;gt; Int {
    switch expression {
    case .Number(let value):
        return value
    case .Addition(let left, let right):
        return evaluate(left) + evaluate(right)
    case .Multiplication(let left, let right):
        return evaluate(left) * evaluate(right)
    }
}

// 计算 (5 + 4) * 2
let five = ArithmeticExpression.Number(5)
let four = ArithmeticExpression.Number(4)
let sum2 = ArithmeticExpression.Addition(five, four)
let product = ArithmeticExpression.Multiplication(sum2, ArithmeticExpression.Number(2))
print(evaluate(product)) // 输出 &amp;quot;18”

// 6. 类和结构体
// 结构体是值类型，类是引用类型
class SomeClass {
    var width = 0
    var height = 0

    // class 不需要 mutating
    func incrementWidth() {
        self.width += 1
    }

    // 下标操作： [n]
    subscript(index: Int) -&amp;gt; Int {
        get {
            return 0
        }
        set(newValue) {
            // set from newValue
        }
    }
}

let s1 = SomeClass()

struct SomeStruct {
    static var someValue = 100
    static func staticFunc() -&amp;gt; Int {
        return 1
    }

    var x = 0
    var y = 0

    var doubleX: Int {
        get {
            return x * 2
        }
        set {
            x = newValue / 2
        }
    }

    // readonly
    var doubleY: Int {
        return y * 2
    }

    var total: Int {
        willSet(newTotal) {
            print(&amp;quot;will set \(newTotal)&amp;quot;)
        }

        didSet {
            print(&amp;quot;old: \(oldValue), new: \(total)&amp;quot;)
        }
    }

    // 如果会改变类成员，比如声明 mutating
    mutating func incrementX() {
        self.x += 1
    }
}

var s2 = SomeStruct(x: 2, y: 3, total: 10)
s2.doubleX = 10  // s2.x == 5
s2.total = 5

// 继承
class Animal {
    // 构造函数
    init() {

    }

    // 必要构造器，子类必须实现，而且声明为 required
    required init(name: String, age: Int) {

    }

    func makeNoise() {
        print(&amp;quot;wowowo&amp;quot;)
    }
}

class Cat: Animal {
    var name: String = &amp;quot;&amp;quot;
    var nickName: String = &amp;quot;&amp;quot;

    init(name: String) {
        super.init()
        self.name = name
    }

    init(fromNickName nickName: String) {
        super.init(name: nickName, age: 18)
        self.nickName = nickName
    }

    // 便利构造器：必须调用其他构造器
    convenience override init() {
        self.init(name: &amp;quot;UnKnown&amp;quot;)
    }

    // 可失败构造器
    init?(age: Int) {
        super.init(name: &amp;quot;UnKnown&amp;quot;, age: age)
        if age &amp;lt; 0 { return nil }
    }

    required init(name: String, age: Int) {
        self.name = name
        super.init(name: name, age: age)
    }

    // 析构，默认会先调用父类的析构
    deinit {

    }

    override func makeNoise() {
        print(&amp;quot;miaomiaomiao&amp;quot;)
    }
}

final class CannotInheirt {

}

// 7. 自动引用计数 ARC
// weak 弱引用
// unowned 无主引用

// 8. 可空链式调用
/* For example:
if let johnsStreet = john.residence?.address?.street {
    print(&amp;quot;John&#39;s street name is \(johnsStreet).&amp;quot;)
} else {
    print(&amp;quot;Unable to retrieve the address.&amp;quot;)
}
*/
// 如果确定有值，使用!
// let roomCount = john.residence!.numberOfRooms


// 9. 错误处理

enum CustomError : ErrorType {
    case Invalid
    case OutOfRange
}

func makeASandwich() throws -&amp;gt; String {
    throw CustomError.Invalid
}

do {
    try makeASandwich()
} catch CustomError.Invalid {
    print(&amp;quot;Invalid&amp;quot;)
}

// 可空
let x = try? makeASandwich()
// 使错误传递失效，肯定不throw，否则 assert
// let y = try! makeASandwich()

// defer 和 Golang 里的 defer 一样，用来退出清理
/*
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件
        }
        // 在这里，作用域的最后调用 close(file)
    }
}
*/

// 10. 类型转换： is as （和 CSharp 类似）
// 任意类型：
// 1. AnyObject 任何 class 类型实例
// 2. Any 任何类型

// 11. 扩展（extension，类似 CSharp 里的扩展方法，但是貌似更强大）
// 比如：扩展内置类型 Double
// 几乎一切都可扩展，用到时再查用法吧
extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}

// 12. 协议（类似接口的东西）
// 当同时有继承时，先写继承，再写协议，协议可以有多个
protocol FullyNamed {
    var fullName: String { get }
}

// 协议也可继承
protocol SubFullyNamed: FullyNamed {
    var nickName: String { get }
}

struct Person: FullyNamed{
    var fullName: String
}

// 专属协议，指定只能用在 class 上
protocol ClassOnlyProtocol: class, FullyNamed {

}

protocol Aged {
    var age: Int { get set }
}

// 协议合成
func foo(pro: protocol&amp;lt;FullyNamed, Aged&amp;gt;, base: Any) {
    // 协议判断
    if let p = base as? Aged {
        print(p.age)
    }
}

// 可选协议（既然是协议，还可选，醉了）
// @objc protocol

// 13. 泛型
func swapTwoValues&amp;lt;T&amp;gt;(inout a: T, inout _ b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}

// 泛型约束
func someFunction&amp;lt;T: SomeClass, U: FullyNamed&amp;gt;(someT: T, someU: U) {
    // 这里是函数主体
}

// Where
/*
func allItemsMatch&amp;lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&amp;gt;
    (someContainer: C1, anotherContainer: C2) -&amp;gt; Bool {
}
*/

// 14. 访问控制
// public internal（默认） private
// 加在 class var 等前
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>程序员的黄金时代</title>
            <link>http://blog.coderzh.com/2016/04/17/gold-time-of-programmer/</link>
            <pubDate>Sun, 17 Apr 2016 08:47:35 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/04/17/gold-time-of-programmer/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/goldtime.jpg&#34; alt=&#34;goldtime&#34; /&gt;&lt;/p&gt;

&lt;p&gt;（第一次尝试写小说，本文仅向王小波致敬，情节纯属虚构，切勿对号入座。）&lt;/p&gt;

&lt;p&gt;我叫张三，身高 1.9 米，不要看我身材高大，我的手可细的很。我敲键盘的速度可以达到 APM 666，不带一个按错的键。其实可以达到更高，但我对 666 这个数字情有独钟。&lt;/p&gt;

&lt;p&gt;你也许猜到了，我是一个程序员。我在全球第一的软件公司上班，公司名字叫「猎狗」。我觉得这个名字很贴切，适合大多数的程序员和产品经理前来工作，我就是其中一个。&lt;/p&gt;

&lt;p&gt;「小黄」是我在公司的花名，每个进公司的员工都会分配一个花名，我被随机抽到了「小黄」这个花名，但是我不喜欢。每次别人叫我小黄，我都要解释我不姓黄，他们总是抿抿一笑。&lt;/p&gt;

&lt;p&gt;我在公司升职的很快，从 D1 到 D6，我只用了 3 年的时间（心智正常的程序员一般需要 10 年）。不是因为我写代码又快又好，也不是我的代码让公司产品占据一个又一个 Store 畅销榜单第一。我写的代码没什么技术含量，因为榜单基本靠刷。&lt;/p&gt;

&lt;p&gt;我升职快的原因是讨老板喜欢。只要老板出席的会议，我总是第一个到。我会把老板说过的每句话都记下来，一字不差，会后还会组织大家学习，深刻领悟老板提到的每一个方法论。&lt;/p&gt;

&lt;p&gt;公司群里只要老板一发话，我总是第一个回复我来解决。只要产品一出问题，我总能说成是别人的锅。我会仔细揣摩老板发的每一条朋友圈，精准定位老板的喜好，投其所好。一旦发现老板开始发表观点了，点赞和转发是不够的，我还会第一时间准备上万字的软文往各大网站和社交媒体里发。&lt;/p&gt;

&lt;p&gt;曾经有一次我写代码的时候睡着了，把错误的代码提交到了上线系统。用户投诉一个接着一个，我被老板的电话叫醒，我一拍桌子，愤愤的说到：「他妈的昨天隔壁老王写的什么狗屎代码，老板你不用担心，我分分钟就可以搞定！」&lt;/p&gt;

&lt;p&gt;我用了 1 个小时理解了昨天写的代码，然后真的只用了 1 分钟就修复了 Bug。我十分得意，为此老板在给全公司的邮件里表扬了我，还许诺今年的优秀员工、重大技术突破奖非我莫属。他后来确实做到了，这点看来是很诚信的。当然，被我栽赃的王二也被开除了。&lt;/p&gt;

&lt;p&gt;类似的事情实在太多，我不能再细说下去，我怕你们学了去我丢了饭碗。我认为这是程序员最好的黄金时代，像我这样的三流程序员也可以在全球第一的公司里混的风生水起。然而我还是想错了。有一天，我收到了 HR 寄来的解雇信，没有一点征兆。&lt;/p&gt;

&lt;p&gt;我想一定是搞错了，解雇老板的可能性或许还要高一些，要解雇我，必须给我一个理由。我思前想后，觉得不对劲。距离上次我在软件出错对话框里弹老板裸照已经过去一年了，虽然我只设了老板一个人的白名单，同事也一直没有揭发过我。&lt;/p&gt;

&lt;p&gt;我想是「二蛋」告的密，他一定是眼红我。但我还是要找老板问个究竟。我找到老板，老板「啪」的一声拿出一叠打印好的 A4 纸，说到：「看看！这都是什么！」&lt;/p&gt;

&lt;p&gt;我只见最上面的一张纸工工整整的写到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;secret_key = &#39;6ICB5p2/5piv5Liq5aSnU0I=&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我大惊失色，「老板，这可是掌握公司上亿数据的加密密钥，可不带这么随便打印出来，万一让人捡了去，可不好了。」&lt;/p&gt;

&lt;p&gt;老板根本没有理睬我，继续问道：「这行代码是你写的不？」&lt;/p&gt;

&lt;p&gt;对于公司保密性最高的代码，也只能是我写的了，我只好承认。&lt;/p&gt;

&lt;p&gt;这时老板哼了一声，显得有点得意：「别以为我不知道，这段密钥是一个 Base64 加密过的字符串，我写了一个小程序，解密了一下，你过来看看！」&lt;/p&gt;

&lt;p&gt;我很好奇老板居然懂 Base64 加密，更好奇他还会写代码。我知道了，一定是二蛋写好的代码发给了老板。我凑过去看，老板找了半天没找到点哪个按钮可以执行，然后我告诉了他。接着，屏幕的赫赫的输出了解密的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;老板是个大SB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我突然想起来了，确实有这么回事，但我不能承认，说到：「老板，这你也相信？」&lt;/p&gt;

&lt;p&gt;老板：「这程序执行的结果千真万确，『老板是个大SB』绝对没错。 」&lt;/p&gt;

&lt;p&gt;我噗呲一笑，又感觉不太好，气氛有点尴尬，正想怎么把这事推到二蛋身上。老板继续发飙起来，你看看后面的，比如这个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;!-- 老板是个大SB --&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有这个单元测试案例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def test_stupid_boss(self):
    self.assertEquals(&#39;老板是个大SB&#39;, dog_company().get_boss())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我看着这些代码，心里想着我的代码写的还是不错的，代码工整，命名也很规范。我和老板说：「有人要诬陷我。」&lt;/p&gt;

&lt;p&gt;「整个公司就你写单元测试，刚才的测试代码除了你写的，还能有谁？」&lt;/p&gt;

&lt;p&gt;这时老板的逻辑性变的强了起来。的确，这一点我无可辩驳，暗暗发誓以后再也不写什么单元测试了，都是害人的东西。&lt;/p&gt;

&lt;p&gt;「那你怎么确认不是别人偷偷改了我的代码？」&lt;/p&gt;

&lt;p&gt;「这里的每一行我都 git blame 过了，就是你写的！」&lt;/p&gt;

&lt;p&gt;我突然有种感觉，老板也不是那么 SB，至少逻辑性非常强。我正打算和他解释 git 的 commit log 也是可以随便修改的，老板只和我说了一句「滚！」。&lt;/p&gt;

&lt;p&gt;在猎狗公司，只要老板说出「滚」字，你是不能进行任何辩驳的，就像一道圣旨，没有任何回旋的余地。也不会有任何回旋的余地，因为假如我没有滚，就相当于老板承认了是大 SB 的事实。我也必须滚，因为我还在更多的代码里藏了骂他的话，骂的更不堪入目，假如哪天他发现了，我还是得滚。&lt;/p&gt;

&lt;p&gt;有人问我，老板对你这么好，为什么还骂他？我说我没有，我只是说了实话。&lt;/p&gt;

&lt;p&gt;生活还得继续，我依然相信现在是我的黄金时代，像我这种高高级开发狗，肯定会有大量的公司抢着要。然而我还是想错了。&lt;/p&gt;

&lt;p&gt;那天我来到程序猿拍卖基地，和很多程序员站成一排，等待上台拍卖，希望被好的雇主看中。我们被分成了几个组，由于我之前在猎狗公司工作过，自然被分配到了狗组。我看见对面站了一排人，他们左顾右盼，不停的用眼角余光警惕别人，时而露出奸诈的微笑，他们是狼组。最受雇主青睐的一个组。&lt;/p&gt;

&lt;p&gt;我和拍卖基地的人说，我应该属于狼组，我凶的很，警惕性高，写代码可以不休息，进攻性也强，把我派去竞争对手公司做卧底分分钟将它搞垮。我说了很多，他们说你说什么没用，他们说你是狗，你就是狗。我看看对面的一群即将失业的羊组，想想还是有道理的。&lt;/p&gt;

&lt;p&gt;轮到我上台了，主持人开始介绍我：「张三，猎狗高高级开发狗，&amp;hellip;&amp;hellip; 离职原因：在代码里辱骂老板是大SB。」我的天，本来以为三路破塔拿下高地只是分分钟的事情，想不到猎狗的老板还给我来了这么一出，感觉就像被剑圣偷了基地。雇主们纷纷灭灯，我闭上眼睛，等待导播放「可惜不是你」。&lt;/p&gt;

&lt;p&gt;最后我被一个雇主雇佣了，原因是他在听介绍时睡着了没有灭灯，也不知道我辱骂老板的事。这家公司叫「巨狼」，是个游戏公司。我顺理成章的从狗晋升到了狼，十分高兴。&lt;/p&gt;

&lt;p&gt;我被分配到了开宝箱组，每天的任务就是写游戏里开宝箱的功能。我和老板说，开宝箱涉及到人工智能、大数据分析、心理学、社会学等众多领域，技术难度高，开发时间长，吸金能力强，所以得加钱加人。老板是聪明人，说：「叫你写开宝箱，别叽叽歪歪。」我不确定我是不是听错了，这不是羊才干的事情的吗？但老板就是老板，肯定比我高瞻远瞩，我不敢骂他，偷偷的也不行。&lt;/p&gt;

&lt;p&gt;有一天我去 UI 组提宝箱界面需求，是一个面容清秀的 UI 妹子，她叫陈清羊。我提完需求后正要走，她一把拉住了我，问我晚上有时间没，要找我单独谈谈。我再次不确定是不是听错了，虽然我身高 1.9，但平时邋遢的很，头发蓬松，拖着拖鞋上班，几天也不洗一次脸。我环顾四周，确认了她确实是在和我说话。淡淡的说了一句：「行吧。」&lt;/p&gt;

&lt;p&gt;陈清羊很漂亮，她肯定不会看上我，这点是可以确定的。我们在约好的咖啡厅见面，她上来就说，「别人都说我和老板有一腿，可是我不是，你能帮我证明吗？」原来是她看我天天写开宝箱比较老实，没有像其他同事一样天天去骚扰她，就想找我证明。&lt;/p&gt;

&lt;p&gt;「别人都说你和老板有一腿，那就是有一腿，没有什么好辩驳的。」&lt;/p&gt;

&lt;p&gt;「可是我没有啊，而且我也不认为和老板有一腿有什么不好的。」&lt;/p&gt;

&lt;p&gt;「你看你面色红润，ru 房高耸，穿着时髦，时不时往老板办公室里钻，上班比谁都晚，下班比谁都早，升职比谁都快。就是我也相信你和老板有一腿啊。」&lt;/p&gt;

&lt;p&gt;陈清羊看我分析的头头是道，但回想到我夸她的用词，脸上泛出一道红晕。&lt;/p&gt;

&lt;p&gt;「要是你每天像我蓬头垢面，别人上班你下班，就没有人再说你。」&lt;/p&gt;

&lt;p&gt;之后，陈清羊还是经常来找我，要我证明。这样一来，在同事间反倒传出了我和她的绯闻来。绯闻闹的越厉害，她越是不怕，越是来找我。&lt;/p&gt;

&lt;p&gt;她和我说，同事都说她和我有一腿，要我证明没有。我想了想，说到：「我倒挺希望证明有。」她有点生气，她并不介意有一腿，介意的是没有的事，却被别人说成了有，感觉吃了亏。&lt;/p&gt;

&lt;p&gt;那天晚上我和她讲了很多故事，特别是水泊梁山的故事。我和她说，义气就是不管你是什么人，有多坏，都会无条件的支持你。我称它为「伟大友谊」，我和她就是伟大友谊。她听了很感动，仿佛某根神经被电触到，对我说的话深信不疑。&lt;/p&gt;

&lt;p&gt;我心里一阵窃喜，看了看外面，天色已晚，接着说到：「我来公司这么久了，一直都是一个人，有件事情，只有你才能帮我。」&lt;/p&gt;

&lt;p&gt;陈清羊的脸更红了，她知道是什么，为了伟大友谊，她什么都可以做。于是我们不约而同的拿出了笔记本电脑，我写代码她画画。我接了个私活，就缺一个设计师。&lt;/p&gt;

&lt;p&gt;我们接了不少私活，赚了不少钱。别人都知道我和她接私活，也就不再说有一腿的事了。后来有人向老板举报，老板要我们交代事情经过，不能遗漏任何一个细节。我把所有细节都交代了，唯独没有交代那天我指着陈清羊的设计稿大骂「什么狗屁设计」这件事，老板更关心的是敦伟大友谊的细节。&lt;/p&gt;

&lt;p&gt;后来陈清羊也交了一份自我检讨的材料上去，第二天我们就被开除了。老板给了我们 N+10 补偿，叫人帮我们收拾好，还特定送我们出了公司。&lt;/p&gt;

&lt;p&gt;我和陈清羊开了一家游戏公司，公司里没有狼，没有狗，也没有羊，只有人。现在公司已经有 168 人，一年的利润有 12 亿美元。我们的公司名叫「超级人」，我们尊重公司里的每个人，我们用正确的方式激励员工，发挥他们最大的创造力。他们工作的很开心，既实现了人生的价值，又收获了财富。&lt;/p&gt;

&lt;p&gt;陈清羊说，这是她的黄金时代，特别怀念当时敦伟大友谊时的紧张和兴奋。&lt;/p&gt;

&lt;p&gt;但是有一件事情我一直不敢问她，就是当年她写的那份材料到底写的什么，会让老板给了我们 N+10 的补偿，才有了第一笔启动资金。直到我去参加她和老板的婚礼，我才有勇气问她。&lt;/p&gt;

&lt;p&gt;她说，她只写了一件事。就是关于那天我指着她的设计稿，毫不留情面的大骂「什么狗屁设计」的这件事。在检讨材料里她写道，我骂她的一瞬间，她觉得如春藤绕树，小鸟依人，再也不想理会别的事，就在那一瞬间，她已经把一切都遗忘，她已经爱上我了，而且这件事永远都不能变。&lt;/p&gt;

&lt;p&gt;之后我再也没见过她。这就是我的黄金时代，一个程序员的黄金时代。&lt;/p&gt;

&lt;p&gt;题图摄影：chillmimi&lt;/p&gt;

&lt;p&gt;图片授权基于：CC BY 2.0 协议&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>7-Eleven 零售的哲学</title>
            <link>http://blog.coderzh.com/2016/04/10/7-eleven/</link>
            <pubDate>Sun, 10 Apr 2016 21:57:06 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/04/10/7-eleven/</guid>
            <description>

&lt;p&gt;1956 年 4 月，有为青年「铃木敏文」大学毕业，进入东京出版贩卖公司，从「退货负责人」到「出版科学研究所」，再到宣传部杂志「编辑」，生活过的充实有趣。在三十岁之际，铃木打算不依靠公司，以自身的力量制作一个独立的电视节目。&lt;/p&gt;

&lt;p&gt;铃木找到了赞助商「伊藤洋华堂」，一个经营大型商场的公司。「伊藤洋华堂」总部的人和铃木说：「就在我们这里完成这一项目怎样？」&lt;/p&gt;

&lt;p&gt;于是，铃木辞去旧工作，入职「伊藤洋华堂」，准备在电视节目上大展拳脚，却发现公司只是「说说而已」，他的电视节目变成了「将来再说」。&lt;/p&gt;

&lt;p&gt;虽然发现自己入了坑，但是铃木本着「干一行，爱一行」的精神，从一个零售业完全的门外汉开始认真的学习起这个行业。&lt;/p&gt;

&lt;p&gt;当时，经营新兴综合超市的伊藤洋华堂尚处于发展阶段，铃木在这个成长型企业兼顾了推广、宣传、人事、财务等几乎所有管理职务。20 世纪 60 年代后期，大型超市迎来了快速增长的繁荣期，而小型超市的状况也日渐惨淡。&lt;/p&gt;

&lt;p&gt;某一天，公司组织员工到美国研修，铃木在前往加利福尼亚的路上，进入一家小店休息，这家店的名字就叫：7-Eleven。 这个小型超市各种食品、生活杂物应有尽有，还真是便利啊。这给铃木留下了深刻的印象，不禁感叹：「没想到美国居然还有那么小的店啊。」&lt;/p&gt;

&lt;p&gt;铃木明白，日本小型超市经营惨淡的原因并非大型超市的竞争，而是自身服务的落后。他看到了日本「老龄化」，「少子化」，购物不便的趋势，看清了市场正从卖家市场转变为买家市场。&lt;/p&gt;

&lt;p&gt;为了证明小型超市只要为客户提供足够的便利，是完全可以和大型超市共存。铃木回国之后，说服总部加盟美国 7-Eleven（美国南方公司）。随后，1974 年 5 月 15 日，日本首家真正意义上的便利店 7-Eleven 开业。&lt;/p&gt;

&lt;p&gt;经过铃木独到的经营，7-Eleven 在日本大受欢迎。营业额直接超过了总部伊藤洋华堂，之后由于美国 7-Eleven 经营不善，作为子公司的日本 7-Eleven 直接把美国 7-Eleven 收购，上演了子公司吞并母公司的神话。如今的 7-Eleven 已经遍布世界各地，为各地的人们提供便捷的服务。&lt;/p&gt;

&lt;p&gt;为什么一个零售行业、流通行业的门外汉，上演了这一零售行业的奇迹？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大多数人反对的事业往往能够获得成功&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;他坚持己见，认定的事情就一定要做到：&lt;/p&gt;

&lt;p&gt;为了让顾客能在便利店使用 ATM 取款机，铃木力排他异，专门开了一家银行只为顾客能在便利店取款。&lt;/p&gt;

&lt;p&gt;为了更高效的物流及工厂供应，他坚持密集型选址开设分店，并没有选址盲目的扩张。&lt;/p&gt;

&lt;p&gt;引入 POS 系统，让门店的零时工也能直接参与订货。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比起「价廉」，更看重「物美」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了让顾客随时享受到新鲜美味的食物，他坚持专属产品研发工厂，365 天 24 小时保持供应，对上架的食品进行严格把关，必须经过管理层试吃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不是「为了顾客」，而是要站在顾客的立场考虑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;铃木主张从「等待型经营」转变为「进攻型」经营，提供「送货上门服务」和「网络零售」，在店里提供「打印复印」、「代收水电煤气」、「税金缴纳」、「免费 WIFI」等服务。&lt;/p&gt;

&lt;p&gt;这些今天看来司空见惯的东西在当时可是相当创新的。&lt;/p&gt;

&lt;h3 id=&#34;零售的哲学:33b04dcd5bf6f530f0f329b8789dcba3&#34;&gt;零售的哲学&lt;/h3&gt;

&lt;p&gt;《零售的哲学》这本书是铃木的自述，字里行间透露出了他深刻领悟用户需求，独到的想法，不管多难坚持付诸执行的决心。&lt;/p&gt;

&lt;p&gt;我从他的自述里看到了诚恳，做一件事就认真做到最好的态度。不是站在很高的高度指导他人传授成功的经验，而只是从自身出发，讲述当初遇到的困难及处理方法。&lt;/p&gt;

&lt;p&gt;铃木从来都没有喜欢过零售行业，他没有抱怨，想法很简单：既然做了，就要做到最好。&lt;/p&gt;

&lt;p&gt;我们程序员，并不从事零售行业，也能从铃木的自述里得到一些启发。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我如何管理我的笔记</title>
            <link>http://blog.coderzh.com/2016/04/09/how-i-manage-my-notes/</link>
            <pubDate>Sat, 09 Apr 2016 14:57:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/04/09/how-i-manage-my-notes/</guid>
            <description>

&lt;p&gt;我们从小就被教育：「好记性不如烂笔头。」我是一个笔记重度用户，也许是从小培养的习惯，喜欢把有意思的东西记在本子里。记录笔记有一种成就感，像玩游戏达成一个又一个成就。&lt;/p&gt;

&lt;p&gt;而如今网络如此发达，大多数的答案都可以通过你问出正确的问题得到解答。凯文·凯利在他的《必然》里有提到，未来，我们不缺乏答案，缺的是问出好的问题。Google 几乎索引了我们想要知道的所有问题的答案（百度索引了所有的相反答案），所以，理论上，我们不再需要记录自己的笔记。&lt;/p&gt;

&lt;p&gt;但事实却并不是这样的，首先，在中国，想要访问 Google 不是一件容易的事情。即使你功夫很好可以畅通无阻的访问，通过 Google 依然不是你最快捷获取已有知识的方式。因为你曾经在 Google 搜索结果里翻了好几页才找到的答案，下次搜索时还要再找一遍，效率是不高的。&lt;/p&gt;

&lt;p&gt;所以，记录笔记的需求一直都在。但是用纸记录笔记已经不适合。每次搬家或清理时，曾经写满笔记的小本子都会被我遗弃掉，如果不翻开那些小本子，我几乎不会记得我曾经记录过什么东西。一旦那些纸质笔记本被我扔掉，之前记录的所有笔记内容都会从我的记忆中抹去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，用软件记录笔记是目前唯一正确的选择。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我尝试过各种笔记软件，其中「为知笔记」使用了最久，最早是因为他支持目录树的分类，后来是因为他支持直接写 Markdown。但前不久，我把我的几百篇为知笔记导出了（Windows 版支持导出），我打算以一种全新的方式来管理我的笔记。&lt;/p&gt;

&lt;p&gt;既可以说是「全新」，也是可以说是用最「原始」的方式管理笔记。即在本地完全由纯文本的方式来进行笔记管理。这种方式不再依赖任何一个笔记软件。&lt;/p&gt;

&lt;h3 id=&#34;所有的软件都不可靠:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;所有的软件都不可靠&lt;/h3&gt;

&lt;p&gt;现有的所有笔记软件给我们一种假象：我们可以永远记录下去。事实并非如此，现在科技发展如此之快，公司被淘汰的速度也在加速，很有可能现在最流行的笔记软件几年后就关门大吉。&lt;/p&gt;

&lt;p&gt;现在市面上大多数的笔记软件的文件存储都是使用私有格式，一旦它停止服务，你只能寄希望于它提供的导出功能，然后盼望着另外一家笔记软件能导入这些笔记。&lt;/p&gt;

&lt;p&gt;类似的事情不断的在发生着，比如之前我最喜欢的 RSS 订阅服务 Google Reader。出自 Google 这样的大公司，用户体验各方面都做的非常好，但是 2013 年 7 月，Google 以运营成本太大，需求太小众，没有盈利模式等缘由将其永久的关闭了。作为 Google Reader 粉，不得不将订阅列表导出，不情不愿的迁移到 feedly 这样的服务。&lt;/p&gt;

&lt;p&gt;又比如，前不久，Facebook 宣布即将关闭著名的后台即服务（Baas）框架 Parse。Parse 作为全球最受欢迎的 Baas 服务，2013 年被 Facebook 收购后，由于 Facebook 自身业务需要，宣布 2017 年 1 月 28 日正式关闭。&lt;/p&gt;

&lt;p&gt;这将导致之前所有使用 Parse 服务的软件重新去考虑迁移的事宜。而事实上有很多软件已工作多年，而且几乎不再维护，一旦关闭，如果不进行迁移维护，那些软件将会失效。&lt;/p&gt;

&lt;h3 id=&#34;回归原始:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;回归原始&lt;/h3&gt;

&lt;p&gt;使用纯文本在本地进行笔记管理，是最原始的笔记方式。你不必再担心笔记软件停止服务后你的笔记在哪里的问题。你也不依赖于任何一款笔记编辑软件，因为任何文本编辑器都可以直接进行笔记编辑。&lt;/p&gt;

&lt;p&gt;当然，在本地管理笔记必须解决几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;能不能很好的搜索笔记内容？&lt;/li&gt;
&lt;li&gt;能不能支持多平台的同步和编辑？（PC和移动端的编辑和同步）&lt;/li&gt;
&lt;li&gt;能不能保证笔记文件不丢失？&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;笔记搜索:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;笔记搜索&lt;/h4&gt;

&lt;p&gt;从本地文件夹里搜索文件，或者搜索文件里的内容，有很多的工具。这些工具都是可替代的，即使所有 GUI 的工具软件都不能用了，我们还有 find 和 grep 命令。&lt;/p&gt;

&lt;p&gt;Mac 下支持 Markdown 的笔记软件多如牛毛，支持本地文档库管理的笔记软件相对来说少一些，比如：Ulysses、MWeb、Farbox 等等。但是这些软件我都不用，因为我直接用 Alfred 就够了。&lt;/p&gt;

&lt;p&gt;对，没有看错，是&lt;strong&gt;效率神器 Alfred&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在 Alfred 中我定制了一个笔记管理的 Workflow，当需要查找某一篇笔记时，只需要按下 &lt;code&gt;f&lt;/code&gt; 空格，输入需要检索的标题或正文关键字，Alfred 就可以直接列出对于的笔记文件，回车后即可直接打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/find-notes.png-s&#34; alt=&#34;find-notes&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;笔记编辑:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;笔记编辑&lt;/h4&gt;

&lt;p&gt;当我想记录编程相关的笔记时，只需要按下 &lt;code&gt;np&lt;/code&gt; 空格，输入文字标题，将自动在合适的路径创建一个新的笔记并打开编辑。（n = new，p = programming 分类）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/new-notes.png-s&#34; alt=&#34;new-notes&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我会用 Atom 来打开和编辑笔记文件，因为它真的很好用。在 Atom 里，安装如下几个插件，编辑 Markdown 的体验将会爽的飞起：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;markdown-preview&lt;/strong&gt; 默认自带，按快捷键 ctrl + shift + m 即可实时看到预览。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;markdown-scroll-sync&lt;/strong&gt; 配合 markdown-preview 使用，编辑时可以同步滚动预览。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tidy-markdown&lt;/strong&gt; 按保存时，自带帮你修正 Markdown 格式，让你的 Markdown 更规范。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;markdown-wirter&lt;/strong&gt; 用来管理 Markdown 文档，用来写博客会很方便。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zen&lt;/strong&gt; 神器，cmd + ctrl + z 进入无干扰书写模式，其中 Typewriter 打字机模式非常不错，当你输入到屏幕中间时，可以让输入的当前行一直保持在屏幕中间。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/atom-markdown.png-s&#34; alt=&#34;atom-markdown&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;alfred-workflow:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;Alfred Workflow&lt;/h4&gt;

&lt;p&gt;想实现上面 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;np&lt;/code&gt; 之类的功能非常简单，通过组合 Workflow 里的 FileFilter、ScriptFilter、Run Script 即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/MyNotes-Workflow.png-s&#34; alt=&#34;MyNotes-Workflow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你可以在 Alfred 的 Workflow 中定制自己的快捷键、笔记类别、笔记路径，非常的简单。如果不知道怎样定制，可以参考我的 Workflow：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/alfred-workflows&#34;&gt;https://github.com/coderzh/alfred-workflows&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;笔记多平台同步:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;笔记多平台同步&lt;/h4&gt;

&lt;p&gt;各种网盘，综合考虑后，我选择了 Dropbox。（为了能正常使用 Dropbox 需要一点功夫。）&lt;/p&gt;

&lt;h4 id=&#34;移动端同步与编辑:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;移动端同步与编辑&lt;/h4&gt;

&lt;p&gt;在支持 Dropbox 同步同时又支持 Markdown 编辑的 App 里选择，最后我选择了 &lt;a href=&#34;https://bywordapp.com/&#34;&gt;Byword&lt;/a&gt;，因为它的 Markdown 编写体验真的很好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/byword.PNG&#34; alt=&#34;byword&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;保证笔记文件不丢失:a4eed20b4e8e278ebfafe3eb338f591b&#34;&gt;保证笔记文件不丢失&lt;/h3&gt;

&lt;p&gt;除了 Dropbox 同步，我会定期使用 git 进行版本管理，Push 到自己的私人仓库里。&lt;/p&gt;

&lt;p&gt;希望本文对喜欢做笔记的同学有点帮助吧。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>所有的编程技术都会成为历史</title>
            <link>http://blog.coderzh.com/2016/04/05/programming-languages/</link>
            <pubDate>Mon, 04 Apr 2016 16:28:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/04/05/programming-languages/</guid>
            <description>&lt;p&gt;大四的时候，我用当时最新的 ASP.NET 技术给我叔写了一个服装制衣厂管理软件，这个软件用了差不多 10 年，中间几乎没有维护过，到现在还在工作。前几天突然联系我说，这个软件能不能迁移到 Win7 上使用（之前是在 XP 上），我想了想，肯定没问题啊，即使不行，在 Win7 里跑个 XP 的虚拟机也行。&lt;/p&gt;

&lt;p&gt;最后，我还是给 ASP.NET 和 IIS 跪了，出各种莫名其妙的错误，从出错的内容里根本看不出任何可追踪的信息。 一个工作了近 10 年的系统，中间迁移重装过几次，工作的很好的系统，突然告诉我一个莫名其妙的错误，我猜八成是 .NET 或 IIS 的 Bug，关于 ASP.NET 的技术我已经忘光了，而且我再也不想在 .NET 上浪费光阴了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;于是我想，当时看来挺不错的技术，几年后，或者十年后，会变成怎样。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，著名的后端即服务（baas）的框架 &lt;a href=&#34;https://parse.com&#34;&gt;Parse&lt;/a&gt; 在 2013 年时被 Facebook 收购。前不久，在 2016 年 1 月，Facebook 因自身业务需求， 宣布将于 2017 年 1 月 28 日正式关闭 Parse 服务。&lt;/p&gt;

&lt;p&gt;那些本以为使用了大公司服务就可以高枕无忧的开发者，又要开始忙碌起来，捣鼓起怎么迁移的事情，而且可以想象，有不少开发者使用 Parse 开发的 App 已经运行几年，本来可以忘记这事了，突然被强制要求回去维护，代价可不小。&lt;/p&gt;

&lt;p&gt;如今，多如牛毛的编程语言，各式各样玲琅满目的编程框架，常常让初学者困惑。「我该学什么编程语言？」「这个技术会不会过时？」这样的问题常常困惑着初学者。&lt;/p&gt;

&lt;p&gt;我的答案是，&lt;strong&gt;所有编程技术都会成为历史&lt;/strong&gt;。没有人能够预知未来的趋势，我们只能根据自身情况做出一个相对好的选择。我也走过不少弯路，在没必要的技术上花费了很多时间。&lt;/p&gt;

&lt;p&gt;第一个让我入门的编程语言是 QBasic，在我读初二的时候。它让我明白了原来我可以通过写代码控制计算机执行一些操作和运算。为什么会选 QB？当时我还小，连计算机为何物都不清楚，由我们学校的老师硬塞过来。原因只有一个：当时的计算机竞赛是用 QB 的。&lt;/p&gt;

&lt;p&gt;当时我被屏幕上跳动的字符所吸引，可是当时学习资源非常匮乏，在我们的小县城连一本 QBasic 教程也很难找到。学校的编程小组纯粹是为了应付竞赛，而我对能否通过编程做出有意思的东西更感兴趣。后来编程竞赛变成了 Pascal，于是又学了 Pascal。&lt;/p&gt;

&lt;p&gt;在盗版光盘店里，老板的一句话让我开始学习 Visual Basic，这也是我的第一次主动选择。因为会 QB，理解起 VB 会容易很多。而且，使用 VB 可以做出各种图形界面的软件。我所有关于 VB 的学习资料都来自于一本厚厚的 Visual Basic 编程宝典。&lt;/p&gt;

&lt;p&gt;上大学后，因为选的土木工程专业，唯一的编程课程是 Fortran。当我意识到我可以比边上同学花更少时间理解和上手 Fortran，我想我是不是应该在编程方面多下点功夫，而不是继续读着不喜欢的专业混到毕业。于是我重新拾起了 VB，报考了计算机二级 VB，非常轻松的通过了。&lt;/p&gt;

&lt;p&gt;我不断意识到，我可能更适合编程。由于当时上大学，网络也普及了，可以在网络上获取一些学习资料，同时学校图书馆里也有不少关于编程的书，我开始接触到一些新的东西。当时使用 ASP 做网页的技术很火，当我加入学校的一个编程组织时，ASP.NET 开始炒起来，于是我跟风开始学 ASP.NET。&lt;/p&gt;

&lt;p&gt;而我当时最熟的是 VB，所以看 C# 很不习惯，特别不理解为什么代码里需要那么多花括号。于是我在开始的相对长的一段时间里，我是使用 VB.NET 来进行 .NET 开发的。当时的我并不理解 VB 和 C# 的区别，觉得既然微软发明了这两种语言，选择自己喜欢的就好了。后来才发现身边的朋友全在用 C#，而我成了一个异类。每次和他们沟通都要在脑海里进行编程语言的转换。终于有一天我受不了了，也学起了 C#。从此 VB 再没有用过了。&lt;/p&gt;

&lt;p&gt;找工作时好多公司都是招 C++ 程序员，而我又不太会，于是找了一份可以使用 C# 的工作。工作后，才发现自己和周围科班出身的同事的差距。于是开始补各种基础知识：计算机原理、数据结构、算法、C/C++ 语言。为了验证学习的效果，我报考并通过了 08 年软件设计师的考试。&lt;/p&gt;

&lt;p&gt;后来和同事沟通时，第一次听说了 Python 这门语言，还有 Ruby On Rails。在这两者中我选择了学习 Python，然后一发不可收拾的爱上了这门语言。&lt;/p&gt;

&lt;p&gt;而关于微软的技术，除了 .NET 3.0 刚出来的时候关注过一阵，之后出的各种：WCF，WPF，Silverlight&amp;hellip;&amp;hellip; 等技术时，我只是在一边看着，成功的闪避了，没有在上面浪费过时间。&lt;/p&gt;

&lt;p&gt;后来做游戏开发的时候，已经是专职 C++ 和 Lua 程序员了。之后在业余时间，开始捣鼓起 Go 语言。&lt;/p&gt;

&lt;p&gt;对了，关于 Java，我从未看过任何一本相关的书，都是按照写 C# 的思维来写 Java，除非老板拿枪指着，我也不会拿 Java 去写代码。 当然，写 Android 时会被迫使用 Java。&lt;/p&gt;

&lt;p&gt;目前前端很火，我却不太感冒，各种前端框架停留在能简单使用的状态。Javascript 依葫芦画瓢还是可以的。&lt;/p&gt;

&lt;p&gt;我当时花了不少时间研究和使用，到现在几乎被淘汰的技术还有 Google 的 Google App Engine。如果当时我把学 GAE 的时间拿去学 Ruby 该有多好啊。&lt;/p&gt;

&lt;p&gt;总结一下我正统的学习编程语言的历程：&lt;/p&gt;

&lt;p&gt;QB -&amp;gt; Pascal -&amp;gt; VB -&amp;gt; C# -&amp;gt; C/C++ -&amp;gt; Python -&amp;gt; Lua -&amp;gt; Go&lt;/p&gt;

&lt;p&gt;前三个我已经忘的一干二净，但是在当时的情景下，对我的帮助和影响还是巨大的。&lt;/p&gt;

&lt;p&gt;当然，我还在继续前进。下一个编程语言，我准备学习 Swift，纯粹为了好玩，因为「所有的编程技术都会成为历史」，如果一门编程语言能够给你编程语言之外的启发，也就足够了!&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>做了一个 Hugo 的主题：hugo-pacman-theme</title>
            <link>http://blog.coderzh.com/2016/03/27/hugo-pacman-theme/</link>
            <pubDate>Sun, 27 Mar 2016 12:57:37 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/27/hugo-pacman-theme/</guid>
            <description>

&lt;p&gt;Hugo 是由 Go 语言实现的静态网站生成器，通过 Hugo 可以快速生成一个静态网站，比如个人博客。在 &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt; 的静态网站生成器排名里，Hugo 排名第五，也是相当的不错。&lt;/p&gt;

&lt;p&gt;Hugo 本身有很多不错的主题，但挑剔的朋友可能会觉得还不够，希望看到 Jeklly 或 Hexo 里漂亮的主题时也能在 Hugo 里找到对应的主题。其实 Hugo 的主题制作并不复杂，有兴趣的同学可以尝试自己制作主题，或者将其他静态网站生成器里的主题转成 Hugo 的主题。&lt;/p&gt;

&lt;p&gt;不会做的话参考我做的这个主题（&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;hugo-pacman-theme&lt;/a&gt;）代码，基本的 Hugo 模板功能都用上了。&lt;/p&gt;

&lt;h3 id=&#34;pacman:54fdd68c9a36858a04277e9977a250be&#34;&gt;Pacman&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://yangjian.me/pacman/&#34;&gt;Pacman&lt;/a&gt; 是一个不错的 Hexo 主题，一直有冲动把这个主题转成 Hugo 的，再加上 Hugo 交流群里有朋友也提到了这个主题，于是利用周末的时间制作了这个主题：&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;hugo-pacman-theme&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;演示地址：&lt;a href=&#34;http://coderzh.github.io/hugo-pacman-theme/&#34;&gt;http://coderzh.github.io/hugo-pacman-theme/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;截图:54fdd68c9a36858a04277e9977a250be&#34;&gt;截图&lt;/h4&gt;

&lt;p&gt;主页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-pacman-tn.png&#34; alt=&#34;hugo-pacman-tn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;文章页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-pacman-theme.png&#34; alt=&#34;hugo-pacman-theme&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;支持功能:54fdd68c9a36858a04277e9977a250be&#34;&gt;支持功能&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;li&gt;标签（标签云）&lt;/li&gt;
&lt;li&gt;归档&lt;/li&gt;
&lt;li&gt;RSS&lt;/li&gt;
&lt;li&gt;文章大纲（Table Of Content）&lt;/li&gt;
&lt;li&gt;文章分享功能&lt;/li&gt;
&lt;li&gt;图片点击预览（FancyBox）&lt;/li&gt;
&lt;li&gt;多说评论（及 Disqus 评论）&lt;/li&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;代码高亮优化（GitHub 配色）&lt;/li&gt;
&lt;li&gt;高度配置化，你要的东西都可以通过 config.toml 进行配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用方法:54fdd68c9a36858a04277e9977a250be&#34;&gt;使用方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，确保安装了最新版 Hugo。下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo Release&lt;/a&gt;，如果使用 Mac ，直接用 Homebrew 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把 hugo-pacman-theme clone 下来，放到你的 Hugo 站点的 themes 目录里（Hugo 的使用方法详见：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/coderzh/hugo-pacman-theme
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置文件，拷贝一份或者参考：&lt;code&gt;hugo-pacman-theme/exampleSite/config.toml&lt;/code&gt;，配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;BaseURL = &amp;quot;http://coderzh.github.io/&amp;quot;
LanguageCode = &amp;quot;zh-CN&amp;quot;
HasCJKLanguage = true
Title = &amp;quot;Hugo PacMan Theme Demo&amp;quot;
Theme = &amp;quot;hugo-pacman-theme&amp;quot;
pygmentsStyle = &amp;quot;default&amp;quot;
pygmentsUseClasses = true
RSSUri = &amp;quot;feed.xml&amp;quot;

[Author]
  Name = &amp;quot;coderzh&amp;quot;

[Params]
  AuthorHomepage = &amp;quot;http://blog.coderzh.com&amp;quot;
  BottomIntroduce = &amp;quot;Introduce1 &amp;lt;br/&amp;gt; Introduce2&amp;quot;
  Description = &amp;quot;&amp;quot;
  Subtitle = &amp;quot;subtitle&amp;quot;
  Weibo = &amp;quot;coderzh&amp;quot;
  WeiboID = 1816308191
  Twitter = &amp;quot;coderzh&amp;quot;
  GitHub = &amp;quot;coderzh&amp;quot;
  Facebook = &amp;quot;coderzh&amp;quot;
  LinkIn = &amp;quot;coderzh&amp;quot;
  Imglogo = &amp;quot;img/logo.svg&amp;quot;
  AuthorImg = &amp;quot;img/author.jpg&amp;quot;
  # 日期时间格式
  DateFormat = &amp;quot;2006年01月02日&amp;quot;
  MonthFormat = &amp;quot;2006年01月&amp;quot;
  FancyBox = true

  # 使用多说评论
  #[Params.DuoShuo]
  #  ShortName = &amp;quot;coderzh&amp;quot;

  # 使用 Disqus 评论
  [Params.Disqus]
    ShortName = &amp;quot;coderzh&amp;quot;

  # Google 统计
  [Params.GoogleAnalytics]
    ID = &amp;quot;UA-10147768-2&amp;quot;

  # 多语言字符串
  [Params.Strings]
    Search = &amp;quot;搜索&amp;quot;
    PageNotFound = &amp;quot;你访问的页面不存在&amp;quot;
    ShowSideBar = &amp;quot;显示侧边栏&amp;quot;
    HideSideBar = &amp;quot;隐藏侧边栏&amp;quot;
    Categories = &amp;quot;分类&amp;quot;
    Archive = &amp;quot;归档&amp;quot;
    Tags = &amp;quot;标签&amp;quot;
    TagCloud = &amp;quot;标签云&amp;quot;
    Rss = &amp;quot;RSS 订阅&amp;quot;
    TableOfContents = &amp;quot;文章目录&amp;quot;

[Menu]
  [[Menu.Main]]
    Name = &amp;quot;首页&amp;quot;
    URL = &amp;quot;/&amp;quot;
    Weight = 1
  [[Menu.Main]]
    Name = &amp;quot;关于&amp;quot;
    URL = &amp;quot;/about&amp;quot;
    Weight = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;最后:54fdd68c9a36858a04277e9977a250be&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;该主题参考的 &lt;a href=&#34;https://github.com/A-limon/pacman&#34;&gt;Pacman&lt;/a&gt;，使用 Hugo 的模板语法纯手工一行一行打造。有需要的朋友尽管拿去使用，有问题欢迎反馈：&lt;/p&gt;

&lt;p&gt;GitHub 地址：&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;https://github.com/coderzh/hugo-pacman-theme&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo 中文文档：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo 交流 QQ 群：512499080&lt;/p&gt;

&lt;p&gt;该主题已经&lt;a href=&#34;https://github.com/spf13/hugoThemes/issues/121&#34;&gt;提交&lt;/a&gt;到官方的主题列表，相信不久就可以在官方的 &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;http://themes.gohugo.io/&lt;/a&gt; 上看到了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>懒程序员和他的 dotfiles</title>
            <link>http://blog.coderzh.com/2016/03/19/dotfiles/</link>
            <pubDate>Sat, 19 Mar 2016 15:05:47 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/19/dotfiles/</guid>
            <description>

&lt;p&gt;如果你不知道什么是 dotfiles，那你就不会知道什么是 dotfiles。如果你知道什么是 dotfiles，那你就知道什么是 dotfiles。&lt;/p&gt;

&lt;p&gt;以一段废话开场，引出今天的主题：&lt;code&gt;dotfiles&lt;/code&gt;。软件匠艺社区（&lt;a href=&#34;codingstyle.cn&#34;&gt;codingstyle.cn&lt;/a&gt;）周三晚上有一期分享介绍 Vim 时提到了 dotfiles，这篇文章我们就来好好说一说 dotfiles。&lt;/p&gt;

&lt;h3 id=&#34;什么是-dotfiles:50fc662a6f6921bb445d80a429a8e146&#34;&gt;什么是 dotfiles？&lt;/h3&gt;

&lt;p&gt;dot 即「点」的意思，意思是以点开头的文件。如果你不是程序员，你大概会说，我咋从来没见过这种文件啊？因为这些文件通常都是隐藏文件，平常一般看不到，比如 .git 目录。但这里说的 dotfiles 主要是指用户 home 目录下的点文件，这类文件一般是一些配置文件，比如 vim 的配置文件 .vimrc，zsh 的配置文件 .zshrc 等。通过设置这些配置文件，可以实现出很强大的功能，比如有不少人通过配置 .vimrc，把 vim 活生生变成了一个功能强大的 IDE。还有一些偷懒的程序员在 .profile 之类的文件里设置了大量命令的 alias。以至于你还没看清楚他敲的第一个命令，他已经敲了三四个命令了。&lt;/p&gt;

&lt;p&gt;通过配置各种 dotfiles，程序员可以把系统定制得既顺手又高效。但是问题来了，自己千辛万苦调的设置，如果换一台机器，又得重新设置一遍。这对于追求效率的程序员来说是不可接受的。&lt;/p&gt;

&lt;h3 id=&#34;dotfiles-管理:50fc662a6f6921bb445d80a429a8e146&#34;&gt;dotfiles 管理&lt;/h3&gt;

&lt;p&gt;于是会玩又懒的程序员想出了一个办法，把所有的 dotfiles 放在一个单独的目录进行统一管理，放到 GitHub 或者通过网盘同步。&lt;/p&gt;

&lt;p&gt;为了让 dotfiles 生效，主要有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过一个脚本，把所有 dotfile 文件 rsync 到 HOME 目录。&lt;/li&gt;
&lt;li&gt;使用软链，让 HOME 目录的 dotfile 文件指向你目录的 dotfile 文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式适合机器初装，但是假如你有两台机器，希望配置能方便的进行同步，第二种方式是更好的选择。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s ~/dotfiles/.vimrc ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，假如你的 dotfile 文件很多，手工去维护那些软链也是一件麻烦的事情。而程序员又是最不能忍受麻烦的，于是造了各种轮子去维护和管理这些 dotfiles 。&lt;/p&gt;

&lt;p&gt;有些人把软链的管理写成一个 Shell 脚本，也有人做成特定的工具。比如：&lt;a href=&#34;https://github.com/thoughtbot/rcm&#34;&gt;rcm&lt;/a&gt;、 &lt;a href=&#34;http://skwp.github.io/dotfiles/&#34;&gt;YARD&lt;/a&gt;、 &lt;a href=&#34;https://pypi.python.org/pypi/dotfiles&#34;&gt;dotfiles&lt;/a&gt;、 &lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;mackup&lt;/a&gt; ……&lt;/p&gt;

&lt;h3 id=&#34;mackup:50fc662a6f6921bb445d80a429a8e146&#34;&gt;mackup&lt;/h3&gt;

&lt;p&gt;在对比了各种 dotfiles 工具后，我最终选择了 &lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;mackup&lt;/a&gt;。理由主要如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用方便，配置起来非常简单。&lt;/li&gt;
&lt;li&gt;社区贡献了大量现成的软件的 dotfiles 配置，可以直接使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 OS X 下，可以直接使用 brew 安装 mackup。其他系统下，可以直接使用 pip 安装。安装好后，备份和还原都只需要一个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 备份
$ mackup backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新机器上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 还原
$ mackup restore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想要那些软链了，只需要执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mackup uninstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mackup 可以通过配置文件，指定你希望备份哪些 dotfiles，以及备份到哪里（支持备份到 Dropbox、Google Drive、Copy、iCloud、Box 以及指定的目录。&lt;/p&gt;

&lt;p&gt;比如在我的 mac 上，我的 &lt;a href=&#34;https://github.com/coderzh/dotfiles/blob/master/home/.mackup.cfg&#34;&gt;.mackup.cfg&lt;/a&gt; 这样设置的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[storage]
engine = file_system
path = dotfiles
directory = home 

[applications_to_sync]
atom
pycharmce
myvim
ideaic15
zsh
mackup
dash
karabiner
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;storage&lt;/code&gt; 里指定了备份到文件系统的 ~/dotfiles/home 路径。&lt;code&gt;applications_to_sync&lt;/code&gt; 指定了备份哪些应用的 dotfiles。mackup 预先定义好了大量 application 的 dotfiles，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Atom
Bash
Dash
Emacs
Flux
Git
Gradle
MacOSX
MacVim
npm
Oh My Zsh
Vim
WebStorm
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要定制某个 application 的 dotfiles 也很简单，比如我发现 mackup 自带的配置里没有 IntelliJ Community 版本的配置，我只需要在新建一个文件： ~/.mackup/ideaic15.cfg ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[application]
name = My IntelliJ IDEA 15

[configuration_files]
Library/Preferences/IdeaIC15/keymaps/Mac OS X copy.xml
Library/Preferences/IdeaIC15/options/keymap.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;configuration_files&lt;/code&gt; 里指定我需要备份的文件即可。非常的简单易用。&lt;/p&gt;

&lt;h3 id=&#34;自动安装软件:50fc662a6f6921bb445d80a429a8e146&#34;&gt;自动安装软件&lt;/h3&gt;

&lt;p&gt;在一台新机器上，把之前机器装的软件一个一个手动安装也是非常耗时和麻烦的事情。如果你使用的是 Mac OS X，将会变得非常简单，因为绝大部分的软件开发包及软件都可以通过 &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; 和 &lt;a href=&#34;https://caskroom.github.io/&#34;&gt;brew cask&lt;/a&gt; 来安装。&lt;/p&gt;

&lt;p&gt;我的 Mac 上 99.9% 的软件，可以通过我写的 &lt;a href=&#34;https://github.com/coderzh/dotfiles/blob/master/install/brew.sh&#34;&gt;brew.sh&lt;/a&gt; 脚本来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Install Homebrew

# Ask for the administrator password upfront.
sudo -v

# Keep-alive: update existing `sudo` time stamp until the script has finished.
while true; do sudo -n true; sleep 60; kill -0 &amp;quot;$$&amp;quot; || exit; done 2&amp;gt;/dev/null &amp;amp;

# Check for Homebrew,
# Install if we don&#39;t have it
if test ! $(which brew); then
  echo &amp;quot;Installing homebrew...&amp;quot;
  ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
fi

brew tap homebrew/versions
brew update
brew upgrade --all

# Install packages
apps=(
    caskroom/cask/brew-cask
    cmake
    coreutils
    findutils
    git
    gnu-sed --with-default-names
    go
    hugo
    mercurial
    mackup
    macvim
    mysql
    android-platform-tools
    python
    ruby
    svn
    vim
    wget
    zsh
)

caskapps=(
    android-studio
    alfred
    atom
    cheatsheet
    dash
    genymotion
    google-chrome
    intellij-idea-ce
    iterm2
    java
    karabiner
    keepassx
    kindle
    macdown
    pomotodo
    pycharm-ce
    qq
    qqmusic
    qqmacmgr
    sogouinput
    thunder
    vagrant
    virtualbox
    vlc
    wiznote
    youdao
)

brew install &amp;quot;${apps[@]}&amp;quot;
brew tap caskroom/versions
brew cask update
brew cask install --appdir=&amp;quot;/Applications&amp;quot; &amp;quot;${caskapps[@]}&amp;quot;
brew cleanup
brew cask cleanup
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pip-npm-gem:50fc662a6f6921bb445d80a429a8e146&#34;&gt;pip、npm、gem&lt;/h3&gt;

&lt;p&gt;使用 pip、npm、gem 安装的包也使用脚本进行一键安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade pip
pip install powerline-status
pip install MySQL-python
pip install tornado
pip install torndb
pip install pycrypto
pip install mock
# npm、gem ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-x-的系统设置:50fc662a6f6921bb445d80a429a8e146&#34;&gt;OS X 的系统设置&lt;/h3&gt;

&lt;p&gt;当你拿到一台新的 Mac 然后开机时，不知道有没有被 Duang~ 的一声吓到的经历。当时吓得的宝宝我赶紧找了如何关闭开机声音的方法（设置静音、插上耳机都不管用！），只要执行一条命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nvram SystemAudioVolume=&amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多的系统设置都可以通过命令来完成，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 电池显示是百分百
defaults write com.apple.menuextra.battery -bool true

# 设置键盘按键重复的延迟
defaults write NSGlobalDomain KeyRepeat -int 3

# 禁止自动拼写纠正
defaults write NSGlobalDomain NSAutomaticSpellingCorrectionEnabled -bool false

# Finder 显示状态栏
defaults write com.apple.finder ShowStatusBar -bool true

# Finder 显示地址栏
defaults write com.apple.finder ShowPathbar -bool true

# 禁止在网络驱动器上生成 .DS_Store 文件 
defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字体:50fc662a6f6921bb445d80a429a8e146&#34;&gt;字体&lt;/h3&gt;

&lt;p&gt;程序员喜欢折腾的几样东西：键盘、编辑器、字体。程序员钟爱的几种字体，包括 Source Code Pro、Hack、Menlo 等等，其中对 powerline 字体更是最爱。把所有心爱的字体放在 dotfiles/fonts 目录里，通过自动安装脚本里直接拷贝到 ~/Library/Fonts/ 目录下即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r ~/dotfiles/fonts/* ~/Library/Fonts/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 powerline 字体需要安装 powerline-status，这个在前面讲的 pip 脚本里已经安装了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install powerline-status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;zsh 中使用 powerline 字体，只需要在 .zshrc 中加一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /usr/local/lib/python2.7/site-packages/powerline/bindings/zsh/powerline.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/zsh-powerline.png&#34; alt=&#34;zsh-powerline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 vim 里使用 powerline 字体，只需要在 .vimrc 里加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set rtp+=/usr/local/lib/python2.7/site-packages/powerline/bindings/vim
set laststatus=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/vim-powerline.png&#34; alt=&#34;vim-powerline&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;总结:50fc662a6f6921bb445d80a429a8e146&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;懒程序员如果拿到了一个新的 Mac 机器，他只需要做如下几步，就可以把这台新的机器变成熟悉的一台机器：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 XCode（最好在 Mac Store 里下载安装完整版的 XCode，因为有些软件安装依赖完整版 XCode）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo softwareupdate -i -a
$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动安装软件及系统设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ git clone https://github.com/coderzh/dotfiles.git
$ source dotfiles/install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 mackup 恢复 dotfiles。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp ~/dotfiles/.mackup.cfg ~/
$ cp -r ~/dotfiles/.mackup ~/
$ mackup restore
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果一切顺利，程序员，你没有浪费上班时间装电脑，你可以开始搬砖了。:-)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（对了，iTerm2 的 Color 设置好像必须手工操作，配色列表可以在 &lt;a href=&#34;https://github.com/mbadolato/iTerm2-Color-Schemes&#34;&gt;https://github.com/mbadolato/iTerm2-Color-Schemes&lt;/a&gt; 找，作为 JetBrains 粉，最后我选择了 JetBrains Darcula.itermcolors 这一款。）&lt;/p&gt;

&lt;p&gt;在 GitHub 里搜 &lt;code&gt;dotfiles&lt;/code&gt; 可以看到大量的 dotfiles，当然，别忘了 Star 我的 dotfiles：&lt;a href=&#34;https://github.com/coderzh/dotfiles&#34;&gt;https://github.com/coderzh/dotfiles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后，温馨提示下，千万不要把 ssh、mysql 密码相关的内容提交上去呦~&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mathiasbynens/dotfiles&#34;&gt;https://github.com/mathiasbynens/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/skwp/dotfiles&#34;&gt;https://github.com/skwp/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/donnemartin/dev-setup&#34;&gt;https://github.com/donnemartin/dev-setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpro/awesome-dotfiles&#34;&gt;https://github.com/webpro/awesome-dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jbernard/dotfiles&#34;&gt;https://github.com/jbernard/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;https://github.com/lra/mackup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpro/dotfiles&#34;&gt;https://github.com/webpro/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>使用番茄工作法一个月感受</title>
            <link>http://blog.coderzh.com/2016/03/06/pomotodo/</link>
            <pubDate>Sun, 06 Mar 2016 21:40:47 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/06/pomotodo/</guid>
            <description>&lt;p&gt;之前就听说过「番茄工作法」，但是一直没有尝试。春节期间，新买的 MacBook Pro 到了之后，开始装各种效率软件时，发现有人推荐 pomotodo 这个番茄工作法的软件。于是试着了解了下所谓的「番茄工作法」，并且开始尝试，结果一发不可收拾。&lt;/p&gt;

&lt;p&gt;在使用了「番茄工作法」几天后，我就打算写一篇关于它的文章。但是我担心我对它也就几天的热度，于是我打算看看我能坚持多久。除了在家里使用「番茄工作法」，在公司我也使用，到今天为止，差不多坚持了一个月。&lt;/p&gt;

&lt;p&gt;而在刚开始听到那些所谓的「xxx 工作法」，我是不信的。即使大家都说它好，我也会产生一种本能的抗拒心态，大家越说它好，我越抗拒，甚至选择忽略它，不去尝试它。因为在我原来的价值观里，人们想要成功，靠那些所谓的「xxx 工作法」是不靠谱的。&lt;/p&gt;

&lt;p&gt;就像《后会无期》里说的：「&lt;strong&gt;听过很多道理，依然过不好这一生&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;我开始思考，如果「番茄工作法」真有那么好，为什么没有听说过哪些成功人士、科学家、伟大的程序员使用了「番茄工作法」？&lt;/p&gt;

&lt;p&gt;而且，「番茄工作法」特别容易让我联想到 GTD （Get Things Done）工具。在我刚工作不久的时候，金山请了一位讲师介绍了 GTD 。那是我第一次听说 GTD ，当时引发了我很大的兴趣。现在还可以在我的博客里找到当时写下的一篇文章《&lt;a href=&#34;http://blog.coderzh.com/2010/01/03/1638096/&#34;&gt;时间管理GTD工具&lt;/a&gt;》（2010 年 1 月）。我尝试过十几二十种不同的 GTD 工具，但是坚持用下来的却没有一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个东西适不适合自己，只有亲身尝试后才知道。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我知道有些人一直都在使用 GTD 工具，但是我经过各种尝试之后，发现 GTD 并不适合我。当我刚遇见「番茄工作法」时，我甚至不想开始尝试了。辛亏了 MacBook ，让我有机会做了一些尝试，也让我明白了一些道理：&lt;/p&gt;

&lt;p&gt;那些成功人士、科学家、伟大的程序员也许的确从不使用番茄工作法，因为他们根本就不需要。他们对所从事的事业有着本能的无限热情，他们不需要借助外部的工具就能做到注意力集中，对事物保持长久的热情，本能的已经对时间有了很好的利用。&lt;/p&gt;

&lt;p&gt;而作为普通大众的我，平时有太多的诱惑让我分心，微信、QQ、微博等等。我的注意力开始变得没那么集中，总是在干正事的时候做着做着就开始折腾起和正事毫无关系的事。&lt;/p&gt;

&lt;p&gt;在凯文凯利的《必然》里提到，人类的注意力是稀缺的资源。新的事物和产品会大量涌现，但是每个人一天的时间只有 24 小时，而一天里能吸引注意力的时间又是更少。&lt;/p&gt;

&lt;p&gt;我开始承认随着社交网络的兴起，我的注意力开始变得涣散。所以，番茄工作法也许适合我。它让我注意力保持集中，让我更好的利用时间，也让我更有成就感。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，从现在开始，尝试一下「番茄工作法」吧！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说了那么多，还没介绍今天的主角。到底什么是番茄工作法？&lt;/p&gt;

&lt;p&gt;番茄是指番茄钟，一种在厨房用来计时的闹钟。当你决定做一件事时，扭动番茄钟定时 25 分钟，在滴滴答答的时钟声音下，你专注于完成这 25 分钟内要完成的事。期间一旦你被打扰，或者开始做无关的事情，你必须重新开始计时。25 分钟后，再次扭动番茄钟定时 5 分钟用来休息，这时完全不去想刚才的事情，而是好好的放松一下。&lt;/p&gt;

&lt;p&gt;规则非常的简单，为此我还专门买了一个真实的番茄钟，也许是因为几块钱的便宜货，这东西时间到的时候的闹铃声太大以至于我会被它吓到。所以，我现在一直使用软件来进行计时。&lt;/p&gt;

&lt;p&gt;开始一个最好的尝试，就是使用「番茄工作法」阅读《番茄工作法图解》。&lt;/p&gt;

&lt;p&gt;看过了这本书，你会对番茄工作法有更深的了解。你会明白为什么那些软件默认都要模拟番茄钟滴滴答答的声音。我刚开始也是非常的不习惯滴滴答答的声音，觉得是一种噪音反而让我分心，所以我都把声音关了。后来看了书，我才明白，扭动番茄钟的动作，听到滴滴答答的倒计时时间，其实是一种很好的仪式感。表示我现在正在一个番茄钟的时间内，让自己保持注意力。我现在已经离不开滴滴答答的声音了。&lt;/p&gt;

&lt;p&gt;使用番茄工作法除了让你注意力更集中之外，还有诸多好处，比如：&lt;/p&gt;

&lt;p&gt;一件你一直都想做，但是每次想想都觉得很麻烦，从而一直都未动手去做的事。使用番茄工作法，抛开那些长远的麻烦烦恼，只关注现在这 25 分钟内要做的事。再麻烦的事总得开始，一旦开始，很多麻烦烦恼自然被解决了。（解决拖延症）&lt;/p&gt;

&lt;p&gt;又比如：&lt;/p&gt;

&lt;p&gt;你精神亢奋持续保持高度集中注意力的工作，从而忘记了休息，你开始腰酸腿疼，颈椎病开始来找你。使用番茄工作法，每 25 分钟，都提醒你必须站起来活动活动，倒一杯水，和同事闲聊几句。&lt;/p&gt;

&lt;p&gt;再比如：&lt;/p&gt;

&lt;p&gt;项目 deadline 就要到了，但是还有一大堆事情没做，你开始变得紧张起来，你开始焦虑，手忙脚乱，一想到大 Boss 苛刻的眼神，你敲键盘的手已经开始颤抖。使用番茄工作法，在剩下的每个 25 分钟内，我只关注当前的任务，既保持高效完成了任务，又缓解了紧张的情绪。&lt;/p&gt;

&lt;p&gt;在 5 分钟的间隔时间，由于处于完全放松的状态，这时更容易有大局观，而不是扎进到具体的事情后出不来。一旦发现前面做的事情方向错了，立马可以开始调整。&lt;/p&gt;

&lt;p&gt;同时，使用「番茄工作法」，你可以很好的对做的事情进行回顾总结。比如，以下是我近一个月来使用「番茄工作法」的统计情况（统计不一定完全准确，有漏记的情况）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/pomotodo.png&#34; alt=&#34;pomotodo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用番茄工作法，我利用周末的时间，看了几本书，更新了 Hugo 中文文档，学习了 Ruby On Rail，写了一个 Android APP。当然，还包括写公众号文章。&lt;/p&gt;

&lt;p&gt;就在现在，我还处于番茄钟的时间内。写这篇文章，我差不多花了 4 个番茄钟的时间。它也在提醒我，未来我在做同样事情时，我能不能更高效，用更少的番茄钟来完成。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>《必然》读书笔记之 - 知化Cognifying</title>
            <link>http://blog.coderzh.com/2016/02/21/inevitable-cognifying/</link>
            <pubDate>Sun, 21 Feb 2016 19:05:10 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/21/inevitable-cognifying/</guid>
            <description>&lt;p&gt;2002 年左右，KK 参加了谷歌的一个小型聚会，当时谷歌还是一个家专注搜索的小公司。KK 问拉里·佩奇「已经有这么多家搜索公司，干嘛还要做免费网络搜索？」&lt;/p&gt;

&lt;p&gt;佩奇回答说：「哦，我们其实是在做人工智能。」&lt;/p&gt;

&lt;p&gt;「知化」这个词不太好理解，其实主要说的是人工智能，即让机器或物体拥有智能的过程，技术上涉及到神经网络、机器学习、大数据等领域。如果你正在从事相关领域的研究，是很有前途的方向。&lt;/p&gt;

&lt;p&gt;去年公司有次请了个机器学习的专家来讲课，从头到尾我居然没有听懂他在讲什么。。当然，原因主要是在我的。毕竟机器学习这块属于专业的领域，需要有很多专业知识做背书，我之前对这块也了解甚少。&lt;/p&gt;

&lt;p&gt;但我相信机器学习的大致概念其实是很好解释清楚的，即通过设计一些算法，让计算机能够进行自我学习和改进。有人会想，计算机有这么牛逼吗？还会自己学习？其实这正是一个比较容易误解的地方。并非程序员把代码写好，计算机自个儿在哪里跑就把什么都学会了。机器学习其实是需要人为训练的过程，通过人类不断的告诉机器哪些是对的哪些是错的，准备大量训练的数据，机器通过训练来自动修正已有的算法以达到最佳的效果。&lt;/p&gt;

&lt;p&gt;举个栗子，文章开头提到的，谷歌创始人说谷歌其实是在做人工智能。首先，谷歌的搜索引擎有一套基于 Page Rank 的算法，能够根据关键词自动搜索出相关的网页。算法虽然很先进，但毕竟有时会出错，比如最佳的搜索结果并没有排在第一位。但用户是会自己判断哪个搜索结果对自己有用，用户会用脚投票，谷歌通过分析哪个搜索结果的点击率最高，来自动修正搜索引擎的算法，从而找出最合适的结果排在第一位。&lt;/p&gt;

&lt;p&gt;人工智能目前主要应用在比如垃圾邮件检测、数字识别、语音识别、人脸识别、各种智能设备，自动驾驶等领域，人工智能是未来科技发展的「必然」。对于未来的人工智能，除了给人类带来便利之外，人类也表现出了很多担心。在「知乎」里有个著名的讨论「&lt;a href=&#34;https://www.zhihu.com/question/27864852/answer/39007053&#34;&gt;为什么有很多名人让人们警惕人工智能？&lt;/a&gt;」，答案排名第一个的谢熊猫君开头就给出了一个让人震惊的结论：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人工智能很可能导致人类的永生或者灭绝，而这一切很可能在我们的有生之年发生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;的确是有点危言耸听，而《必然》的作者 KK 显然是人工智能的乐观派，他相信人工智能并不能完全取代人类，而是对人类不擅长的能力的一种补充。计算机的有些能力是人类所不具备的，比如超强记忆容量，超强的计算能力，所以我们发明了硬盘和 CPU 。我们的思维方式不擅长做统计，于是我们制造出各种统计技术很强的智能设备。人类开车比如容易走神分心，于是我们研究制造自动驾驶。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「创造聪明绝顶的人工智能是个错误，因而探究更多智能种类显得更为明智」&lt;/strong&gt; 从这句话看来，KK 这个乐观派也未必是那么的乐观。也许他是对的，开发一个聪明绝顶的全面人工智能的机器人，对于人类来说本身就是个错误，何况技术实现也非常困难。所以，只要人工智能在某一种特定的心智表现出色就好。比如自动驾驶的人工智能只会做好驾驶一件事，预测天气的人工智能只会用来预测天气。&lt;/p&gt;

&lt;p&gt;假设人工智能在各个方面都逐渐取代了人类，那必然会导致大量的职业消失。就像自动化实现后，机器代替了农民以及在农场作业的动物，淘汰了当时大多数人的工作。作为程序员，想到的是以后人工智能可以根据用户的语音需求自动编写代码，大量的程序员将失业。&lt;/p&gt;

&lt;p&gt;机器将取代更多人类工种，一切都是时间问题。KK 甚至放出了这样的话：&lt;/p&gt;

&lt;p&gt;「或许很难令人相信，但在本世纪结束前，如今人们从事的职业中有 70% 很可能会被自动化设备取代。不用说，亲爱的读者，你的工作也会被机器取代。广泛的自动化将会触及包括体力劳动和知识型工作在内的所有工种。」&lt;/p&gt;

&lt;p&gt;「无论你是一名医生、律师、建筑师、记者甚至程序员，机器人都将历史性地接管你的工作。」&lt;/p&gt;

&lt;p&gt;所以，不要再以为你的职业一定可以干一辈子，也不要以为在大公司上班就一定可以工作到退休，也许某天你所从事的这个职业本身就消失了。你的搬砖技术练的再好，已经没有任何公司需要人搬砖了。&lt;/p&gt;

&lt;p&gt;那么，人类做什么？会有更多新的职业产生出来。未来自动驾驶的汽车随处可见，而相应的会衍生出一个新的名为行程优化师的新工作。当外科自动化机器人成为常规后，会出现一种新的专业分析师，为你解读数据。（未来代码都由机器来自动编写，测试，部署上线，服务器坏了有机器人自动维修。我想不出会出现什么新的职业，也许程序员会变成一个更高端的职业，主要设计和优化机器人使用的编程语言，开发用来生成代码的代码。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「几乎人人都能得到个人机器人，但是仅仅拥有一个机器人并不是成功的关键。成功将青睐那些以最优化的方式与机器人以及机器一同工作的人。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;「人类的工作就是不停地给机器人安排任务，这本身就是一项永远做不完的工作，所以，我们至少还能保留这份『工作』。」&lt;/p&gt;

&lt;p&gt;「将来，无论你现在从事什么工作，收入水平如何，都讲反复经历机器人代替人的以下 7 个步骤：」&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;机器人干不了我的工作。&lt;/li&gt;
&lt;li&gt;好吧，它会许多事情，但是我做的事情它不一定都会。&lt;/li&gt;
&lt;li&gt;好吧，我做的事情它都会，但是它常常出故障，这时需要我来处理。&lt;/li&gt;
&lt;li&gt;好吧，它干常规工作时从不出错，但是我需要训练它学习新任务。&lt;/li&gt;
&lt;li&gt;好吧，就让它做我原来的工作吧，那工作本来就不是人该干的。&lt;/li&gt;
&lt;li&gt;哇，机器人正在干我以前做的工作，我的新工作不仅好玩多了，工资还高。&lt;/li&gt;
&lt;li&gt;真高兴，机器人绝对干不了我现在做的事情。&lt;/li&gt;
&lt;li&gt;【重复】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;「未来，你的薪水高低将取决于你能否和机器人默契配合。90% 的同事将会是看不见的机器，而没有他们，你的大部分工作将无法完成。这一切都是必然的。让机器人代替我们从事现在的工作，让我们在它们的帮助下去构想有意义的新工作吧。」&lt;/p&gt;

&lt;p&gt;在未来，使用编程语言手敲代码可能会被视为一种复古行为。趁着现在这个到处就差一个程序员的时代，多敲几行代码，说不定就改变世界了呢？&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我的第一台 Mac</title>
            <link>http://blog.coderzh.com/2016/02/09/my-first-mac/</link>
            <pubDate>Tue, 09 Feb 2016 10:42:05 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/09/my-first-mac/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mac.JPG-w&#34; alt=&#34;mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;新年第一篇，祝大家猴年大吉，心想事成，万事如意！&lt;/p&gt;

&lt;p&gt;这两天在家里除了带孩子就是在摆弄新到的 MacBook Pro 了。嗯，前几天咬一咬牙，双手颤抖的点击了下单按钮，第三天就收到了。&lt;/p&gt;

&lt;p&gt;当初在买 MBP 还是 iMac 之间纠结过，因为已经有一个台式机，所以确定了买 MBP。然后就是纠结买 13 吋还是 15 吋。之前我去广州新开的苹果体验店看过，15 吋的略大了点，13 吋的大小刚刚好，本来打算就买 13 吋的。直到下单前，又改变主意了，考虑便携性和性能，我更倾向于性能，于是最后一刻改成了 15 吋标准配置（16 G内存 512闪存）。购买时，我使用了教育商店购买，便宜了 1500 软妹币。我准备了堂弟的学生证，然而第二天苹果直接就给我发货了，并没有要求我出示学生证。后来听说是抽查的。&lt;/p&gt;

&lt;p&gt;平常我大都是在 Windows 的平台下开发的，有时用一用 Linux。感觉 Windows 平台下的开发工具链其实挺完善的，写 C/C++ ，C# 有号称宇宙无敌 IDE 的 Visual Studio ，写 Python 有 PyCharm，写 Java 有 IntelliJ ，写 Android 有 Android Studio ，编辑器有 gVim 。对应的效率工具也一应俱全：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Total Commander 装机必备的神器，谁用谁知道。&lt;/li&gt;
&lt;li&gt;Launchy 效率神器，快速启动程序。作者长时间未更新，最近换成了另外一个神器：Wox 。没用过的赶紧试试，有惊喜。&lt;/li&gt;
&lt;li&gt;Clipx / Ditto 多重剪贴板。&lt;/li&gt;
&lt;li&gt;cmder 终端模拟器，好用到爆，从此告别系统自带的命令行窗口。&lt;/li&gt;
&lt;li&gt;Visual Studio 的 Visual Assist 插件，一个字就是爽。&lt;/li&gt;
&lt;li&gt;Visual Studio 的 ViEmu 插件，没有 Vim 模式的 IDE 已经没法用了。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;《必然》一书的『过滤』一章中提到，如果你只接触那些你已经喜欢的东西是有风险的，即你可能会卷入一个以自我为中心的漩涡，从而对任何与你的标准存在细微差异的事情都视而不见，即使你原本会喜欢它。这种现象被称为『过滤器泡沫』。&lt;/p&gt;

&lt;p&gt;所以，我们要勇于尝试新事物。当时觉得 Ubuntu 好玩，在上面使劲折腾过，折腾了一段时间后，感觉还是不太适合作为个人的桌面系统。一直想尝试 Mac OS X，昂贵的价格又有点让人望而却步。从体验 Mac 的这几天来看，感觉付出是非常值的，从设计美感到使用体验都非常好，为什么我没有早一点入手呢？&lt;/p&gt;

&lt;p&gt;这两天都在研究 Mac 系统怎么玩，看了很多文章，装了一些软件，学习了很多东西。学习曲线大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;学习了神奇的触摸板的使用方法。（双指，三指，四指的手法。。。）&lt;/li&gt;
&lt;li&gt;学习了系统常用的快捷键。&lt;/li&gt;
&lt;li&gt;学习了在 Mac 上如何安装软件。（Mac App Store、官网下载 dmg、使用 Homebrew）&lt;/li&gt;
&lt;li&gt;给命令行终端配上漂亮的 Solarized 皮肤，安装配置 Shell 神器：oh-my-zsh&lt;/li&gt;
&lt;li&gt;安装包管理神器 Homebrew 和 brew cask。&lt;/li&gt;
&lt;li&gt;安装效率神器：Alfred2。&lt;/li&gt;
&lt;li&gt;使用 Homebrew 把系统自带的软件包升级到最新版本，比如：git、python、vim 等等。&lt;/li&gt;
&lt;li&gt;安装和配置 Mac 下的 macvim。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;嗯，完成了以上步骤后，基本上可以开始干活了。对了，再接上 HHKB，调整开关设置，打开开关 2、3、4，启用 Mac 模式，简直完美！&lt;/p&gt;

&lt;p&gt;接着，我还安装了如下的软件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chrome 浏览器。&lt;/li&gt;
&lt;li&gt;Dash 查看各种文档的神器。&lt;/li&gt;
&lt;li&gt;Mou 编辑 MarkDown 的神器。&lt;/li&gt;
&lt;li&gt;XCode 现在还用不着，先装上。&lt;/li&gt;
&lt;li&gt;Android Studio&lt;/li&gt;
&lt;li&gt;ShiftIt 用来调整窗口位置和大小的神器。&lt;/li&gt;
&lt;li&gt;WizNote 为知笔记&lt;/li&gt;
&lt;li&gt;QQ&lt;/li&gt;
&lt;li&gt;微信&lt;/li&gt;
&lt;li&gt;QQ 音乐&lt;/li&gt;
&lt;li&gt;有道词典&lt;/li&gt;
&lt;li&gt;迅雷&lt;/li&gt;
&lt;li&gt;VLC 视频播放器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alfred2 和 oh-my-zsh 是我用了的最令人惊叹好用的工具，谁还有好用的软件推荐给我啊~~~&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>博客皮肤单独建了个仓库</title>
            <link>http://blog.coderzh.com/2016/02/05/new-hugo-rapid-theme-repo/</link>
            <pubDate>Fri, 05 Feb 2016 23:55:45 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/05/new-hugo-rapid-theme-repo/</guid>
            <description>

&lt;p&gt;有同学提到希望将这个博客的皮肤单独建个仓库，方便使用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/issues/1&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog/issues/1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;的确，早就应该这么做了。趁着放春节假期了，把这个撸了一遍，单独的皮肤仓库叫：&lt;code&gt;hugo-rapid-theme&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;只是将它从原博客中抽离出来，还有很大优化的空间，需要的同学先用着吧。&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&#34;https://github.com/coderzh/hugo-rapid-theme&#34;&gt;https://github.com/coderzh/hugo-rapid-theme&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;说明文档:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;说明文档&lt;/h2&gt;

&lt;p&gt;以下是 hugo-rapid-theme 的 README 文档：&lt;/p&gt;

&lt;p&gt;Demo: &lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step1-install-hugo:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step1 Install Hugo&lt;/h3&gt;

&lt;p&gt;Set &lt;a href=&#34;http://www.gohugo.org/doc/overview/installing/&#34;&gt;Hugo Install&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step2-create-your-site:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step2 Create your site&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;hugo new site your-blog-name
cd your-blog-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step3-clone-the-theme-repo:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step3 Clone the theme repo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/coderzh/hugo-rapid-theme.git themes/hugo-rapid-theme

# replace config file
rm config.toml
cp themes/hugo-rapid-theme/config.yaml .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step4-start-your-site:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step4 Start your site&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# new content
hugo new about.md
# start server
hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step5-have-fun:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step5 Have Fun&lt;/h3&gt;

&lt;p&gt;Now you can open &lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modify the config.yaml and other things, and have fun!&lt;/p&gt;

&lt;p&gt;You can also make this repo as submodule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git submodule add https://github.com/coderzh/hugo-rapid-theme.git themes/hugo-rapid-theme
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>追求简单和纯粹，我去掉了博客的评论功能</title>
            <link>http://blog.coderzh.com/2016/02/01/close-comments/</link>
            <pubDate>Mon, 01 Feb 2016 23:35:19 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/01/close-comments/</guid>
            <description>&lt;p&gt;一直以来，我们都习惯了有评论功能的博客系统，甚至大多数的博客系统还拿评论数来计算分数，作为你的文章热度的一个指标。&lt;/p&gt;

&lt;p&gt;曾经我也一度以为评论功能很重要，有时还会去期待有人评论。然而从结果来看，几乎大部分的评论都毫无价值。最近还受到了垃圾评论的骚扰，既浪费了我的时间不停的去删除，也影响了阅读者的体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;真心想和你交流的人，会想尽一切方法找到你。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，不必担心收不到有用的用户反馈。而且，那么大一个微信二维码放在那里，只要扫一扫关注一下，就可以给我发消息，当然，找到我的邮箱地址也是很容易的事情。&lt;/p&gt;

&lt;p&gt;为了追求最佳的阅读体验，追求一个博客的简单和纯粹，我去掉了博客的评论系统。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>张小龙悟透《失控》做出了微信，我们看过了《必然》能做什么？</title>
            <link>http://blog.coderzh.com/2016/01/31/inevitable/</link>
            <pubDate>Sun, 31 Jan 2016 12:22:25 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/31/inevitable/</guid>
            <description>&lt;p&gt;凯文凯利在 20 多年前在《失控》一书中预言了人类的未来的科技、社会和经济，现今的万维网、博客、维基百科、无人驾驶、电子货币、去中心化等等，都在上个世纪 90 年代被 KK 成功预言，而他在写《失控》一书时，还没有万维网，因特网才刚刚进入实用阶段。&lt;/p&gt;

&lt;p&gt;微信之父张小龙很早前就读过了《失控》，在他最近被爆出来的饭否日记中，他这么写到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;再问有多少人看了失控，无人。我顿时将自己想象为KK而口若悬河了。&lt;/p&gt;

&lt;p&gt;2011-01-13 17:42 by gzallen&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;张小龙非常推崇《失控》中提到的 &lt;strong&gt;去中心化&lt;/strong&gt; 的思想，这点在微信公众号和朋友圈都有体现。比如并没有一个中心化的公众号列表入口，展示最新最热的公众号文章。每个公众号主只与关注者互相连接，用户与用户之间互相连接，好的内容可以在用户之间以几何倍数的传播。又比如前几天的朋友圈红包照片功能，瞬间引爆了朋友圈。&lt;/p&gt;

&lt;p&gt;《失控》这本书很厚，而且里面的内容需要花大量的时间去理解和琢磨。本文的标题纯粹是为了吸引眼球，因为并不能得出这样的结论：悟透了《失控》就一定能做出像微信这样牛逼的产品。更加现实的是，即使看过了《必然》，我们大多数人什么也做不出来。&lt;/p&gt;

&lt;p&gt;但是看这两本书，有助于你了解人类未来的科技趋势。正如罗振宇所说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个时代最悲哀的事情，就是——&lt;/p&gt;

&lt;p&gt;你努力，但你不在风口上，&lt;/p&gt;

&lt;p&gt;你聪明，但你不在潮流中。&lt;/p&gt;

&lt;p&gt;知道趋势，意味着已经胜利在望。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《失控》中预言的很多科技虽然现在已经发生，而在某些领域，比如人工生命、机器人技术、生态学、仿真学等领域，并没有出现新的重大思想。正如他在《必然》中的 &lt;strong&gt;形成(Becomming)&lt;/strong&gt; 中提到的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;未来的大部分运转人类生活的伟大产品，在 2016 年以前，都还没被发明出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们目睹了从 PC 时代到互联网时代，再到现在的移动互联网时代的转变过程。我们正处于形成的过程中，所以我们感觉不到变化。你今天后悔当初为什么没有和张小龙想到一块去。再过几年十几年，你同样也会感叹，我要是在当时就意识到有那么多可能性该多好啊！&lt;/p&gt;

&lt;p&gt;设想未来你的孙子问你，「爷爷，为什么你年轻的时候马桶还不会说话，裤子还需要手来脱，打字还需要键盘，甚至显示屏幕还要放一个笨重的显示器，你居然还在桌子上放两个？！你当时没想到需要做点什么吗？」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，不要再感叹强大的 BAT 已经垄断市场，未来更大的机会正在发生甚至还未被挖掘，把握最佳的时机，就是现在！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候我们察觉不到变化，有时候其实是因为并不认可这样的变化，当变化已经形成时却又追悔莫及。所以，我们需要抛弃成见，拥抱变化。&lt;strong&gt;看准方向，找对风口，努力去飞&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有句话叫：风口上的猪也会飞。其实我并不认可这句话。说现实一点，想让猪飞起来，那得是多大的风啊！真有这样一个好的风口，聪明的人早已经把猪赶到不知道哪里去了，还有猪什么事。真正厉害的不是猪，而是扇风的人。有一句话说的好，「为了这些猪，我没少扇多少风。」&lt;/p&gt;

&lt;p&gt;所以，我对于 &lt;strong&gt;形成&lt;/strong&gt; 的理解是，深刻理解形成的本质，抓住最好的时机，付出持续的努力，遇到反对时能够坚定，遇到挫折时能够总结，跌倒时想着爬起来怎样继续前进。有一天你也许功成名就，也许一事无成。但这有什么关系呢，放眼到整个人类社会，&lt;strong&gt;形成&lt;/strong&gt; 的趋势并不因你而左右，你会感激形成的过程中创造出来的种种机会。&lt;/p&gt;

&lt;p&gt;《必然》这本书一共有 12 个关键词，每个关键词都需要深入的思考。我也感觉到一篇苍白无力的读后感是无法总结这本有深度的书，所以一篇文章聊其中一个关键词已经足够。下次我们再来聊聊下个关键词「&lt;strong&gt;知化(Cognifying)&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;附录：&lt;/p&gt;

&lt;p&gt;《必然》十二个关键词：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问、开始。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我和 ThoughtWorks 的一点小故事</title>
            <link>http://blog.coderzh.com/2016/01/18/thoughtworks-story/</link>
            <pubDate>Mon, 18 Jan 2016 23:05:24 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/18/thoughtworks-story/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/TW.jpg-wt&#34; alt=&#34;TW&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2009 年的时候买了一本《卓有成效的程序员》，看的热血沸腾，当时还写了一篇读后感《&lt;a href=&#34;http://blog.coderzh.com/2009/07/18/1526082/&#34;&gt;程序员的共鸣 - 读《卓有成效的程序员》&lt;/a&gt;》，现在翻来看还觉得蛮有意思的。从此后，开始用 Launchy ， ClipX 等提高效率的工具，也开始接触代码编辑器神器 Emacs 和 Vim 。当时年少无知先学了 Emacs ，还全程用 Emacs 开发过一个小项目。后来实在是小指按 ctrl 键按到桑爽的不行了，才发现 Vim 是多么和谐的存在。&lt;/p&gt;

&lt;p&gt;这本书是由 &lt;a href=&#34;https://www.thoughtworks.com/&#34;&gt;ThoughtWorks&lt;/a&gt; 中国公司翻译的，再加上当时用的持续集成工具 CCNet 就是 ThoughtWorks 开发的，瞬间觉得这个公司好牛逼。 更加牛逼的是，世界顶级的 OO 专家，敏捷开发创始人之一的 &lt;a href=&#34;http://www.martinfowler.com&#34;&gt;Martin Fowler&lt;/a&gt; 大牛就在 ThoughtWorks 担任首席科学家。&lt;/p&gt;

&lt;p&gt;当时对持续集成，敏捷开发还挺感兴趣，在博客里写了点东西，还特意关注了几个 ThoughtWorks 员工的博客。没事还在博客里留了几次言，突然有一天博客园的短消息里来了这么一条消息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;标题：如果你真的对coding有如此的热情&lt;/p&gt;

&lt;p&gt;可曾想过来ThoughtWorks?&lt;/p&gt;

&lt;p&gt;我看到你在我Blog上的留言了。如果你对代码如此热情，如果你喜欢体会作为程序员更多的可能，可曾想过来ThoughtWorks? 有兴趣的话请与我联系。作为前3年在各种类型的软件公司混过，后4年一直很enjoy的公司，看到你的Blog, 也许，这里是适合你的地方。&lt;/p&gt;

&lt;p&gt;陈金洲&lt;/p&gt;

&lt;p&gt;PS. 为了能联系到你，专门注册了博客园的账号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时的我工作快 3 年，正处于年少轻狂，自信爆棚，感觉啥都能干就缺一个机会的时代。把《设计模式》来回翻了几遍后，就和 Michael Chen 联系面试了。直到很多年后，我才听说， ThoughtWorks 被人称为“最难面试的 IT 公司”。首先说结论，最后我并没有去 ThoughtWorks 。具体情况见下文。&lt;/p&gt;

&lt;p&gt;第一面是 HR 的&lt;strong&gt;英文电话面试&lt;/strong&gt;，我英语也就四级的水平，听和看还行，但平时口语完全没机会训练。我在家设想了 HR 大概会问的几个问题，简单写了写，列了几个关键字就去了。当然，我还是很紧张，平时我就不太擅长电话里和别人沟通，而且还是要用英文，而且还是面试。 HR 的每个问题我还是听的很清楚的，我也就硬撑着把该说的说了。现在记得 HR 问了类似这样的问题：你的同事都是怎么评价你的？你平时遇到过什么难题又是如何解决的。我当时心里想着，当然要说一些同事夸奖我的话了，技术牛逼，喜欢分享，乐于助人之类的。也没遇到什么特别的难题啊，怎么编呢，一时又乱了方寸。&lt;/p&gt;

&lt;p&gt;第一轮电话面试后，我感觉糟透了，感觉没戏了。等了几周也未见回复，感觉就这样被淘汰了，不甘心就发邮件问了 HR 是不是被 out 了 ，HR 回复说还并没有结果让我再等等，又让我感觉到了一丝的希望。&lt;/p&gt;

&lt;p&gt;不久后，收到了邮件进入下一轮面试：&lt;strong&gt;Home Work&lt;/strong&gt; 。给了几道题，让选其中一道，在家写代码，写好后发给他们。我觉得这个环节不错，不像现场面试需要在高度压力的情况下用笔在纸上写代码。Home Work 是你自己在家做的，是在很自然放松的情况下，可以 google ，可以参考任何别人代码的情况下写的你的代码，是最接近真实工作时的状况。&lt;/p&gt;

&lt;p&gt;一共有三个可选题目：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PROBLEM ONE:  TRAINS&lt;/li&gt;
&lt;li&gt;PROBLEM TWO: SALES TAXES&lt;/li&gt;
&lt;li&gt;PROBLEM THREE: MARS ROVERS&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;我选了题目意思是我最容易看懂的 MARS ROVERS （火星漫游者）。&lt;/strong&gt;大意是给定火星探测机器人的一个坐标位置，然后给它发送一系列的指令，比如左转、右转、前进，最后输出他的目标点的坐标和朝向。&lt;/p&gt;

&lt;p&gt;我当时是这么想的，这题的算法很简单， ThoughtWorks 考察的肯定不是我能不能实现需求这么简单，而是考察我面向对象设计的能力，以及抽象的能力，能否把代码写的足够优雅，同时又具备很好的未来扩展性。而测试驱动开发作为敏捷开发的一个重要理念，我的 Home Work 里至少是需要包含测试代码的。虽然他们并不知道我是先写的代码还是先写的测试，嗯，我还是尝试先写测试代码，至少它的文件创建日期比功能代码会早一些，哈哈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这题肯定要用一些设计模式，但是又要避免过度设计。&lt;/strong&gt;于是我把最有可能关联的几个模式套了进去：工厂模式，状态模式，好像还有命令模式。把类分的很清晰，每个函数也很短，命名也是反复琢磨，最后还配上了单元测试案例。最后，把感觉非常完美的一份代码提交了上去。&lt;/p&gt;

&lt;p&gt;然后又等了漫长的几周，通知进入下一轮面试：&lt;strong&gt;电话技术面试&lt;/strong&gt;。面试我的就是 Michael Chen 。前面主要聊我现在的工作，做了一些什么项目，用了一些什么技术，问的很细，聊的挺愉快。聊完项目后，Michael Chen 提示我进入纯粹的答题环节，问了我一些设计模式相关的问题。&lt;/p&gt;

&lt;p&gt;这次电话技术面试聊完后，我感觉有戏，感觉 ThoughtWorks 正在向我招手。这是我理想中的，非常舒服的面试。但是我当时真的准备好了吗？真的准备好了从珠海赶赴西安或者北京去上班吗？我当时觉得地点无所谓，其实是没有太想清楚的。&lt;/p&gt;

&lt;p&gt;又是漫长的等待，&lt;strong&gt;心里面想着下一轮应该是飞到西安去和 ThoughtWorks 的工程师一起 Pair 结对编程了&lt;/strong&gt;。但等了好几周依然没有消息，我也开始考虑真的要去西安工作吗？我能适应那种经常出差的工作的？我以后真的要走咨询师的路线吗？我想了很久，最后某天 HR 突然来了一个电话，说&lt;strong&gt;前面面试的都很不错，但是英语方面还想和我再确认一次，要加一轮电话英语面试&lt;/strong&gt;。听完后，我感觉很不好，辛苦面试了这么久，又让我苦苦等待了这么久，最后又回到了第一轮的英语面试。我当时有点情绪，所以在加试的电话面试里表现的比第一次还差。&lt;/p&gt;

&lt;p&gt;HR 最后和我说，可能是毕业工作后英语口语用太少了，再复习多练习练习是可以的。&lt;strong&gt;建议我再花一个月的时间复习和练习一下英语口语，然后再来面试&lt;/strong&gt;。我当时已经有情绪了，这个面试折腾了 1 个多月，有点心累了。所以，后面我给 HR 发邮件说我不来了。&lt;/p&gt;

&lt;p&gt;直到最近，我才发现在 ThoughtWorks 的面试者中，被要求回去学习一段时间再回来面试的人大有人在，而且很多人最后都成功入职了。也许当时的我处理的是有点草率了。但命运这种东西谁知道呢，&lt;strong&gt;当时的一个决定对未来有什么影响，谁也说不清。我们还是要感恩现在的自己，以及之前做过的所有正确的和不正确的决定，是它们成就了现在的你。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这篇聊 ThoughtWorks 是因为&lt;a href=&#34;http://blog.coderzh.com/2016/01/16/coding-style-share/&#34;&gt;上篇文章&lt;/a&gt;提到的，认识了 ThoughtWorks 的前员工 &lt;a href=&#34;http://seabornlee.cn&#34;&gt;Seaborn Lee&lt;/a&gt; （小波） ，又让我想到了之前的面试经历。于是就和 Seaborn Lee 八卦了一下当年面试我的 Michael Chen 到底是怎样的一个存在。&lt;/p&gt;

&lt;p&gt;小波说了五个字：“&lt;strong&gt;他也是传奇&lt;/strong&gt;”，然后是这样描述的 ：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一是技术牛&lt;/p&gt;

&lt;p&gt;二是立志做产品&lt;/p&gt;

&lt;p&gt;承诺三年不调薪&lt;/p&gt;

&lt;p&gt;做了几款产品&lt;/p&gt;

&lt;p&gt;金数据成了被收购&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;瞬间让我佩服的五体投地。我从很多 ThoughtWorks 员工那了解到，不管是离职的还是在职的，他们对 ThoughtWorks 公司都是满口的称赞，对公司的认可度非常非常的高，说明这真是一家不错的公司呢。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
