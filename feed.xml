<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title> on CoderZh Blog</title>
        <link>http://blog.coderzh.com/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Sun, 27 Mar 2016 12:57:37 CST</updated>
        
        <item>
            <title>做了一个 Hugo 的主题：hugo-pacman-theme</title>
            <link>http://blog.coderzh.com/2016/03/27/hugo-pacman-theme/</link>
            <pubDate>Sun, 27 Mar 2016 12:57:37 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/27/hugo-pacman-theme/</guid>
            <description>

&lt;p&gt;Hugo 是由 Go 语言实现的静态网站生成器，通过 Hugo 可以快速生成一个静态网站，比如个人博客。在 &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt; 的静态网站生成器排名里，Hugo 排名第五，也是相当的不错。&lt;/p&gt;

&lt;p&gt;Hugo 本身有很多不错的主题，但挑剔的朋友可能会觉得还不够，希望看到 Jeklly 或 Hexo 里漂亮的主题时也能在 Hugo 里找到对应的主题。其实 Hugo 的主题制作并不复杂，有兴趣的同学可以尝试自己制作主题，或者将其他静态网站生成器里的主题转成 Hugo 的主题。&lt;/p&gt;

&lt;p&gt;不会做的话参考我做的这个主题（&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;hugo-pacman-theme&lt;/a&gt;）代码，基本的 Hugo 模板功能都用上了。&lt;/p&gt;

&lt;h3 id=&#34;pacman:54fdd68c9a36858a04277e9977a250be&#34;&gt;Pacman&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://yangjian.me/pacman/&#34;&gt;Pacman&lt;/a&gt; 是一个不错的 Hexo 主题，一直有冲动把这个主题转成 Hugo 的，再加上 Hugo 交流群里有朋友也提到了这个主题，于是利用周末的时间制作了这个主题：&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;hugo-pacman-theme&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;演示地址：&lt;a href=&#34;http://coderzh.github.io/hugo-pacman-theme/&#34;&gt;http://coderzh.github.io/hugo-pacman-theme/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;截图:54fdd68c9a36858a04277e9977a250be&#34;&gt;截图&lt;/h4&gt;

&lt;p&gt;主页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-pacman-tn.png&#34; alt=&#34;hugo-pacman-tn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;文章页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-pacman-theme.png&#34; alt=&#34;hugo-pacman-theme&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;支持功能:54fdd68c9a36858a04277e9977a250be&#34;&gt;支持功能&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;li&gt;标签（标签云）&lt;/li&gt;
&lt;li&gt;归档&lt;/li&gt;
&lt;li&gt;RSS&lt;/li&gt;
&lt;li&gt;文章大纲（Table Of Content）&lt;/li&gt;
&lt;li&gt;文章分享功能&lt;/li&gt;
&lt;li&gt;图片点击预览（FancyBox）&lt;/li&gt;
&lt;li&gt;多说评论（及 Disqus 评论）&lt;/li&gt;
&lt;li&gt;Google Analytics&lt;/li&gt;
&lt;li&gt;代码高亮优化（GitHub 配色）&lt;/li&gt;
&lt;li&gt;高度配置化，你要的东西都可以通过 config.toml 进行配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;使用方法:54fdd68c9a36858a04277e9977a250be&#34;&gt;使用方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，确保安装了最新版 Hugo。下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo Release&lt;/a&gt;，如果使用 Mac ，直接用 Homebrew 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把 hugo-pacman-theme clone 下来，放到你的 Hugo 站点的 themes 目录里（Hugo 的使用方法详见：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/coderzh/hugo-pacman-theme
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置文件，拷贝一份或者参考：&lt;code&gt;hugo-pacman-theme/exampleSite/config.toml&lt;/code&gt;，配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;BaseURL = &amp;quot;http://coderzh.github.io/&amp;quot;
LanguageCode = &amp;quot;zh-CN&amp;quot;
HasCJKLanguage = true
Title = &amp;quot;Hugo PacMan Theme Demo&amp;quot;
Theme = &amp;quot;hugo-pacman-theme&amp;quot;
pygmentsStyle = &amp;quot;default&amp;quot;
pygmentsUseClasses = true
RSSUri = &amp;quot;feed.xml&amp;quot;

[Author]
  Name = &amp;quot;coderzh&amp;quot;

[Params]
  AuthorHomepage = &amp;quot;http://blog.coderzh.com&amp;quot;
  BottomIntroduce = &amp;quot;Introduce1 &amp;lt;br/&amp;gt; Introduce2&amp;quot;
  Description = &amp;quot;&amp;quot;
  Subtitle = &amp;quot;subtitle&amp;quot;
  Weibo = &amp;quot;coderzh&amp;quot;
  WeiboID = 1816308191
  Twitter = &amp;quot;coderzh&amp;quot;
  GitHub = &amp;quot;coderzh&amp;quot;
  Facebook = &amp;quot;coderzh&amp;quot;
  LinkIn = &amp;quot;coderzh&amp;quot;
  Imglogo = &amp;quot;img/logo.svg&amp;quot;
  AuthorImg = &amp;quot;img/author.jpg&amp;quot;
  # 日期时间格式
  DateFormat = &amp;quot;2006年01月02日&amp;quot;
  MonthFormat = &amp;quot;2006年01月&amp;quot;
  FancyBox = true

  # 使用多说评论
  #[Params.DuoShuo]
  #  ShortName = &amp;quot;coderzh&amp;quot;

  # 使用 Disqus 评论
  [Params.Disqus]
    ShortName = &amp;quot;coderzh&amp;quot;

  # Google 统计
  [Params.GoogleAnalytics]
    ID = &amp;quot;UA-10147768-2&amp;quot;

  # 多语言字符串
  [Params.Strings]
    Search = &amp;quot;搜索&amp;quot;
    PageNotFound = &amp;quot;你访问的页面不存在&amp;quot;
    ShowSideBar = &amp;quot;显示侧边栏&amp;quot;
    HideSideBar = &amp;quot;隐藏侧边栏&amp;quot;
    Categories = &amp;quot;分类&amp;quot;
    Archive = &amp;quot;归档&amp;quot;
    Tags = &amp;quot;标签&amp;quot;
    TagCloud = &amp;quot;标签云&amp;quot;
    Rss = &amp;quot;RSS 订阅&amp;quot;
    TableOfContents = &amp;quot;文章目录&amp;quot;

[Menu]
  [[Menu.Main]]
    Name = &amp;quot;首页&amp;quot;
    URL = &amp;quot;/&amp;quot;
    Weight = 1
  [[Menu.Main]]
    Name = &amp;quot;关于&amp;quot;
    URL = &amp;quot;/about&amp;quot;
    Weight = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;最后:54fdd68c9a36858a04277e9977a250be&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;该主题参考的 &lt;a href=&#34;https://github.com/A-limon/pacman&#34;&gt;Pacman&lt;/a&gt;，使用 Hugo 的模板语法纯手工一行一行打造。有需要的朋友尽管拿去使用，有问题欢迎反馈：&lt;/p&gt;

&lt;p&gt;GitHub 地址：&lt;a href=&#34;https://github.com/coderzh/hugo-pacman-theme&#34;&gt;https://github.com/coderzh/hugo-pacman-theme&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo 中文文档：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo 交流 QQ 群：512499080&lt;/p&gt;

&lt;p&gt;该主题已经&lt;a href=&#34;https://github.com/spf13/hugoThemes/issues/121&#34;&gt;提交&lt;/a&gt;到官方的主题列表，相信不久就可以在官方的 &lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;http://themes.gohugo.io/&lt;/a&gt; 上看到了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>懒程序员和他的 dotfiles</title>
            <link>http://blog.coderzh.com/2016/03/19/dotfiles/</link>
            <pubDate>Sat, 19 Mar 2016 15:05:47 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/19/dotfiles/</guid>
            <description>

&lt;p&gt;如果你不知道什么是 dotfiles，那你就不会知道什么是 dotfiles。如果你知道什么是 dotfiles，那你就知道什么是 dotfiles。&lt;/p&gt;

&lt;p&gt;以一段废话开场，引出今天的主题：&lt;code&gt;dotfiles&lt;/code&gt;。软件匠艺社区（&lt;a href=&#34;codingstyle.cn&#34;&gt;codingstyle.cn&lt;/a&gt;）周三晚上有一期分享介绍 Vim 时提到了 dotfiles，这篇文章我们就来好好说一说 dotfiles。&lt;/p&gt;

&lt;h3 id=&#34;什么是-dotfiles:50fc662a6f6921bb445d80a429a8e146&#34;&gt;什么是 dotfiles？&lt;/h3&gt;

&lt;p&gt;dot 即「点」的意思，意思是以点开头的文件。如果你不是程序员，你大概会说，我咋从来没见过这种文件啊？因为这些文件通常都是隐藏文件，平常一般看不到，比如 .git 目录。但这里说的 dotfiles 主要是指用户 home 目录下的点文件，这类文件一般是一些配置文件，比如 vim 的配置文件 .vimrc，zsh 的配置文件 .zshrc 等。通过设置这些配置文件，可以实现出很强大的功能，比如有不少人通过配置 .vimrc，把 vim 活生生变成了一个功能强大的 IDE。还有一些偷懒的程序员在 .profile 之类的文件里设置了大量命令的 alias。以至于你还没看清楚他敲的第一个命令，他已经敲了三四个命令了。&lt;/p&gt;

&lt;p&gt;通过配置各种 dotfiles，程序员可以把系统定制得既顺手又高效。但是问题来了，自己千辛万苦调的设置，如果换一台机器，又得重新设置一遍。这对于追求效率的程序员来说是不可接受的。&lt;/p&gt;

&lt;h3 id=&#34;dotfiles-管理:50fc662a6f6921bb445d80a429a8e146&#34;&gt;dotfiles 管理&lt;/h3&gt;

&lt;p&gt;于是会玩又懒的程序员想出了一个办法，把所有的 dotfiles 放在一个单独的目录进行统一管理，放到 GitHub 或者通过网盘同步。&lt;/p&gt;

&lt;p&gt;为了让 dotfiles 生效，主要有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过一个脚本，把所有 dotfile 文件 rsync 到 HOME 目录。&lt;/li&gt;
&lt;li&gt;使用软链，让 HOME 目录的 dotfile 文件指向你目录的 dotfile 文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式适合机器初装，但是假如你有两台机器，希望配置能方便的进行同步，第二种方式是更好的选择。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s ~/dotfiles/.vimrc ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，假如你的 dotfile 文件很多，手工去维护那些软链也是一件麻烦的事情。而程序员又是最不能忍受麻烦的，于是造了各种轮子去维护和管理这些 dotfiles 。&lt;/p&gt;

&lt;p&gt;有些人把软链的管理写成一个 Shell 脚本，也有人做成特定的工具。比如：&lt;a href=&#34;https://github.com/thoughtbot/rcm&#34;&gt;rcm&lt;/a&gt;、 &lt;a href=&#34;http://skwp.github.io/dotfiles/&#34;&gt;YARD&lt;/a&gt;、 &lt;a href=&#34;https://pypi.python.org/pypi/dotfiles&#34;&gt;dotfiles&lt;/a&gt;、 &lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;mackup&lt;/a&gt; ……&lt;/p&gt;

&lt;h3 id=&#34;mackup:50fc662a6f6921bb445d80a429a8e146&#34;&gt;mackup&lt;/h3&gt;

&lt;p&gt;在对比了各种 dotfiles 工具后，我最终选择了 &lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;mackup&lt;/a&gt;。理由主要如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用方便，配置起来非常简单。&lt;/li&gt;
&lt;li&gt;社区贡献了大量现成的软件的 dotfiles 配置，可以直接使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 OS X 下，可以直接使用 brew 安装 mackup。其他系统下，可以直接使用 pip 安装。安装好后，备份和还原都只需要一个命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 备份
$ mackup backup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新机器上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 还原
$ mackup restore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想要那些软链了，只需要执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mackup uninstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mackup 可以通过配置文件，指定你希望备份哪些 dotfiles，以及备份到哪里（支持备份到 Dropbox、Google Drive、Copy、iCloud、Box 以及指定的目录。&lt;/p&gt;

&lt;p&gt;比如在我的 mac 上，我的 &lt;a href=&#34;https://github.com/coderzh/dotfiles/blob/master/home/.mackup.cfg&#34;&gt;.mackup.cfg&lt;/a&gt; 这样设置的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[storage]
engine = file_system
path = dotfiles
directory = home 

[applications_to_sync]
atom
pycharmce
myvim
ideaic15
zsh
mackup
dash
karabiner
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;storage&lt;/code&gt; 里指定了备份到文件系统的 ~/dotfiles/home 路径。&lt;code&gt;applications_to_sync&lt;/code&gt; 指定了备份哪些应用的 dotfiles。mackup 预先定义好了大量 application 的 dotfiles，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Atom
Bash
Dash
Emacs
Flux
Git
Gradle
MacOSX
MacVim
npm
Oh My Zsh
Vim
WebStorm
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要定制某个 application 的 dotfiles 也很简单，比如我发现 mackup 自带的配置里没有 IntelliJ Community 版本的配置，我只需要在新建一个文件： ~/.mackup/ideaic15.cfg ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[application]
name = My IntelliJ IDEA 15

[configuration_files]
Library/Preferences/IdeaIC15/keymaps/Mac OS X copy.xml
Library/Preferences/IdeaIC15/options/keymap.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;configuration_files&lt;/code&gt; 里指定我需要备份的文件即可。非常的简单易用。&lt;/p&gt;

&lt;h3 id=&#34;自动安装软件:50fc662a6f6921bb445d80a429a8e146&#34;&gt;自动安装软件&lt;/h3&gt;

&lt;p&gt;在一台新机器上，把之前机器装的软件一个一个手动安装也是非常耗时和麻烦的事情。如果你使用的是 Mac OS X，将会变得非常简单，因为绝大部分的软件开发包及软件都可以通过 &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; 和 &lt;a href=&#34;https://caskroom.github.io/&#34;&gt;brew cask&lt;/a&gt; 来安装。&lt;/p&gt;

&lt;p&gt;我的 Mac 上 99.9% 的软件，可以通过我写的 &lt;a href=&#34;https://github.com/coderzh/dotfiles/blob/master/install/brew.sh&#34;&gt;brew.sh&lt;/a&gt; 脚本来安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Install Homebrew

# Ask for the administrator password upfront.
sudo -v

# Keep-alive: update existing `sudo` time stamp until the script has finished.
while true; do sudo -n true; sleep 60; kill -0 &amp;quot;$$&amp;quot; || exit; done 2&amp;gt;/dev/null &amp;amp;

# Check for Homebrew,
# Install if we don&#39;t have it
if test ! $(which brew); then
  echo &amp;quot;Installing homebrew...&amp;quot;
  ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
fi

brew tap homebrew/versions
brew update
brew upgrade --all

# Install packages
apps=(
    caskroom/cask/brew-cask
    cmake
    coreutils
    findutils
    git
    gnu-sed --with-default-names
    go
    hugo
    mercurial
    mackup
    macvim
    mysql
    android-platform-tools
    python
    ruby
    svn
    vim
    wget
    zsh
)

caskapps=(
    android-studio
    alfred
    atom
    cheatsheet
    dash
    genymotion
    google-chrome
    intellij-idea-ce
    iterm2
    java
    karabiner
    keepassx
    kindle
    macdown
    pomotodo
    pycharm-ce
    qq
    qqmusic
    qqmacmgr
    sogouinput
    thunder
    vagrant
    virtualbox
    vlc
    wiznote
    youdao
)

brew install &amp;quot;${apps[@]}&amp;quot;
brew tap caskroom/versions
brew cask update
brew cask install --appdir=&amp;quot;/Applications&amp;quot; &amp;quot;${caskapps[@]}&amp;quot;
brew cleanup
brew cask cleanup
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pip-npm-gem:50fc662a6f6921bb445d80a429a8e146&#34;&gt;pip、npm、gem&lt;/h3&gt;

&lt;p&gt;使用 pip、npm、gem 安装的包也使用脚本进行一键安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade pip
pip install powerline-status
pip install MySQL-python
pip install tornado
pip install torndb
pip install pycrypto
pip install mock
# npm、gem ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-x-的系统设置:50fc662a6f6921bb445d80a429a8e146&#34;&gt;OS X 的系统设置&lt;/h3&gt;

&lt;p&gt;当你拿到一台新的 Mac 然后开机时，不知道有没有被 Duang~ 的一声吓到的经历。当时吓得的宝宝我赶紧找了如何关闭开机声音的方法（设置静音、插上耳机都不管用！），只要执行一条命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nvram SystemAudioVolume=&amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多的系统设置都可以通过命令来完成，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 电池显示是百分百
defaults write com.apple.menuextra.battery -bool true

# 设置键盘按键重复的延迟
defaults write NSGlobalDomain KeyRepeat -int 3

# 禁止自动拼写纠正
defaults write NSGlobalDomain NSAutomaticSpellingCorrectionEnabled -bool false

# Finder 显示状态栏
defaults write com.apple.finder ShowStatusBar -bool true

# Finder 显示地址栏
defaults write com.apple.finder ShowPathbar -bool true

# 禁止在网络驱动器上生成 .DS_Store 文件 
defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字体:50fc662a6f6921bb445d80a429a8e146&#34;&gt;字体&lt;/h3&gt;

&lt;p&gt;程序员喜欢折腾的几样东西：键盘、编辑器、字体。程序员钟爱的几种字体，包括 Source Code Pro、Hack、Menlo 等等，其中对 powerline 字体更是最爱。把所有心爱的字体放在 dotfiles/fonts 目录里，通过自动安装脚本里直接拷贝到 ~/Library/Fonts/ 目录下即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp -r ~/dotfiles/fonts/* ~/Library/Fonts/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 powerline 字体需要安装 powerline-status，这个在前面讲的 pip 脚本里已经安装了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install powerline-status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;zsh 中使用 powerline 字体，只需要在 .zshrc 中加一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /usr/local/lib/python2.7/site-packages/powerline/bindings/zsh/powerline.zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/zsh-powerline.png&#34; alt=&#34;zsh-powerline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 vim 里使用 powerline 字体，只需要在 .vimrc 里加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set rtp+=/usr/local/lib/python2.7/site-packages/powerline/bindings/vim
set laststatus=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/vim-powerline.png&#34; alt=&#34;vim-powerline&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;总结:50fc662a6f6921bb445d80a429a8e146&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;懒程序员如果拿到了一个新的 Mac 机器，他只需要做如下几步，就可以把这台新的机器变成熟悉的一台机器：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 XCode（最好在 Mac Store 里下载安装完整版的 XCode，因为有些软件安装依赖完整版 XCode）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo softwareupdate -i -a
$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动安装软件及系统设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ git clone https://github.com/coderzh/dotfiles.git
$ source dotfiles/install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 mackup 恢复 dotfiles。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp ~/dotfiles/.mackup.cfg ~/
$ cp -r ~/dotfiles/.mackup ~/
$ mackup restore
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如果一切顺利，程序员，你没有浪费上班时间装电脑，你可以开始搬砖了。:-)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（对了，iTerm2 的 Color 设置好像必须手工操作，配色列表可以在 &lt;a href=&#34;https://github.com/mbadolato/iTerm2-Color-Schemes&#34;&gt;https://github.com/mbadolato/iTerm2-Color-Schemes&lt;/a&gt; 找，作为 JetBrains 粉，最后我选择了 JetBrains Darcula.itermcolors 这一款。）&lt;/p&gt;

&lt;p&gt;在 GitHub 里搜 &lt;code&gt;dotfiles&lt;/code&gt; 可以看到大量的 dotfiles，当然，别忘了 Star 我的 dotfiles：&lt;a href=&#34;https://github.com/coderzh/dotfiles&#34;&gt;https://github.com/coderzh/dotfiles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后，温馨提示下，千万不要把 ssh、mysql 密码相关的内容提交上去呦~&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mathiasbynens/dotfiles&#34;&gt;https://github.com/mathiasbynens/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/skwp/dotfiles&#34;&gt;https://github.com/skwp/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/donnemartin/dev-setup&#34;&gt;https://github.com/donnemartin/dev-setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpro/awesome-dotfiles&#34;&gt;https://github.com/webpro/awesome-dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jbernard/dotfiles&#34;&gt;https://github.com/jbernard/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lra/mackup&#34;&gt;https://github.com/lra/mackup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpro/dotfiles&#34;&gt;https://github.com/webpro/dotfiles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>使用番茄工作法一个月感受</title>
            <link>http://blog.coderzh.com/2016/03/06/pomotodo/</link>
            <pubDate>Sun, 06 Mar 2016 21:40:47 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/03/06/pomotodo/</guid>
            <description>&lt;p&gt;之前就听说过「番茄工作法」，但是一直没有尝试。春节期间，新买的 MacBook Pro 到了之后，开始装各种效率软件时，发现有人推荐 pomotodo 这个番茄工作法的软件。于是试着了解了下所谓的「番茄工作法」，并且开始尝试，结果一发不可收拾。&lt;/p&gt;

&lt;p&gt;在使用了「番茄工作法」几天后，我就打算写一篇关于它的文章。但是我担心我对它也就几天的热度，于是我打算看看我能坚持多久。除了在家里使用「番茄工作法」，在公司我也使用，到今天为止，差不多坚持了一个月。&lt;/p&gt;

&lt;p&gt;而在刚开始听到那些所谓的「xxx 工作法」，我是不信的。即使大家都说它好，我也会产生一种本能的抗拒心态，大家越说它好，我越抗拒，甚至选择忽略它，不去尝试它。因为在我原来的价值观里，人们想要成功，靠那些所谓的「xxx 工作法」是不靠谱的。&lt;/p&gt;

&lt;p&gt;就像《后会无期》里说的：「&lt;strong&gt;听过很多道理，依然过不好这一生&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;我开始思考，如果「番茄工作法」真有那么好，为什么没有听说过哪些成功人士、科学家、伟大的程序员使用了「番茄工作法」？&lt;/p&gt;

&lt;p&gt;而且，「番茄工作法」特别容易让我联想到 GTD （Get Things Done）工具。在我刚工作不久的时候，金山请了一位讲师介绍了 GTD 。那是我第一次听说 GTD ，当时引发了我很大的兴趣。现在还可以在我的博客里找到当时写下的一篇文章《&lt;a href=&#34;http://blog.coderzh.com/2010/01/03/1638096/&#34;&gt;时间管理GTD工具&lt;/a&gt;》（2010 年 1 月）。我尝试过十几二十种不同的 GTD 工具，但是坚持用下来的却没有一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个东西适不适合自己，只有亲身尝试后才知道。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我知道有些人一直都在使用 GTD 工具，但是我经过各种尝试之后，发现 GTD 并不适合我。当我刚遇见「番茄工作法」时，我甚至不想开始尝试了。辛亏了 MacBook ，让我有机会做了一些尝试，也让我明白了一些道理：&lt;/p&gt;

&lt;p&gt;那些成功人士、科学家、伟大的程序员也许的确从不使用番茄工作法，因为他们根本就不需要。他们对所从事的事业有着本能的无限热情，他们不需要借助外部的工具就能做到注意力集中，对事物保持长久的热情，本能的已经对时间有了很好的利用。&lt;/p&gt;

&lt;p&gt;而作为普通大众的我，平时有太多的诱惑让我分心，微信、QQ、微博等等。我的注意力开始变得没那么集中，总是在干正事的时候做着做着就开始折腾起和正事毫无关系的事。&lt;/p&gt;

&lt;p&gt;在凯文凯利的《必然》里提到，人类的注意力是稀缺的资源。新的事物和产品会大量涌现，但是每个人一天的时间只有 24 小时，而一天里能吸引注意力的时间又是更少。&lt;/p&gt;

&lt;p&gt;我开始承认随着社交网络的兴起，我的注意力开始变得涣散。所以，番茄工作法也许适合我。它让我注意力保持集中，让我更好的利用时间，也让我更有成就感。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，从现在开始，尝试一下「番茄工作法」吧！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说了那么多，还没介绍今天的主角。到底什么是番茄工作法？&lt;/p&gt;

&lt;p&gt;番茄是指番茄钟，一种在厨房用来计时的闹钟。当你决定做一件事时，扭动番茄钟定时 25 分钟，在滴滴答答的时钟声音下，你专注于完成这 25 分钟内要完成的事。期间一旦你被打扰，或者开始做无关的事情，你必须重新开始计时。25 分钟后，再次扭动番茄钟定时 5 分钟用来休息，这时完全不去想刚才的事情，而是好好的放松一下。&lt;/p&gt;

&lt;p&gt;规则非常的简单，为此我还专门买了一个真实的番茄钟，也许是因为几块钱的便宜货，这东西时间到的时候的闹铃声太大以至于我会被它吓到。所以，我现在一直使用软件来进行计时。&lt;/p&gt;

&lt;p&gt;开始一个最好的尝试，就是使用「番茄工作法」阅读《番茄工作法图解》。&lt;/p&gt;

&lt;p&gt;看过了这本书，你会对番茄工作法有更深的了解。你会明白为什么那些软件默认都要模拟番茄钟滴滴答答的声音。我刚开始也是非常的不习惯滴滴答答的声音，觉得是一种噪音反而让我分心，所以我都把声音关了。后来看了书，我才明白，扭动番茄钟的动作，听到滴滴答答的倒计时时间，其实是一种很好的仪式感。表示我现在正在一个番茄钟的时间内，让自己保持注意力。我现在已经离不开滴滴答答的声音了。&lt;/p&gt;

&lt;p&gt;使用番茄工作法除了让你注意力更集中之外，还有诸多好处，比如：&lt;/p&gt;

&lt;p&gt;一件你一直都想做，但是每次想想都觉得很麻烦，从而一直都未动手去做的事。使用番茄工作法，抛开那些长远的麻烦烦恼，只关注现在这 25 分钟内要做的事。再麻烦的事总得开始，一旦开始，很多麻烦烦恼自然被解决了。（解决拖延症）&lt;/p&gt;

&lt;p&gt;又比如：&lt;/p&gt;

&lt;p&gt;你精神亢奋持续保持高度集中注意力的工作，从而忘记了休息，你开始腰酸腿疼，颈椎病开始来找你。使用番茄工作法，每 25 分钟，都提醒你必须站起来活动活动，倒一杯水，和同事闲聊几句。&lt;/p&gt;

&lt;p&gt;再比如：&lt;/p&gt;

&lt;p&gt;项目 deadline 就要到了，但是还有一大堆事情没做，你开始变得紧张起来，你开始焦虑，手忙脚乱，一想到大 Boss 苛刻的眼神，你敲键盘的手已经开始颤抖。使用番茄工作法，在剩下的每个 25 分钟内，我只关注当前的任务，既保持高效完成了任务，又缓解了紧张的情绪。&lt;/p&gt;

&lt;p&gt;在 5 分钟的间隔时间，由于处于完全放松的状态，这时更容易有大局观，而不是扎进到具体的事情后出不来。一旦发现前面做的事情方向错了，立马可以开始调整。&lt;/p&gt;

&lt;p&gt;同时，使用「番茄工作法」，你可以很好的对做的事情进行回顾总结。比如，以下是我近一个月来使用「番茄工作法」的统计情况（统计不一定完全准确，有漏记的情况）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/pomotodo.png&#34; alt=&#34;pomotodo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用番茄工作法，我利用周末的时间，看了几本书，更新了 Hugo 中文文档，学习了 Ruby On Rail，写了一个 Android APP。当然，还包括写公众号文章。&lt;/p&gt;

&lt;p&gt;就在现在，我还处于番茄钟的时间内。写这篇文章，我差不多花了 4 个番茄钟的时间。它也在提醒我，未来我在做同样事情时，我能不能更高效，用更少的番茄钟来完成。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>《必然》读书笔记之 - 知化Cognifying</title>
            <link>http://blog.coderzh.com/2016/02/21/inevitable-cognifying/</link>
            <pubDate>Sun, 21 Feb 2016 19:05:10 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/21/inevitable-cognifying/</guid>
            <description>&lt;p&gt;2002 年左右，KK 参加了谷歌的一个小型聚会，当时谷歌还是一个家专注搜索的小公司。KK 问拉里·佩奇「已经有这么多家搜索公司，干嘛还要做免费网络搜索？」&lt;/p&gt;

&lt;p&gt;佩奇回答说：「哦，我们其实是在做人工智能。」&lt;/p&gt;

&lt;p&gt;「知化」这个词不太好理解，其实主要说的是人工智能，即让机器或物体拥有智能的过程，技术上涉及到神经网络、机器学习、大数据等领域。如果你正在从事相关领域的研究，是很有前途的方向。&lt;/p&gt;

&lt;p&gt;去年公司有次请了个机器学习的专家来讲课，从头到尾我居然没有听懂他在讲什么。。当然，原因主要是在我的。毕竟机器学习这块属于专业的领域，需要有很多专业知识做背书，我之前对这块也了解甚少。&lt;/p&gt;

&lt;p&gt;但我相信机器学习的大致概念其实是很好解释清楚的，即通过设计一些算法，让计算机能够进行自我学习和改进。有人会想，计算机有这么牛逼吗？还会自己学习？其实这正是一个比较容易误解的地方。并非程序员把代码写好，计算机自个儿在哪里跑就把什么都学会了。机器学习其实是需要人为训练的过程，通过人类不断的告诉机器哪些是对的哪些是错的，准备大量训练的数据，机器通过训练来自动修正已有的算法以达到最佳的效果。&lt;/p&gt;

&lt;p&gt;举个栗子，文章开头提到的，谷歌创始人说谷歌其实是在做人工智能。首先，谷歌的搜索引擎有一套基于 Page Rank 的算法，能够根据关键词自动搜索出相关的网页。算法虽然很先进，但毕竟有时会出错，比如最佳的搜索结果并没有排在第一位。但用户是会自己判断哪个搜索结果对自己有用，用户会用脚投票，谷歌通过分析哪个搜索结果的点击率最高，来自动修正搜索引擎的算法，从而找出最合适的结果排在第一位。&lt;/p&gt;

&lt;p&gt;人工智能目前主要应用在比如垃圾邮件检测、数字识别、语音识别、人脸识别、各种智能设备，自动驾驶等领域，人工智能是未来科技发展的「必然」。对于未来的人工智能，除了给人类带来便利之外，人类也表现出了很多担心。在「知乎」里有个著名的讨论「&lt;a href=&#34;https://www.zhihu.com/question/27864852/answer/39007053&#34;&gt;为什么有很多名人让人们警惕人工智能？&lt;/a&gt;」，答案排名第一个的谢熊猫君开头就给出了一个让人震惊的结论：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人工智能很可能导致人类的永生或者灭绝，而这一切很可能在我们的有生之年发生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;的确是有点危言耸听，而《必然》的作者 KK 显然是人工智能的乐观派，他相信人工智能并不能完全取代人类，而是对人类不擅长的能力的一种补充。计算机的有些能力是人类所不具备的，比如超强记忆容量，超强的计算能力，所以我们发明了硬盘和 CPU 。我们的思维方式不擅长做统计，于是我们制造出各种统计技术很强的智能设备。人类开车比如容易走神分心，于是我们研究制造自动驾驶。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「创造聪明绝顶的人工智能是个错误，因而探究更多智能种类显得更为明智」&lt;/strong&gt; 从这句话看来，KK 这个乐观派也未必是那么的乐观。也许他是对的，开发一个聪明绝顶的全面人工智能的机器人，对于人类来说本身就是个错误，何况技术实现也非常困难。所以，只要人工智能在某一种特定的心智表现出色就好。比如自动驾驶的人工智能只会做好驾驶一件事，预测天气的人工智能只会用来预测天气。&lt;/p&gt;

&lt;p&gt;假设人工智能在各个方面都逐渐取代了人类，那必然会导致大量的职业消失。就像自动化实现后，机器代替了农民以及在农场作业的动物，淘汰了当时大多数人的工作。作为程序员，想到的是以后人工智能可以根据用户的语音需求自动编写代码，大量的程序员将失业。&lt;/p&gt;

&lt;p&gt;机器将取代更多人类工种，一切都是时间问题。KK 甚至放出了这样的话：&lt;/p&gt;

&lt;p&gt;「或许很难令人相信，但在本世纪结束前，如今人们从事的职业中有 70% 很可能会被自动化设备取代。不用说，亲爱的读者，你的工作也会被机器取代。广泛的自动化将会触及包括体力劳动和知识型工作在内的所有工种。」&lt;/p&gt;

&lt;p&gt;「无论你是一名医生、律师、建筑师、记者甚至程序员，机器人都将历史性地接管你的工作。」&lt;/p&gt;

&lt;p&gt;所以，不要再以为你的职业一定可以干一辈子，也不要以为在大公司上班就一定可以工作到退休，也许某天你所从事的这个职业本身就消失了。你的搬砖技术练的再好，已经没有任何公司需要人搬砖了。&lt;/p&gt;

&lt;p&gt;那么，人类做什么？会有更多新的职业产生出来。未来自动驾驶的汽车随处可见，而相应的会衍生出一个新的名为行程优化师的新工作。当外科自动化机器人成为常规后，会出现一种新的专业分析师，为你解读数据。（未来代码都由机器来自动编写，测试，部署上线，服务器坏了有机器人自动维修。我想不出会出现什么新的职业，也许程序员会变成一个更高端的职业，主要设计和优化机器人使用的编程语言，开发用来生成代码的代码。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「几乎人人都能得到个人机器人，但是仅仅拥有一个机器人并不是成功的关键。成功将青睐那些以最优化的方式与机器人以及机器一同工作的人。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;「人类的工作就是不停地给机器人安排任务，这本身就是一项永远做不完的工作，所以，我们至少还能保留这份『工作』。」&lt;/p&gt;

&lt;p&gt;「将来，无论你现在从事什么工作，收入水平如何，都讲反复经历机器人代替人的以下 7 个步骤：」&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;机器人干不了我的工作。&lt;/li&gt;
&lt;li&gt;好吧，它会许多事情，但是我做的事情它不一定都会。&lt;/li&gt;
&lt;li&gt;好吧，我做的事情它都会，但是它常常出故障，这时需要我来处理。&lt;/li&gt;
&lt;li&gt;好吧，它干常规工作时从不出错，但是我需要训练它学习新任务。&lt;/li&gt;
&lt;li&gt;好吧，就让它做我原来的工作吧，那工作本来就不是人该干的。&lt;/li&gt;
&lt;li&gt;哇，机器人正在干我以前做的工作，我的新工作不仅好玩多了，工资还高。&lt;/li&gt;
&lt;li&gt;真高兴，机器人绝对干不了我现在做的事情。&lt;/li&gt;
&lt;li&gt;【重复】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;「未来，你的薪水高低将取决于你能否和机器人默契配合。90% 的同事将会是看不见的机器，而没有他们，你的大部分工作将无法完成。这一切都是必然的。让机器人代替我们从事现在的工作，让我们在它们的帮助下去构想有意义的新工作吧。」&lt;/p&gt;

&lt;p&gt;在未来，使用编程语言手敲代码可能会被视为一种复古行为。趁着现在这个到处就差一个程序员的时代，多敲几行代码，说不定就改变世界了呢？&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我的第一台 Mac</title>
            <link>http://blog.coderzh.com/2016/02/09/my-first-mac/</link>
            <pubDate>Tue, 09 Feb 2016 10:42:05 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/09/my-first-mac/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mac.JPG-w&#34; alt=&#34;mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;新年第一篇，祝大家猴年大吉，心想事成，万事如意！&lt;/p&gt;

&lt;p&gt;这两天在家里除了带孩子就是在摆弄新到的 MacBook Pro 了。嗯，前几天咬一咬牙，双手颤抖的点击了下单按钮，第三天就收到了。&lt;/p&gt;

&lt;p&gt;当初在买 MBP 还是 iMac 之间纠结过，因为已经有一个台式机，所以确定了买 MBP。然后就是纠结买 13 吋还是 15 吋。之前我去广州新开的苹果体验店看过，15 吋的略大了点，13 吋的大小刚刚好，本来打算就买 13 吋的。直到下单前，又改变主意了，考虑便携性和性能，我更倾向于性能，于是最后一刻改成了 15 吋标准配置（16 G内存 512闪存）。购买时，我使用了教育商店购买，便宜了 1500 软妹币。我准备了堂弟的学生证，然而第二天苹果直接就给我发货了，并没有要求我出示学生证。后来听说是抽查的。&lt;/p&gt;

&lt;p&gt;平常我大都是在 Windows 的平台下开发的，有时用一用 Linux。感觉 Windows 平台下的开发工具链其实挺完善的，写 C/C++ ，C# 有号称宇宙无敌 IDE 的 Visual Studio ，写 Python 有 PyCharm，写 Java 有 IntelliJ ，写 Android 有 Android Studio ，编辑器有 gVim 。对应的效率工具也一应俱全：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Total Commander 装机必备的神器，谁用谁知道。&lt;/li&gt;
&lt;li&gt;Launchy 效率神器，快速启动程序。作者长时间未更新，最近换成了另外一个神器：Wox 。没用过的赶紧试试，有惊喜。&lt;/li&gt;
&lt;li&gt;Clipx / Ditto 多重剪贴板。&lt;/li&gt;
&lt;li&gt;cmder 终端模拟器，好用到爆，从此告别系统自带的命令行窗口。&lt;/li&gt;
&lt;li&gt;Visual Studio 的 Visual Assist 插件，一个字就是爽。&lt;/li&gt;
&lt;li&gt;Visual Studio 的 ViEmu 插件，没有 Vim 模式的 IDE 已经没法用了。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;《必然》一书的『过滤』一章中提到，如果你只接触那些你已经喜欢的东西是有风险的，即你可能会卷入一个以自我为中心的漩涡，从而对任何与你的标准存在细微差异的事情都视而不见，即使你原本会喜欢它。这种现象被称为『过滤器泡沫』。&lt;/p&gt;

&lt;p&gt;所以，我们要勇于尝试新事物。当时觉得 Ubuntu 好玩，在上面使劲折腾过，折腾了一段时间后，感觉还是不太适合作为个人的桌面系统。一直想尝试 Mac OS X，昂贵的价格又有点让人望而却步。从体验 Mac 的这几天来看，感觉付出是非常值的，从设计美感到使用体验都非常好，为什么我没有早一点入手呢？&lt;/p&gt;

&lt;p&gt;这两天都在研究 Mac 系统怎么玩，看了很多文章，装了一些软件，学习了很多东西。学习曲线大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;学习了神奇的触摸板的使用方法。（双指，三指，四指的手法。。。）&lt;/li&gt;
&lt;li&gt;学习了系统常用的快捷键。&lt;/li&gt;
&lt;li&gt;学习了在 Mac 上如何安装软件。（Mac App Store、官网下载 dmg、使用 Homebrew）&lt;/li&gt;
&lt;li&gt;给命令行终端配上漂亮的 Solarized 皮肤，安装配置 Shell 神器：oh-my-zsh&lt;/li&gt;
&lt;li&gt;安装包管理神器 Homebrew 和 brew cask。&lt;/li&gt;
&lt;li&gt;安装效率神器：Alfred2。&lt;/li&gt;
&lt;li&gt;使用 Homebrew 把系统自带的软件包升级到最新版本，比如：git、python、vim 等等。&lt;/li&gt;
&lt;li&gt;安装和配置 Mac 下的 macvim。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;嗯，完成了以上步骤后，基本上可以开始干活了。对了，再接上 HHKB，调整开关设置，打开开关 2、3、4，启用 Mac 模式，简直完美！&lt;/p&gt;

&lt;p&gt;接着，我还安装了如下的软件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Chrome 浏览器。&lt;/li&gt;
&lt;li&gt;Dash 查看各种文档的神器。&lt;/li&gt;
&lt;li&gt;Mou 编辑 MarkDown 的神器。&lt;/li&gt;
&lt;li&gt;XCode 现在还用不着，先装上。&lt;/li&gt;
&lt;li&gt;Android Studio&lt;/li&gt;
&lt;li&gt;ShiftIt 用来调整窗口位置和大小的神器。&lt;/li&gt;
&lt;li&gt;WizNote 为知笔记&lt;/li&gt;
&lt;li&gt;QQ&lt;/li&gt;
&lt;li&gt;微信&lt;/li&gt;
&lt;li&gt;QQ 音乐&lt;/li&gt;
&lt;li&gt;有道词典&lt;/li&gt;
&lt;li&gt;迅雷&lt;/li&gt;
&lt;li&gt;VLC 视频播放器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alfred2 和 oh-my-zsh 是我用了的最令人惊叹好用的工具，谁还有好用的软件推荐给我啊~~~&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>博客皮肤单独建了个仓库</title>
            <link>http://blog.coderzh.com/2016/02/05/new-hugo-rapid-theme-repo/</link>
            <pubDate>Fri, 05 Feb 2016 23:55:45 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/05/new-hugo-rapid-theme-repo/</guid>
            <description>

&lt;p&gt;有同学提到希望将这个博客的皮肤单独建个仓库，方便使用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/issues/1&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog/issues/1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;的确，早就应该这么做了。趁着放春节假期了，把这个撸了一遍，单独的皮肤仓库叫：&lt;code&gt;hugo-rapid-theme&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;只是将它从原博客中抽离出来，还有很大优化的空间，需要的同学先用着吧。&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&#34;https://github.com/coderzh/hugo-rapid-theme&#34;&gt;https://github.com/coderzh/hugo-rapid-theme&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;说明文档:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;说明文档&lt;/h2&gt;

&lt;p&gt;以下是 hugo-rapid-theme 的 README 文档：&lt;/p&gt;

&lt;p&gt;Demo: &lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step1-install-hugo:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step1 Install Hugo&lt;/h3&gt;

&lt;p&gt;Set &lt;a href=&#34;http://www.gohugo.org/doc/overview/installing/&#34;&gt;Hugo Install&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step2-create-your-site:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step2 Create your site&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;hugo new site your-blog-name
cd your-blog-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step3-clone-the-theme-repo:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step3 Clone the theme repo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/coderzh/hugo-rapid-theme.git themes/hugo-rapid-theme

# replace config file
rm config.toml
cp themes/hugo-rapid-theme/config.yaml .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step4-start-your-site:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step4 Start your site&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# new content
hugo new about.md
# start server
hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step5-have-fun:1c7dc7e052e1f712e7a427da9af2576f&#34;&gt;Step5 Have Fun&lt;/h3&gt;

&lt;p&gt;Now you can open &lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modify the config.yaml and other things, and have fun!&lt;/p&gt;

&lt;p&gt;You can also make this repo as submodule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git submodule add https://github.com/coderzh/hugo-rapid-theme.git themes/hugo-rapid-theme
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>追求简单和纯粹，我去掉了博客的评论功能</title>
            <link>http://blog.coderzh.com/2016/02/01/close-comments/</link>
            <pubDate>Mon, 01 Feb 2016 23:35:19 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/02/01/close-comments/</guid>
            <description>&lt;p&gt;一直以来，我们都习惯了有评论功能的博客系统，甚至大多数的博客系统还拿评论数来计算分数，作为你的文章热度的一个指标。&lt;/p&gt;

&lt;p&gt;曾经我也一度以为评论功能很重要，有时还会去期待有人评论。然而从结果来看，几乎大部分的评论都毫无价值。最近还受到了垃圾评论的骚扰，既浪费了我的时间不停的去删除，也影响了阅读者的体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;真心想和你交流的人，会想尽一切方法找到你。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，不必担心收不到有用的用户反馈。而且，那么大一个微信二维码放在那里，只要扫一扫关注一下，就可以给我发消息，当然，找到我的邮箱地址也是很容易的事情。&lt;/p&gt;

&lt;p&gt;为了追求最佳的阅读体验，追求一个博客的简单和纯粹，我去掉了博客的评论系统。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>张小龙悟透《失控》做出了微信，我们看过了《必然》能做什么？</title>
            <link>http://blog.coderzh.com/2016/01/31/inevitable/</link>
            <pubDate>Sun, 31 Jan 2016 12:22:25 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/31/inevitable/</guid>
            <description>&lt;p&gt;凯文凯利在 20 多年前在《失控》一书中预言了人类的未来的科技、社会和经济，现今的万维网、博客、维基百科、无人驾驶、电子货币、去中心化等等，都在上个世纪 90 年代被 KK 成功预言，而他在写《失控》一书时，还没有万维网，因特网才刚刚进入实用阶段。&lt;/p&gt;

&lt;p&gt;微信之父张小龙很早前就读过了《失控》，在他最近被爆出来的饭否日记中，他这么写到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;再问有多少人看了失控，无人。我顿时将自己想象为KK而口若悬河了。&lt;/p&gt;

&lt;p&gt;2011-01-13 17:42 by gzallen&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;张小龙非常推崇《失控》中提到的 &lt;strong&gt;去中心化&lt;/strong&gt; 的思想，这点在微信公众号和朋友圈都有体现。比如并没有一个中心化的公众号列表入口，展示最新最热的公众号文章。每个公众号主只与关注者互相连接，用户与用户之间互相连接，好的内容可以在用户之间以几何倍数的传播。又比如前几天的朋友圈红包照片功能，瞬间引爆了朋友圈。&lt;/p&gt;

&lt;p&gt;《失控》这本书很厚，而且里面的内容需要花大量的时间去理解和琢磨。本文的标题纯粹是为了吸引眼球，因为并不能得出这样的结论：悟透了《失控》就一定能做出像微信这样牛逼的产品。更加现实的是，即使看过了《必然》，我们大多数人什么也做不出来。&lt;/p&gt;

&lt;p&gt;但是看这两本书，有助于你了解人类未来的科技趋势。正如罗振宇所说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个时代最悲哀的事情，就是——&lt;/p&gt;

&lt;p&gt;你努力，但你不在风口上，&lt;/p&gt;

&lt;p&gt;你聪明，但你不在潮流中。&lt;/p&gt;

&lt;p&gt;知道趋势，意味着已经胜利在望。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《失控》中预言的很多科技虽然现在已经发生，而在某些领域，比如人工生命、机器人技术、生态学、仿真学等领域，并没有出现新的重大思想。正如他在《必然》中的 &lt;strong&gt;形成(Becomming)&lt;/strong&gt; 中提到的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;未来的大部分运转人类生活的伟大产品，在 2016 年以前，都还没被发明出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们目睹了从 PC 时代到互联网时代，再到现在的移动互联网时代的转变过程。我们正处于形成的过程中，所以我们感觉不到变化。你今天后悔当初为什么没有和张小龙想到一块去。再过几年十几年，你同样也会感叹，我要是在当时就意识到有那么多可能性该多好啊！&lt;/p&gt;

&lt;p&gt;设想未来你的孙子问你，「爷爷，为什么你年轻的时候马桶还不会说话，裤子还需要手来脱，打字还需要键盘，甚至显示屏幕还要放一个笨重的显示器，你居然还在桌子上放两个？！你当时没想到需要做点什么吗？」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，不要再感叹强大的 BAT 已经垄断市场，未来更大的机会正在发生甚至还未被挖掘，把握最佳的时机，就是现在！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有时候我们察觉不到变化，有时候其实是因为并不认可这样的变化，当变化已经形成时却又追悔莫及。所以，我们需要抛弃成见，拥抱变化。&lt;strong&gt;看准方向，找对风口，努力去飞&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有句话叫：风口上的猪也会飞。其实我并不认可这句话。说现实一点，想让猪飞起来，那得是多大的风啊！真有这样一个好的风口，聪明的人早已经把猪赶到不知道哪里去了，还有猪什么事。真正厉害的不是猪，而是扇风的人。有一句话说的好，「为了这些猪，我没少扇多少风。」&lt;/p&gt;

&lt;p&gt;所以，我对于 &lt;strong&gt;形成&lt;/strong&gt; 的理解是，深刻理解形成的本质，抓住最好的时机，付出持续的努力，遇到反对时能够坚定，遇到挫折时能够总结，跌倒时想着爬起来怎样继续前进。有一天你也许功成名就，也许一事无成。但这有什么关系呢，放眼到整个人类社会，&lt;strong&gt;形成&lt;/strong&gt; 的趋势并不因你而左右，你会感激形成的过程中创造出来的种种机会。&lt;/p&gt;

&lt;p&gt;《必然》这本书一共有 12 个关键词，每个关键词都需要深入的思考。我也感觉到一篇苍白无力的读后感是无法总结这本有深度的书，所以一篇文章聊其中一个关键词已经足够。下次我们再来聊聊下个关键词「&lt;strong&gt;知化(Cognifying)&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;附录：&lt;/p&gt;

&lt;p&gt;《必然》十二个关键词：形成、知化、流动、屏读、使用、共享、过滤、重混、互动、追踪、提问、开始。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>我和 ThoughtWorks 的一点小故事</title>
            <link>http://blog.coderzh.com/2016/01/18/thoughtworks-story/</link>
            <pubDate>Mon, 18 Jan 2016 23:05:24 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/18/thoughtworks-story/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/TW.jpg-wt&#34; alt=&#34;TW&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2009 年的时候买了一本《卓有成效的程序员》，看的热血沸腾，当时还写了一篇读后感《&lt;a href=&#34;http://blog.coderzh.com/2009/07/18/1526082/&#34;&gt;程序员的共鸣 - 读《卓有成效的程序员》&lt;/a&gt;》，现在翻来看还觉得蛮有意思的。从此后，开始用 Launchy ， ClipX 等提高效率的工具，也开始接触代码编辑器神器 Emacs 和 Vim 。当时年少无知先学了 Emacs ，还全程用 Emacs 开发过一个小项目。后来实在是小指按 ctrl 键按到桑爽的不行了，才发现 Vim 是多么和谐的存在。&lt;/p&gt;

&lt;p&gt;这本书是由 &lt;a href=&#34;https://www.thoughtworks.com/&#34;&gt;ThoughtWorks&lt;/a&gt; 中国公司翻译的，再加上当时用的持续集成工具 CCNet 就是 ThoughtWorks 开发的，瞬间觉得这个公司好牛逼。 更加牛逼的是，世界顶级的 OO 专家，敏捷开发创始人之一的 &lt;a href=&#34;http://www.martinfowler.com&#34;&gt;Martin Fowler&lt;/a&gt; 大牛就在 ThoughtWorks 担任首席科学家。&lt;/p&gt;

&lt;p&gt;当时对持续集成，敏捷开发还挺感兴趣，在博客里写了点东西，还特意关注了几个 ThoughtWorks 员工的博客。没事还在博客里留了几次言，突然有一天博客园的短消息里来了这么一条消息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;标题：如果你真的对coding有如此的热情&lt;/p&gt;

&lt;p&gt;可曾想过来ThoughtWorks?&lt;/p&gt;

&lt;p&gt;我看到你在我Blog上的留言了。如果你对代码如此热情，如果你喜欢体会作为程序员更多的可能，可曾想过来ThoughtWorks? 有兴趣的话请与我联系。作为前3年在各种类型的软件公司混过，后4年一直很enjoy的公司，看到你的Blog, 也许，这里是适合你的地方。&lt;/p&gt;

&lt;p&gt;陈金洲&lt;/p&gt;

&lt;p&gt;PS. 为了能联系到你，专门注册了博客园的账号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时的我工作快 3 年，正处于年少轻狂，自信爆棚，感觉啥都能干就缺一个机会的时代。把《设计模式》来回翻了几遍后，就和 Michael Chen 联系面试了。直到很多年后，我才听说， ThoughtWorks 被人称为“最难面试的 IT 公司”。首先说结论，最后我并没有去 ThoughtWorks 。具体情况见下文。&lt;/p&gt;

&lt;p&gt;第一面是 HR 的&lt;strong&gt;英文电话面试&lt;/strong&gt;，我英语也就四级的水平，听和看还行，但平时口语完全没机会训练。我在家设想了 HR 大概会问的几个问题，简单写了写，列了几个关键字就去了。当然，我还是很紧张，平时我就不太擅长电话里和别人沟通，而且还是要用英文，而且还是面试。 HR 的每个问题我还是听的很清楚的，我也就硬撑着把该说的说了。现在记得 HR 问了类似这样的问题：你的同事都是怎么评价你的？你平时遇到过什么难题又是如何解决的。我当时心里想着，当然要说一些同事夸奖我的话了，技术牛逼，喜欢分享，乐于助人之类的。也没遇到什么特别的难题啊，怎么编呢，一时又乱了方寸。&lt;/p&gt;

&lt;p&gt;第一轮电话面试后，我感觉糟透了，感觉没戏了。等了几周也未见回复，感觉就这样被淘汰了，不甘心就发邮件问了 HR 是不是被 out 了 ，HR 回复说还并没有结果让我再等等，又让我感觉到了一丝的希望。&lt;/p&gt;

&lt;p&gt;不久后，收到了邮件进入下一轮面试：&lt;strong&gt;Home Work&lt;/strong&gt; 。给了几道题，让选其中一道，在家写代码，写好后发给他们。我觉得这个环节不错，不像现场面试需要在高度压力的情况下用笔在纸上写代码。Home Work 是你自己在家做的，是在很自然放松的情况下，可以 google ，可以参考任何别人代码的情况下写的你的代码，是最接近真实工作时的状况。&lt;/p&gt;

&lt;p&gt;一共有三个可选题目：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PROBLEM ONE:  TRAINS&lt;/li&gt;
&lt;li&gt;PROBLEM TWO: SALES TAXES&lt;/li&gt;
&lt;li&gt;PROBLEM THREE: MARS ROVERS&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;我选了题目意思是我最容易看懂的 MARS ROVERS （火星漫游者）。&lt;/strong&gt;大意是给定火星探测机器人的一个坐标位置，然后给它发送一系列的指令，比如左转、右转、前进，最后输出他的目标点的坐标和朝向。&lt;/p&gt;

&lt;p&gt;我当时是这么想的，这题的算法很简单， ThoughtWorks 考察的肯定不是我能不能实现需求这么简单，而是考察我面向对象设计的能力，以及抽象的能力，能否把代码写的足够优雅，同时又具备很好的未来扩展性。而测试驱动开发作为敏捷开发的一个重要理念，我的 Home Work 里至少是需要包含测试代码的。虽然他们并不知道我是先写的代码还是先写的测试，嗯，我还是尝试先写测试代码，至少它的文件创建日期比功能代码会早一些，哈哈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这题肯定要用一些设计模式，但是又要避免过度设计。&lt;/strong&gt;于是我把最有可能关联的几个模式套了进去：工厂模式，状态模式，好像还有命令模式。把类分的很清晰，每个函数也很短，命名也是反复琢磨，最后还配上了单元测试案例。最后，把感觉非常完美的一份代码提交了上去。&lt;/p&gt;

&lt;p&gt;然后又等了漫长的几周，通知进入下一轮面试：&lt;strong&gt;电话技术面试&lt;/strong&gt;。面试我的就是 Michael Chen 。前面主要聊我现在的工作，做了一些什么项目，用了一些什么技术，问的很细，聊的挺愉快。聊完项目后，Michael Chen 提示我进入纯粹的答题环节，问了我一些设计模式相关的问题。&lt;/p&gt;

&lt;p&gt;这次电话技术面试聊完后，我感觉有戏，感觉 ThoughtWorks 正在向我招手。这是我理想中的，非常舒服的面试。但是我当时真的准备好了吗？真的准备好了从珠海赶赴西安或者北京去上班吗？我当时觉得地点无所谓，其实是没有太想清楚的。&lt;/p&gt;

&lt;p&gt;又是漫长的等待，&lt;strong&gt;心里面想着下一轮应该是飞到西安去和 ThoughtWorks 的工程师一起 Pair 结对编程了&lt;/strong&gt;。但等了好几周依然没有消息，我也开始考虑真的要去西安工作吗？我能适应那种经常出差的工作的？我以后真的要走咨询师的路线吗？我想了很久，最后某天 HR 突然来了一个电话，说&lt;strong&gt;前面面试的都很不错，但是英语方面还想和我再确认一次，要加一轮电话英语面试&lt;/strong&gt;。听完后，我感觉很不好，辛苦面试了这么久，又让我苦苦等待了这么久，最后又回到了第一轮的英语面试。我当时有点情绪，所以在加试的电话面试里表现的比第一次还差。&lt;/p&gt;

&lt;p&gt;HR 最后和我说，可能是毕业工作后英语口语用太少了，再复习多练习练习是可以的。&lt;strong&gt;建议我再花一个月的时间复习和练习一下英语口语，然后再来面试&lt;/strong&gt;。我当时已经有情绪了，这个面试折腾了 1 个多月，有点心累了。所以，后面我给 HR 发邮件说我不来了。&lt;/p&gt;

&lt;p&gt;直到最近，我才发现在 ThoughtWorks 的面试者中，被要求回去学习一段时间再回来面试的人大有人在，而且很多人最后都成功入职了。也许当时的我处理的是有点草率了。但命运这种东西谁知道呢，&lt;strong&gt;当时的一个决定对未来有什么影响，谁也说不清。我们还是要感恩现在的自己，以及之前做过的所有正确的和不正确的决定，是它们成就了现在的你。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这篇聊 ThoughtWorks 是因为&lt;a href=&#34;http://blog.coderzh.com/2016/01/16/coding-style-share/&#34;&gt;上篇文章&lt;/a&gt;提到的，认识了 ThoughtWorks 的前员工 &lt;a href=&#34;http://seabornlee.cn&#34;&gt;Seaborn Lee&lt;/a&gt; （小波） ，又让我想到了之前的面试经历。于是就和 Seaborn Lee 八卦了一下当年面试我的 Michael Chen 到底是怎样的一个存在。&lt;/p&gt;

&lt;p&gt;小波说了五个字：“&lt;strong&gt;他也是传奇&lt;/strong&gt;”，然后是这样描述的 ：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一是技术牛&lt;/p&gt;

&lt;p&gt;二是立志做产品&lt;/p&gt;

&lt;p&gt;承诺三年不调薪&lt;/p&gt;

&lt;p&gt;做了几款产品&lt;/p&gt;

&lt;p&gt;金数据成了被收购&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;瞬间让我佩服的五体投地。我从很多 ThoughtWorks 员工那了解到，不管是离职的还是在职的，他们对 ThoughtWorks 公司都是满口的称赞，对公司的认可度非常非常的高，说明这真是一家不错的公司呢。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>谁也挡不住程序员在微信群里玩起了直播分享</title>
            <link>http://blog.coderzh.com/2016/01/16/coding-style-share/</link>
            <pubDate>Sat, 16 Jan 2016 17:19:20 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/16/coding-style-share/</guid>
            <description>&lt;p&gt;上次写了一篇《&lt;a href=&#34;http://blog.coderzh.com/2015/12/27/code-review/&#34;&gt;大家都应该做的 Code Review&lt;/a&gt;》，在公众号里有位朋友留言：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/comments.jpg&#34; alt=&#34;comment&#34; /&gt;&lt;/p&gt;

&lt;p&gt;开始的感觉是，哦，又一个在留言里推广自己网站的家伙。但在好奇心驱使下，我打开了这个 &lt;a href=&#34;http://codingstyle.cn&#34;&gt;Codingstyle.cn&lt;/a&gt; 的网站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/coding-style.jpg&#34; alt=&#34;coding-style&#34; /&gt;&lt;/p&gt;

&lt;p&gt;界面挺简洁大方的，但好像在哪里见过，哦，原来是 Fork 的 &lt;a href=&#34;https://ruby-china.org/&#34;&gt;Ruby China&lt;/a&gt;。浏览了一些帖子，发现这是一个刚做不久的程序员社区，讨论的主要是敏捷、重构、编程实践、程序人生之类的话题，这位朋友还算比较用心，运营一个程序员社区实属不易，于是我就找了之前的两篇文章贴了过去。&lt;/p&gt;

&lt;p&gt;很快，Seaborn Lee 加了我的微信，并且把我拉到了一个只有 10 几人的“匠艺社区种子用户”的微信群里。然后我发现，群里的其他人都是一些高产博主，Seaborn Lee 正在通过微信群的方式培养自己的种子用户。&lt;/p&gt;

&lt;p&gt;匠艺社区小组每周都组织一次微信分享， Seaborn Lee 问我是否愿意分享一些东西。我婉言拒绝了，对于在微信群里进行语音分享这种事情，我还没经历过，也没有经验，&lt;strong&gt;我更多的是好奇，他们是怎样进行微信群语音分享的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经历了两次匠艺社区分享，着实让我吃了一惊。首先，分享并不是在“匠艺社区种子用户”微信群进行的，而是在另一个单独的叫“软件匠艺小组分享”的微信群，到目前为止，这个群已经有 459 个用户，而且全部都是程序员！&lt;/p&gt;

&lt;p&gt;他们一共分享过三期：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://codingstyle.cn/topics/56&#34;&gt;微信群分享第一期 微服务 by 许晓斌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codingstyle.cn/topics/77&#34;&gt;微信群分享第二期 正交设计 by 刘光聪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codingstyle.cn/topics/81&#34;&gt;微信群分享第三期 TDD 的本质不是 TDD by 丁辉&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我是从第二期开始参加的，一开始我非常好奇，他们是怎样在那么多人的微信群里进行直播分享的。最后发现其实方法非常简单直接，就是：&lt;strong&gt;发语音，截图，打字&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/coding-style-share.jpg&#34; alt=&#34;coding-style-share&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分享定在每周三晚上 8:30 到 9:30 ，首先会自愿报名选出一个主持人，负责整场分享的进度把控。分享者的内容是一篇文章，会先在群里发出来，然后分享者开始发语音分享，过程中会穿插打字和截图。分享完后，进行话题讨论，最后贴出分享者的二维码，大家自愿打赏。&lt;/p&gt;

&lt;p&gt;分享群的人数增加很快，程序员们闻风而来，很快就逼近了 500 人上限。可以确定的是，群里都是一些爱学习的程序员，不然谁晚上吃饱了不回去抱老婆还在微信群里听你的语音分享。我还发现一个有趣的现象，群里每个人进群时都加了 Seaborn Lee 好友。这就是 Growth Hack 啊！&lt;/p&gt;

&lt;p&gt;前不久我参加了一个培训，老师让我们所有人把微信打开，查看一下自己有多少个好友。我打开一看，发现有 100 多个，其他同事多的有3，4百个。老师说，她的微信里有 1000 多个好友，并不是随便摇一摇加的好友，都是有一定相关性的好友。她给每个好友都加了标签，遇到问题时在朋友圈一发，立马就有相关的人跳出来帮忙。这就是人脉的力量。&lt;/p&gt;

&lt;p&gt;同样，我也很感叹 Seaborn Lee 的做法，在微信群里组织分享，吸引大量爱学习的程序员过来并加为好友，这些人简直就是程序员社区的精准目标用户啊！于是我对 Seaborn Lee 本人的经历产生了兴趣，原来他之前就职于 &lt;a href=&#34;https://www.thoughtworks.com/&#34;&gt;ThoughtWorks&lt;/a&gt; ，目前于创业公司「深圳湾」任 CTO 。在他的博客里的 &lt;a href=&#34;http://seabornlee.cn/isaid.md&#34;&gt;时间线&lt;/a&gt; 一栏更是了解到他从出生、上学到工作一路走来的坎坷经历。了解了这些后， Seaborn Lee 的形象更加鲜活起来了：好学、上进、有活力、爱分享、组织各种社区活动。&lt;/p&gt;

&lt;p&gt;虽然微信里不能很好的支持视频直播，但谁也挡不住爱分享的程序员在微信群里玩起了语音直播。如果你也有兴趣，加我的微信公众号：hacker-thinking ，并发送“爱学习，爱分享”，我将加你为好友并把你加到刚才提到的“软件匠艺小组分享”群，一起学习进步。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>被脱裤也不怕 - 反馈总结</title>
            <link>http://blog.coderzh.com/2016/01/13/password-security-additional/</link>
            <pubDate>Wed, 13 Jan 2016 19:06:42 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/13/password-security-additional/</guid>
            <description>

&lt;p&gt;在发出前两篇安全相关的文章（&lt;a href=&#34;http://blog.coderzh.com/2016/01/03/security-design/&#34;&gt;设计安全的账号系统的正确姿势&lt;/a&gt; ，&lt;a href=&#34;http://blog.coderzh.com/2016/01/10/a-password-security-design-example/&#34;&gt;即使被拖库，也可以保证密码不泄露&lt;/a&gt;）后，我陆续收到了不少的反馈。我的文章本意是引起大家对密码安全的重视，给大家设计账号安全系统时提供一些参考和思路。&lt;/p&gt;

&lt;p&gt;正如张小龙说的，“我所说的一切都是错的”。&lt;/p&gt;

&lt;p&gt;所以，我更希望大家从辩证的角度去看待前两篇文章，然后结合自身项目的情况去做相应的设计。同时，我收到不少有价值的反馈，我觉得有必要将这些反馈整理一下，给大家一些参考，也算是对前面文章的补充。&lt;/p&gt;

&lt;p&gt;上篇文章没有提到 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE&#34;&gt;HTTPS&lt;/a&gt;（SSL/TLS），是我疏漏了。作为一个安全的系统，在保证传输安全时强烈建议直接上 HTTPS（SSL/TLS）。文章中使用 &lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/cc488016%28v=vs.90%29.aspx&#34;&gt;ECDH&lt;/a&gt; 交换密钥传输的过程其实和 HTTPS（SSL/TLS）是类似的，只不过 HTTPS（SSL/TLS）实现的要完善太多。&lt;/p&gt;

&lt;p&gt;正如一位朋友反馈所说：“14年的时候 openssl 爆出过一个名为 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E&#34;&gt;Heartbleed&lt;/a&gt; 的漏洞，可见良好的算法不一定被良好的实现，所以从开发者的角度还是不要觉得存在绝对安全的算法比较好。” 所以可以认为我的方案是在 HTTPS（SSL/TLS）基础上再一层加固，当然，如果你认为这一层加固没必要也可以去掉。&lt;/p&gt;

&lt;p&gt;另一方面，目前大量网站还在使用 HTTP ，很多游戏设计时也并未使用 TLS ，所以，我上篇文章使用的方法还是有一定的意义的。&lt;/p&gt;

&lt;h3 id=&#34;反馈汇总:1114219843eb3806f45029c8d223a620&#34;&gt;反馈汇总&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;“应该从源头上禁止用户使用简单密码”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：非常同意！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“获取 salt 并不需要啥验证，那么还有必要分开存储么，脱裤者直接根据uid调一遍接口不就拿到了？相当于就是公开的吧？”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：确实是这样。salt 相当于公开的了，没有必要分开存储了。如果你有更好的方法，请告诉我。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“使用 HTTPS(SSL/TLS) 来保障传输的安全是不是就可以了？”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：理论上是足够了，而且推荐使用。 如果你的项目安全级别非常高，本着不信任绝对安全的角度可考虑再一层加固。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“salt 使用密码学安全的随机数生成就够了，不需要使用 uid 。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：同意，确实不是很必要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“服务器性能够强劲，bcrypt 放在服务端执行也没什么问题。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：通过调整 bcrypt 参数让服务端执行在可接受的时间范围内确实可以。但是把这种耗时的操作放到客户端去做不是更好吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“不知攻焉知防，还是使用现有的算法和协议比较好，不要自己发明。即使自己发明，也需要经过实践的检验不断迭代才行。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：首先，文中用到的都是现有的成熟算法，如 bcrypt，SHA-512， AES ，包括 &lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/cc488016%28v=vs.90%29.aspx&#34;&gt;ECDH&lt;/a&gt;，并没有重新发明什么。文章&lt;strong&gt;重点是对密码的两次加盐哈希以及密码的验证方式&lt;/strong&gt;。当然，方案需要在实践中不断迭代优化，我也是不能同意再多。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有一位朋友说的非常好，很多互联网公司对安全不重视，近年来密码安全事故频繁发生，导致密码泄露后被拿去撞库，用户利益受损。&lt;strong&gt;应该去推动一下密码安全的业界标准，避免企业犯错用户买单&lt;/strong&gt;。同时，&lt;strong&gt;互联网没有绝对的安全，强烈建议用户不要用同一个密码，密码定期改！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，我所说的也都是错的。欢迎继续交流。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>即使被拖库，也可以保证密码不泄露</title>
            <link>http://blog.coderzh.com/2016/01/10/a-password-security-design-example/</link>
            <pubDate>Sun, 10 Jan 2016 23:06:42 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/10/a-password-security-design-example/</guid>
            <description>

&lt;p&gt;在前一篇文章《&lt;a href=&#34;http://blog.coderzh.com/2016/01/03/security-design/&#34;&gt;设计安全的账号系统的正确姿势&lt;/a&gt;》中，主要提出了一些设计的方法和思路，并没有给出一个更加具体的，可以实施的安全加密方案。经过我仔细的思考并了解了目前一些方案后，我设计了一个自认为还比较安全的安全加密方案。本文主要就是讲述这个方案，非常欢迎和期待有读者一起来讨论。&lt;/p&gt;

&lt;p&gt;首先，我们明确一下安全加密方案的终极目标：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即使在数据被拖库，代码被泄露，请求被劫持的情况下，也能保障用户的密码不被泄露。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说具体一些，我们理想中的绝对安全的系统大概是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先保障数据很难被拖库。&lt;/li&gt;
&lt;li&gt;即使数据被拖库，攻击者也无法从中破解出用户的密码。&lt;/li&gt;
&lt;li&gt;即使数据被拖库，攻击者也无法伪造登录请求通过验证。&lt;/li&gt;
&lt;li&gt;即使数据被拖库，攻击者劫持了用户的请求数据，也无法破解出用户的密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如何保障数据不被拖库，这里就不展开讲了。首先我们来说说密码加密。现在应该很少系统会直接保存用户的密码了吧，至少也是会计算密码的 md5 后保存。md5 这种不可逆的加密方法理论上已经很安全了，但是随着彩虹表的出现，使得大量长度不够的密码可以直接从彩虹表里反推出来。&lt;/p&gt;

&lt;p&gt;所以，只对密码进行 md5 加密是肯定不够的。聪明的程序员想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符，再计算 md5 ，那反推出原始密码就变得非常困难了。加上的这段长字符，我们称为盐（Salt），通过这种方式加密的结果，我们称为 &lt;code&gt;加盐 Hash&lt;/code&gt; 。比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/salt.png&#34; alt=&#34;salt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上一篇我们讲过，常用的哈希函数中，SHA-256、SHA-512 会比 md5 更安全，更难破解，出于更高安全性的考虑，我的这个方案中，会使用 SHA-512 代替 md5 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/sha-512.png&#34; alt=&#34;salt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的加盐哈希运算，即使攻击者拿到了最终结果，也很难反推出原始的密码。不能反推，但可以正着推，假设攻击者将 salt 值也拿到了，那么他可以枚举遍历所有 6 位数的简单密码，加盐哈希，计算出一个结果对照表，从而破解出简单的密码。这就是通常所说的暴力破解。&lt;/p&gt;

&lt;p&gt;为了应对暴力破解，我使用了加盐的&lt;strong&gt;慢哈希&lt;/strong&gt;。慢哈希是指执行这个哈希函数非常慢，这样暴力破解需要枚举遍历所有可能结果时，就需要花上非常非常长的时间。比如：bcrypt 就是这样一个慢哈希函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bcrypt.png&#34; alt=&#34;bcrypt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过调整 &lt;code&gt;cost&lt;/code&gt; 参数，可以调整该函数慢到什么程度。假设让 bcrypt 计算一次需要 0.5 秒，遍历 6 位的简单密码，需要的时间为：((26 * 2 + 10)^6) / 2 秒，约 900 年。&lt;/p&gt;

&lt;p&gt;好了，有了上面的基础，来看看我的最终解决方案：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/password_security.jpg&#34; alt=&#34;password_secutity&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图里有很多细节，我分阶段来讲：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 协商密钥&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于非对称加密的密钥协商算法，可以在通信内容完全被公开的情况下，双方协商出一个只有双方才知道的密钥，然后使用该密钥进行对称加密传输数据。比如图中所用的 ECDH 密钥协商。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 请求 Salt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;双方协商出一个密钥 SharedKey 之后，就可以使用 SharedKey 作为 AES 对称加密的密钥进行通信，客户端传给服务端自己的公钥 A ，以及加密了的用户ID（uid）。服务端从数据库中查找到该 uid 对于的 Salt1 和 Salt2 ，然后再加密返回给客户端。&lt;/p&gt;

&lt;p&gt;注意，服务端保存的 Salt1 和 Salt2 最好和用户数据分开存储，存到其他服务器的数据库里，这样即使被 SQL 注入，想要获得 Salt1 和 Salt2 也会非常困难。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 验证密码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是最重要的一步了。客户端拿到 Salt1 和 Salt2 之后，可以计算出两个加盐哈希：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SaltHash1 = bcrypt(SHA512(password), uid + salt1, 10)
SaltHash2 = SHA512(SaltHash1 + uid + salt2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 SaltHash2 做为 AES 密钥，加密包括 uid，time，SaltHash1，RandKey 等内容传输给服务端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ticket = AES(SaltHash2, uid + time + SaltHash1 + RandKey)
AES(SharedKey, Ticket)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端使用 SharedKey 解密出 Ticket 之后，再从数据库中找到该 uid 对应的 SaltHash2 ，解密 Ticket ，得到 SaltHash1 ，使用 SaltHash1 重新计算 SaltHash2 看是否和数据库中的 SaltHash2 一致，从而验证密码是否正确。&lt;/p&gt;

&lt;p&gt;校验两个哈希值是否相等时，使用时间恒定的比较函数，防止试探性攻击。&lt;/p&gt;

&lt;p&gt;time 用于记录数据包发送的时间，用来防止录制回放攻击。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 加密传输&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;密码验证通过后，服务端生成一个随机的临时密钥 TempKey（使用安全的随机函数），并使用 RandKey 做为密钥，传输给客户端。之后双方的数据交互都通过 TempKey 作为 AES 密钥进行加密。&lt;/p&gt;

&lt;h4 id=&#34;假设被拖库了:348d28cc795f0a1857c92b26f086746c&#34;&gt;假设被拖库了&lt;/h4&gt;

&lt;p&gt;以上就是整个加密传输、存储的全过程。我们来假设几种攻击场景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;假设数据被拖库了，密码会泄露吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库中的 Salt1 ，Salt2 ， SaltHash2 暴露了，想从 SaltHash2 直接反解出原始密码几乎是不可能的事情。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;假设数据被拖库了，攻击者能不能伪造登录请求通过验证？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;攻击者在生成 Ticket 时，需要 SaltHash1 ，但由于并不知道密码，所以无法计算出 SaltHash1 ，又无法从 SaltHash2 反推 SaltHash1 ，所以无法伪造登录请求通过验证。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;假设数据被拖库了，攻击者使用中间人攻击，劫持了用户的请求，密码会被泄露吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;中间人拥有真实服务器所有的数据，仿冒了真实的 Server ，因此，他可以解密出 Ticket 中的 SaltHash1 ，&lt;strong&gt;但是 SaltHash1 是无法解密出原始密码的。所以，密码也不会被泄露。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是，中间人攻击可以获取到最后的 TempKey ，从而能监听后续的所有通信过程。这是很难解决的问题，因为在服务端所有东西都暴露的情况下，中间人假设可以劫持用户数据，仿冒真实 Server , 是很难和真实的 Server 区分开的。解决的方法也许只有防止被中间人攻击，保证 Server 的公钥在客户端不被篡改。&lt;/p&gt;

&lt;p&gt;假设攻击已经进展到了这样的程度，还有办法补救吗？有。由于攻击者只能监听用户的登录过程，并不知道真实的密码。所以，只需要在服务端对 Salt2 进行升级，即可生成新的 SaltHash2 ，从而让攻击者所有攻击失效。&lt;/p&gt;

&lt;p&gt;具体是这样的：用户正常的登录，服务端验证通过后，生成新的 Salt2 ，然后根据传过来的 SaltHash1 重新计算了 SaltHash2 存入数据库。下次用户再次登录时，获取到的是新的 Salt2 ，密码没有变，同样能登录，攻击者之前拖库的那份数据也失效了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;q-a:348d28cc795f0a1857c92b26f086746c&#34;&gt;Q &amp;amp; A&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用 bcrypt 慢哈希函数，服务端应对大量的用户登录请求，性能承受的了吗？&lt;/p&gt;

&lt;p&gt;该方案中，细心一点会注意到， bcrypt 只是在客户端进行运算的，服务端是直接拿到客户端运算好的结果（ SaltHash1 ）后 SHA-512 计算结果进行验证的。所以，把性能压力分摊到了各个客户端。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么要使用两个 Salt 值？&lt;/p&gt;

&lt;p&gt;使用两个 Salt 值，是为了防止拖库后，劫持了用户请求后将密码破解出来。只有拥有密码的用户，才能用第一个 Salt 值计算出 SaltHash1 ，并且不能反推回原始密码。第二个 Salt 值可以加大被拖库后直接解密出 SaltHash1 的难度。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么要动态请求 Salt1 和 Salt2 ？&lt;/p&gt;

&lt;p&gt;Salt 值直接写在客户端肯定不好，而且写死了要修改还得升级客户端。动态请求 Salt 值，还可以实现不升级客户端的情况下，对密码进行动态升级：服务端可定期更换 Salt2 ，重新计算 SaltHash2 ，让攻击者即使拖了一次数据也很快处于失效状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据库都已经全被拖走了，密码不泄露还有什么意义呢？&lt;/p&gt;

&lt;p&gt;其实是有意义的，正如刚刚提到的升级 Salt2 的补救方案，用户可以在完全不知情的情况下，不需要修改密码就升级了账号体系。同时，保护好用户的密码，不被攻击者拿去撞别家网站的库，也是一份责任。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;欢迎大家针对本文的方案进行讨论，如有不实或者考虑不周的地方，请尽情指出。或者有更好的建议或意见，欢迎交流！&lt;/p&gt;

&lt;h3 id=&#34;更新-反馈汇总:348d28cc795f0a1857c92b26f086746c&#34;&gt;更新：反馈汇总&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;“应该从源头上禁止用户使用简单密码”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：非常同意！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“获取 salt 并不需要啥验证，那么还有必要分开存储么，脱裤者直接根据uid调一遍接口不就拿到了？相当于就是公开的吧？”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：确实是这样。salt 相当于公开的了，没有必要分开存储了。如果你有更好的方法，请告诉我。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“使用 HTTPS(SSL/TLS) 来保障传输的安全是不是就可以了？”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：理论上是足够了，而且推荐使用。 如果你的项目安全级别非常高，本着不信任绝对安全的角度可考虑再一层加固。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“salt 使用密码学安全的随机数生成就够了，不需要使用 uid 。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：同意，确实不是很必要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“服务器性能够强劲，bcrypt 放在服务端执行也没什么问题。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：通过调整 bcrypt 参数让服务端执行在可接受的时间范围内确实可以。但是把这种耗时的操作放到客户端去做不是更好吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;“不知攻焉知防，还是使用现有的算法和协议比较好，不要自己发明。即使自己发明，也需要经过实践的检验不断迭代才行。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回复：首先，文中用到的都是现有的成熟算法，如 bcrypt，SHA-512， AES ，包括 &lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/cc488016%28v=vs.90%29.aspx&#34;&gt;ECDH&lt;/a&gt;，并没有重新发明什么。文章&lt;strong&gt;重点是对密码的两次加盐哈希以及密码的验证方式&lt;/strong&gt;。当然，方案需要在实践中不断迭代优化，我也是不能同意再多。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有一位朋友说的非常好，很多互联网公司对安全不重视，近年来密码安全事故频繁发生，导致密码泄露后被拿去撞库，用户利益受损。&lt;strong&gt;应该去推动一下密码安全的业界标准，避免企业犯错用户买单&lt;/strong&gt;。同时，&lt;strong&gt;互联网没有绝对的安全，强烈建议用户不要用同一个密码，密码定期改！&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>设计安全的账号系统的正确姿势</title>
            <link>http://blog.coderzh.com/2016/01/03/security-design/</link>
            <pubDate>Sun, 03 Jan 2016 18:23:28 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/03/security-design/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/security.jpg-wt&#34; alt=&#34;security&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;引子:c2254085ba550b8986e017a4f607e2b0&#34;&gt;引子&lt;/h3&gt;

&lt;p&gt;最近有个虚拟练习项目，涉及到系统安全保障的设计，于是对安全保障这块做了一些更深入的了解。发现了很多有趣的东西，开阔了眼界。中间查了一些资料，于是我打算重新整理，用更加循序渐进，大家都能懂的方式，说一说如何设计一个安全的系统。&lt;/p&gt;

&lt;h3 id=&#34;著名的安全事件:c2254085ba550b8986e017a4f607e2b0&#34;&gt;著名的安全事件&lt;/h3&gt;

&lt;p&gt;首先来看看最近几年比较著名的拖库撞库后密码泄露的事件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;2011年12月，国内最大的程序员社区 CSDN 遭拖库，600万个账户信息泄露。&lt;/li&gt;
&lt;li&gt;2014年3月，携程旅行网的系统存技术漏洞，漏洞可能导致用户的姓名、身份证号码、银行卡类别、银行卡卡号、银行卡CVV码以及银行卡6位Bin泄露。&lt;/li&gt;
&lt;li&gt;2014年5月，小米论坛涉及800万用户信息遭泄露，信息包括用户名、密码、注册IP、邮箱等。&lt;/li&gt;
&lt;li&gt;2014年12月，12306遭撞库攻击，13万用户信息泄露，包括用户账号、明文密码、身份证、邮箱等敏感信息。&lt;/li&gt;
&lt;li&gt;2015年10月，网易邮箱遭攻击，近5亿条用户信息被泄露，包括用户名、密码、密码保护信息、登陆IP以及用户生日等多个原始信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了密码泄露事件，数据被物理删除的事件也是发生：&lt;/p&gt;

&lt;p&gt;2015年5月，携程网及APP陷入瘫痪，数据库遭物理删除疑似离职员工报复。&lt;/p&gt;

&lt;p&gt;这么多大公司大网站的系统都遭到攻击，泄露用户信息，更别说其他小网站了。这些攻击都可以从技术上来进行防范的，但是我们看到即使是大公司，安全方面也是那么的薄弱。&lt;/p&gt;

&lt;h3 id=&#34;防范方法:c2254085ba550b8986e017a4f607e2b0&#34;&gt;防范方法&lt;/h3&gt;

&lt;p&gt;防范的方法简单来说数据从用户键盘敲出的那一刻，到服务器后台存储都要保持正确的姿势。比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用正确的姿势保存密码。&lt;/li&gt;
&lt;li&gt;用正确的姿势传输数据。&lt;/li&gt;
&lt;li&gt;用正确的姿势加密敏感信息。&lt;/li&gt;
&lt;li&gt;用正确的姿势对数据进行备份和监控。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;用正确的姿势保存密码:c2254085ba550b8986e017a4f607e2b0&#34;&gt;用正确的姿势保存密码&lt;/h3&gt;

&lt;p&gt;这一步非常重要，也比较复杂。用户在浏览器里输入密码，传输到服务器端进行验证，服务端将之前保存的密码信息和用户的输入进行比对。&lt;/p&gt;

&lt;h4 id=&#34;1-低级错误-明文保存密码:c2254085ba550b8986e017a4f607e2b0&#34;&gt;1. 低级错误：明文保存密码&lt;/h4&gt;

&lt;p&gt;安全性最低的是在服务端明文保存用户的密码，一旦服务器被入侵，数据被拖走（拖库），所有用户的密码都直接的暴露在外面。这是最初级的做法，毫无安全性可言。假如你在一个网站或论坛注册了一个账号，该网站自动发了一封邮件告诉你注册成功，里面明文写了你的密码，赶紧把密码改了然后再也不要访问这个网站。&lt;/p&gt;

&lt;h4 id=&#34;2-低级错误-可逆加密密码:c2254085ba550b8986e017a4f607e2b0&#34;&gt;2. 低级错误：可逆加密密码&lt;/h4&gt;

&lt;p&gt;既然不能明文保存密码，那当然是加密保存了。耍个小聪明，比如把密码的字母倒着存，或者每个字母存后一个字母，或者进行异或混淆处理，表面上密码看上去已经看不出来原始的密码是什么了，但实际上这个和明文保存密码并没有本质区别，因为黑客既然可以入侵你的服务器，自然可以拿到你的加密代码，只要按你的算法进行简单的解密就可以得到原始密码。&lt;/p&gt;

&lt;h4 id=&#34;3-错误方法-md5-加密密码:c2254085ba550b8986e017a4f607e2b0&#34;&gt;3. 错误方法：md5 加密密码&lt;/h4&gt;

&lt;p&gt;在我还是一个初学者的时候，我已被告知不能用前两种方式保存密码，当时的主流方法是使用 md5 加密密码。（年代久远，现在已绝非主流了。） md5 是一种不可逆的加密方法，即密码被 md5 加密后是无法解密出原始密码的，验证密码是否正确的方法是将用户输入的密码 md5 加密后于数据库里保存的 md5 机密后的结果进行比对。这样，服务器端在不知道真实用户密码的情况下也能对用户密码进行验证了。&lt;/p&gt;

&lt;p&gt;这是早期比较主流的做法，然而，这依然是非常不安全的。因为只要枚举所有短密码进行 md5 加密，做成一个索引表，就能轻易的逆推出原始密码。这种预先计算好的用于逆推加密散列函数的表就是“彩虹表”。随着“彩虹表”不断变大，md5 的加密已经变得非常的不安全。2015年10月网易邮箱的用户密码泄露也被怀疑只对密码进行了 md5 加密。&lt;/p&gt;

&lt;h4 id=&#34;4-正确方法-加盐-hash-保存密码:c2254085ba550b8986e017a4f607e2b0&#34;&gt;4. 正确方法：加盐 hash 保存密码&lt;/h4&gt;

&lt;p&gt;加盐 hash 是指在加密密码时，不只是对密码进行 hash ，而是对密码进行调油加醋，放点盐（salt）再加密，一方面，由于你放的这点盐，让密码本身更长强度更高，彩虹表逆推的难度更大，也因你放的这点盐，让黑客进行撞库时运算量更大，破解的难度更高。&lt;/p&gt;

&lt;p&gt;如何进行加盐就是一门很重要的学问了。md5 是一种 hash 算法，以下就拿 md5 来举例。假如密码是 123456 ，md5 的结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/md5.png&#34; alt=&#34;md5&#34; /&gt;&lt;/p&gt;

&lt;p&gt;像 123456 这样的简单密码，是很容易被逆推出来的。但是假如我们往简单密码里加点盐试试：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/md5-salt.png&#34; alt=&#34;md5-salt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面例子里的 &lt;code&gt;#g5Fv;0Dvk&lt;/code&gt; 就是我们加的盐。加完之后，密码的强度更高了，彩虹表破解的难度加大了。或者进行加盐两次 md5 ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/double-md5-salt.png&#34; alt=&#34;double-md5-salt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到这里，你一定会有疑问，是不是把 md5 多做几次，或者自定义一些组合的方式就更安全了。其实不是的，黑客既然能拿到数据库里的数据，也很有可能拿到你的代码。&lt;/p&gt;

&lt;p&gt;一个健壮的、牢不可破的系统应该是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即使被拿走了数据和所有的代码，也没办法破解里面的数据。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这也是为什么大家不必实现自己的加密算法，而是使用公开的加密算法的原因，比如：RSA、AES、DES 等等。既然无法保证加密代码不被泄露，那就使用公开的加密算法，只要保护好私钥信息，就算你知道我的加密方式也没有任何帮助。&lt;/p&gt;

&lt;p&gt;大部分情况下，使用 md5(md5(password) + salt) 方式加密基本上已经可以了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/salt.png&#34; alt=&#34;salt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中，最关键的是 salt 从哪里来？ salt 该怎么设置才能安全。有几个重要的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不要使用固定不变的 salt。&lt;/li&gt;
&lt;li&gt;每个用户的 salt 都需要不同。&lt;/li&gt;
&lt;li&gt;salt 要保持一定的长度。&lt;/li&gt;
&lt;li&gt;salt 必须由服务端使用安全的随机函数生成。&lt;/li&gt;
&lt;li&gt;客户端运算需要的 salt 需要从服务端动态获取。&lt;/li&gt;
&lt;li&gt;客户端加盐 hash 的结果并不是最终服务端存盘的结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于客户端也需要执行加盐 hash ，所以，salt 不能直接写在客户端，而是应该动态从服务端获得。服务端生成随机的 salt 时，必须使用安全的随机函数，防止随机数被预测。&lt;/p&gt;

&lt;p&gt;各语言安全的随机函数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Platform&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;CSPRNG&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;PHP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;mcrypt_create_iv, openssl_random_pseudo_bytes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Java&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;java.security.SecureRandom&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dot NET (C#, VB)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;System.Security.Cryptography.RNGCryptoServiceProvider&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ruby&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SecureRandom&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Python&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;os.urandom&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Perl&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Math::Random::Secure&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;C/C++&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;(Windows API)   CryptGenRandom&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Any language on GNU/Linux or Unix&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Read from /dev/random or /dev/urandom&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;就算 salt 值动态从服务端获取，也有可能被中间人拦截获取。同时，客户端的加盐 hash 的过程相当于是完全暴露的。一种更安全的做法是，客户端使用 javascript 进行加盐 hash，把结果传到服务器后，服务器对结果再进行一次 &lt;code&gt;加盐 hash&lt;/code&gt; 或者 &lt;code&gt;加密 hash&lt;/code&gt;（比如：&lt;a href=&#34;https://tools.ietf.org/html/rfc2104&#34;&gt;HMAC&lt;/a&gt;） ，然后再和数据库的结果进行比对。&lt;/p&gt;

&lt;p&gt;如果需要达到更高的安全等级，可以考虑：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 使用更安全的 hash 函数用来抵抗碰撞攻击，比如：SHA256, SHA512, RipeMD, WHIRLPOOL。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;两个不同的内容 hash 的结果可能相同，攻击者在不知道真实密码的情况下，使用其他密码进行碰撞攻击从而登录系统。使用更安全的 hash 函数可以减少这种情况的发生。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 可以使用一种大量消耗 cpu 的 hash 算法对抗暴力破解，比如PBKDF2 或者 bcrypt。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;暴力破解就是枚举所有可能的密码进行尝试验证，使用大量消耗 cpu 的 hash 算法可以极大增加暴力破解的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 比较加盐 md5 结果时，使用时间恒定的比较函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在比较两个字符串时，通常都一个字符一个字符进行比较，如果某个字符不匹配就会立即返回。攻击者可以根据验证的时间长短来判断前几位字符是否正确，然后逐步修正最终得到正确的结果。&lt;/p&gt;

&lt;p&gt;因此，在比较 hash 时，使用时间恒定的比较函数，可以让攻击者摸不着头脑。比如下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static boolean slowEquals(byte[] a, byte[] b)
{
    int diff = a.length ^ b.length;
    for(int i = 0; i &amp;lt; a.length &amp;amp;&amp;amp; i &amp;lt; b.length; i++)
        diff |= a[i] ^ b[i];
    return diff == 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;异或（^）操作可以用来判断两个字符是否相等，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 XOR 0 = 0    1 XOR 1 = 0
0 XOR 1 = 1    1 XOR 0 = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的函数枚举每个字符进行异或判断，然后将所有的结果取或运算，得到最终的结果，比较的时间是恒定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. salt 的值不要和最终 hash 的结果存在同一个数据库。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SQL 注入是常见的攻击手段，被注入后数据库里的数据被暴露无遗。所以，应该将 salt 分开存储，存到别的机器的数据库里，让攻击者拿不到 salt ，从而无法轻易破解信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 最终存储的结果使用基于 key 的 hash 函数，比如 &lt;a href=&#34;https://tools.ietf.org/html/rfc2104&#34;&gt;HMAC&lt;/a&gt;。 key 从外部安全性极高的专属服务中获得。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了这层加固，即使数据被拖库，攻击者也无法从 hash 的结果逆推回原始密码。因为使用了加密的 hash 函数。基于 key 的 hash 函数只是进行哈希运算时，除了传入原始内容外，还需要传入一个密钥（key）。攻击者没有 key 几乎不可能对数据进行解密。&lt;/p&gt;

&lt;p&gt;key 可以保存在极高安全性的通用的 key 管理系统，使用加密协议传输，对访问者进行验证，只允许特定的机器有权限访问。&lt;/p&gt;

&lt;h3 id=&#34;用正确的姿势传输数据:c2254085ba550b8986e017a4f607e2b0&#34;&gt;用正确的姿势传输数据&lt;/h3&gt;

&lt;p&gt;使用 HTTP 协议传输数据时，数据都是明文传输的，数据从发出到服务器接收，中间可能被劫持，篡改。比如常见的 DNS 劫持，HTTP 劫持，中间人攻击。&lt;/p&gt;

&lt;p&gt;用正确的姿势传输数据，目的就是为了保证传输的数据安全，简单归纳为两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;需要确保进行通讯的服务端是官方的、正确的服务端，而不是跟一个假的服务端在通信。&lt;/li&gt;
&lt;li&gt;确保信息在网络上传输时是加密的，只有客户端和服务端有能力对数据进行解密。&lt;/li&gt;
&lt;li&gt;确保信息在传输时不被篡改，或者数据被篡改时能立即发现。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-验证服务端的合法性:c2254085ba550b8986e017a4f607e2b0&#34;&gt;1. 验证服务端的合法性&lt;/h4&gt;

&lt;p&gt;《改变未来的九大算法》一书中提到了公钥加密和数字签名技术，这是进行安全通信的基础技术保障。这里涉及到了加密技术，先了解两个最基础的概念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：加密和解密时使用的是同一个密钥。&lt;/li&gt;
&lt;li&gt;非对称加密：需要两个密钥来进行加密和解密：公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥） ，公钥加密的信息只有私钥才能解开，私钥加密的信息只有公钥才能解开。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;非对称加密是实现验证服务端合法性的基础，常见的加密算法有 &lt;a href=&#34;http://baike.baidu.com/view/10613.htm&#34;&gt;RSA&lt;/a&gt; 、 &lt;a href=&#34;http://baike.baidu.com/view/584834.htm&#34;&gt;ECC&lt;/a&gt; 等 。服务端生成一对公钥和私钥，公钥是公开的所有人都知道，客户端需要和服务端通信时，使用该公钥进行数据加密，由于只有真实合法的服务端才拥有对应的私钥，所有只有真实的服务端才能解密该信息，然后返回数据给客户端时，使用客户端自己生成的公钥进行加密，这样数据只有对应的客户端才能理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/rsa.gif&#34; alt=&#34;rsa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用 HTTPS 时，数字证书里包含了名称和公钥信息，只要认证该证书是合法的，并且对方能理解用该公钥加密的信息，就能确定是合法的服务端。&lt;/p&gt;

&lt;h4 id=&#34;2-确保通信的安全:c2254085ba550b8986e017a4f607e2b0&#34;&gt;2. 确保通信的安全&lt;/h4&gt;

&lt;p&gt;既然使用非对称加密的方式，可以保证双方安全的通信，那是不是就一直使用非对称加密传输数据就行了？理论上是可以的，但是非对称加密的效率要比对称加密的效率低很多。通常的做法是，通过非对称加密的方法，协商出一个只有双方知道的对称加密密钥。&lt;/p&gt;

&lt;p&gt;即使在不安全的通信环境下，也可以协商出一个只有双方才知道的对称加密密钥。在《改变未来的九大算法》一书里，有一个经典的描述如何交互密钥的例子（在所有沟通都是透明的情况下，如何协商出一个只有你和阿诺德才知道的颜料颜色。）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/sharedkey.jpg&#34; alt=&#34;sharedkey&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/cc488016%28v=vs.90%29.aspx&#34;&gt;ECDH&lt;/a&gt; 就是基于上面原理设计的密钥交换算法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/ecdh.png&#34; alt=&#34;ecdh&#34; /&gt;&lt;/p&gt;

&lt;p&gt;密钥协商好后，双方就可以使用该密钥进行加密传输了，比如使用 AES 、 DES。&lt;/p&gt;

&lt;p&gt;由于 ECDH 密钥交换协议不验证公钥发送者的身份，因此无法阻止中间人攻击。如果监听者 Mallory 截获了 Alice 的公钥，就可以替换为他自己的公钥，并将其发送给 Bob。Mallory 还可以截获 Bob 的公钥，替换为他自己的公钥，并将其发送给 Alice。这样，Mallory 就可以轻松地对 Alice 与 Bob 之间发送的任何消息进行解密。他可以更改消息，用他自己的密钥对消息重新加密，然后将消息发送给接收者。&lt;/p&gt;

&lt;p&gt;解决方法是，Alice 和 Bob 可以在交换公钥之前使用数字签名对公钥进行签名。&lt;/p&gt;

&lt;p&gt;即使攻击者不能解密传输的内容，但仍可以使用重放攻击尝试身份验证或用于欺骗系统。重放攻击是指攻击者将数据包截取后，向目标主机重新发送一遍数据包。&lt;/p&gt;

&lt;p&gt;防御重放攻击的方法主要有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用时间戳。数据包在一定时间范围内才是有效的。&lt;/li&gt;
&lt;li&gt;使用递增的序号。收到重复的数据包时可以轻易的发现。&lt;/li&gt;
&lt;li&gt;使用提问应答方式。收到数据包时可以判断出来是否应答过。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTTPS 正是使用了上述的原理，保证了通信的安全。所以，任何对安全有需求的系统都应该使用 HTTPS。如果是使用自有协议开发，比如 APP 或游戏，应该使用上述的方法保障通信的安全。&lt;/p&gt;

&lt;h3 id=&#34;用正确的姿势加密敏感信息:c2254085ba550b8986e017a4f607e2b0&#34;&gt;用正确的姿势加密敏感信息&lt;/h3&gt;

&lt;p&gt;我们都知道，用户的密码不能明文保存，而且要使用不可逆的加密算法，只保存最终的 hash 结果用来验证是否正确。那用户其他的敏感信息呢？比如身份证、银行卡、信用卡等信息，该如何加密保存而不被泄露呢？&lt;/p&gt;

&lt;p&gt;对于身份证信息，可以像密码一样只保存 hash 的结果，可以用于用户输入身份证号后进行验证。假如需要给用户显示身份证信息，只需要保存抹掉了几位数字的身份证号。&lt;/p&gt;

&lt;p&gt;假如你的系统涉及到支付，需要用户的银行卡，信用卡（卡号，CVV码）等信息时，必须遵循 &lt;a href=&#34;http://baike.baidu.com/view/8417913.htm&#34;&gt;PCI DSS&lt;/a&gt; （第三方支付行业数据安全标准）标准。PCI DSS 是由 PCI 安全标准委员会的创始成员(visa、mastercard、American Express、Discover Financial Services、JCB等)制定，力在使国际上采用一致的数据安全措施，包括安全管理、策略、过程、网络体系结构、软件设计的要求的列表等，全面保障交易安全。&lt;/p&gt;

&lt;p&gt;如果只是银行卡，还需要遵循 &lt;a href=&#34;http://baike.baidu.com/subview/1812080/12861982.htm&#34;&gt;ADSS&lt;/a&gt; （银联卡收单机构账户信息安全管理标准） 标准。&lt;/p&gt;

&lt;p&gt;2014年3月携程泄露用户银行卡信息就是因为没有遵循 &lt;a href=&#34;http://baike.baidu.com/view/8417913.htm&#34;&gt;PCI DSS&lt;/a&gt; 标准。&lt;/p&gt;

&lt;h3 id=&#34;用正确的姿势对数据进行备份和监控:c2254085ba550b8986e017a4f607e2b0&#34;&gt;用正确的姿势对数据进行备份和监控&lt;/h3&gt;

&lt;p&gt;2015年5月的携程数据被删事件，就是数据备份没有做好的例子。数据备份是为了防止由于硬盘损坏或人为破坏导致的数据丢失。主要措施有：磁盘 raid，物理备份（磁带库），异地的逻辑备份。同时做好权限控制，并对访问记录做好监控，及时发现问题，保留现场证据。&lt;/p&gt;

&lt;h2 id=&#34;总结:c2254085ba550b8986e017a4f607e2b0&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文总结了设计一个安全系统的基本原理和方法，并没有举出一个特定具体的方案，因为不同的系统对安全性的要求各有不同，设计者应该根据自身系统的特点进行具体设计。比如加盐 hash 的具体实施方法，salt 值如何构成等等。&lt;/p&gt;

&lt;p&gt;本文所述内容如有不实之处或者有争议的部分，欢迎交流指出。&lt;/p&gt;

&lt;h4 id=&#34;附录:c2254085ba550b8986e017a4f607e2b0&#34;&gt;附录&lt;/h4&gt;

&lt;p&gt;常用的加密算法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对称加密：&lt;a href=&#34;http://baike.baidu.com/view/7510.htm&#34;&gt;DES&lt;/a&gt;、&lt;a href=&#34;http://baike.baidu.com/view/350958.htm&#34;&gt;3DES&lt;/a&gt;、TDEA、&lt;a href=&#34;http://baike.baidu.com/view/2208941.htm&#34;&gt;Blowfish&lt;/a&gt;、RC2、RC4、&lt;a href=&#34;http://baike.baidu.com/view/734720.htm&#34;&gt;RC5&lt;/a&gt;、&lt;a href=&#34;http://baike.baidu.com/view/92629.htm&#34;&gt;IDEA&lt;/a&gt;、SKIPJACK、&lt;a href=&#34;http://baike.baidu.com/subview/133041/5358738.htm&#34;&gt;AES&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;非对称加密：&lt;a href=&#34;http://baike.baidu.com/view/7520.htm&#34;&gt;RSA&lt;/a&gt;、&lt;a href=&#34;http://baike.baidu.com/view/46554.htm&#34;&gt;ECC&lt;/a&gt;（椭圆曲线加密算法）、&lt;a href=&#34;http://baike.baidu.com/view/551692.htm&#34;&gt;Diffie-Hellman&lt;/a&gt;、&lt;a href=&#34;http://baike.baidu.com/view/2154827.htm&#34;&gt;El Gamal&lt;/a&gt;、DSA（数字签名用）&lt;/li&gt;
&lt;li&gt;Hash 算法：MD2、MD4、MD5、HAVAL、SHA-1、SHA256、SHA512、RipeMD、WHIRLPOOL、SHA3、&lt;a href=&#34;https://tools.ietf.org/html/rfc2104&#34;&gt;HMAC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DES、3DES、AES 区别：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DES：1976年由美国联邦政府的国家标准局颁布，密钥为 56 位。&lt;/li&gt;
&lt;li&gt;3DES：DES加密算法的一种模式，它使用3条56位的密钥对数据进行三次加密。&lt;/li&gt;
&lt;li&gt;AES：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，用来替代原先的DES。密钥长度可以是128，192或256比特。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;参考文章:c2254085ba550b8986e017a4f607e2b0&#34;&gt;参考文章&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://crackstation.net/hashing-security.htm&#34;&gt;Salted Password Hashing - Doing it Right&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://msdn.microsoft.com/zh-cn/library/cc488016%28v=vs.90%29.aspx&#34;&gt;ECDH 算法概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Rainbow_table&#34;&gt;Rainbow table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《改变未来的九大算法》第四章：公钥加密&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>我的 2015</title>
            <link>http://blog.coderzh.com/2016/01/01/my-2015/</link>
            <pubDate>Fri, 01 Jan 2016 00:34:08 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2016/01/01/my-2015/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/2016.jpg-wt&#34; alt=&#34;2016&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2015年对我来说是意义非凡的一年，这一年里，我主要干了以下几件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;离开游戏创业公司加入了微信。&lt;/li&gt;
&lt;li&gt;重新开始写博客，开始写公众号：一个程序员的思考。&lt;/li&gt;
&lt;li&gt;我可爱的儿子出生了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以说，2015年我收获颇多，最大的收获是我的小宝宝的到来，欣喜和激动之情难以言表。对于这个新加入的小成员，我们会好好的爱他，呵护他，陪伴他成长，宝宝加油，我们也一起加油哦。&lt;/p&gt;

&lt;p&gt;事业方面，我离开了工作4年的游戏创业公司，这里有太多千丝万缕的故事。2011年，我们从西山居出来时，也是满怀梦想，也曾激情奋斗，一起吃大叔做的菜，一起打闹玩笑，认真工作时为一个问题可以争的面红耳赤，一起玩游戏时可以在 LOL 里 High 到不能自已。&lt;/p&gt;

&lt;p&gt;我努力过，也可以说还不够努力，也许当时我可以做的更好，或许当时我可以更主动去承担起一些责任，或许，我什么也改变不了。创业维艰，只有经历过的人才能体会。当时看着一个又一个最早一起的小伙伴离开，难免伤感，不过他们离开后都有了不错的去处，也是很欣慰的。&lt;/p&gt;

&lt;p&gt;我坚持了4年，领略了游戏行业无情的市场竞争，经历了创业公司面临的种种问题和挑战。当然，我主要工作也只是写程序，很多事情是你无法左右的。所以在我30岁的时候，&lt;strong&gt;我想应该做些改变了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;于是我加入了微信。做为在职员工，不应该在外面过多评论自己的公司。在这里我就简单说一下自己的感受。腾讯是一家值得尊敬的公司，公司文化氛围很好，活跃而且开放，同事都很优秀，我学习到很多，并且非常庆幸能加入腾讯。&lt;/p&gt;

&lt;p&gt;换工作后，我也逐渐不怎么玩游戏了，把一直想戒也戒不掉的 LOL 给彻底戒掉了。我玩起游戏来很疯，很执着，喜欢专研，熬夜玩，睡觉也想。我大概经历过3次这样的过程。第一次是在大学时玩剑侠情缘一，没日没夜通宵达旦的玩，玩到早上通宵回来又饿又困，倒头睡到中午或下午，起来接着玩。第二次是工作后玩剑三，也沉迷过一段时间，第三次是创业时玩 LOL ，天天沉迷排位赛，看直播比赛，对英雄技能技巧、比赛选手如数家珍。&lt;/p&gt;

&lt;p&gt;从游戏里跳出来后，&lt;strong&gt;我发现其实我也没有那么喜欢游戏&lt;/strong&gt;。一旦我不玩游戏后，那些游戏我碰都不碰了，APP Store 里排名靠前的我也玩不到几天。之前创业时，经常需要加班，总觉得玩游戏的时间都不够，所以业余时间也被占的满满的。现在不玩游戏后，发现其实时间是可以有很多方式来利用的，可以做很多有意义的事情，当你做的越多时，越会觉得时间其实是那么的不够用，为什么还要浪费在一局又一局重复的游戏上面呢？&lt;/p&gt;

&lt;p&gt;所以，我在我的博客上写了这么一句话激励自己：&lt;strong&gt;如果你没有感觉到时间不够用时，你多半正在虚度光阴。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是我重新捡起了荒废了3~4年的博客。这几年博客没有更新和创业公司加班及玩游戏有关，也和大环境有关。这几年微博兴起，Google Reader 关闭，博客没落，很多知名的博客都停更了。当然，这都是借口。如今，人们重新意识到了有价值的原创长文的价值，自媒体开始兴起，博客的形式也重新燃起了火花。国外的 &lt;a href=&#34;https://medium.com/&#34;&gt;Medium&lt;/a&gt; ，国内的 &lt;a href=&#34;http://www.jianshu.com/&#34;&gt;简书&lt;/a&gt; ，知乎专栏，新浪微博长文，微信公众号文章等等风生水起。&lt;/p&gt;

&lt;p&gt;虽然我之前在博客园的写的 Google Test 相关的文章已经有几十万的阅读量，但我还是决定从博客园搬家出来，目前使用的是 &lt;a href=&#34;gohugo.io&#34;&gt;Hugo&lt;/a&gt; 搭建的静态博客网站 &lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt; ，同时大部分文章都会在我的微信公众号（一个程序员的思考）里发布。博客起到一个备份和被搜索引擎索引的作用。&lt;/p&gt;

&lt;p&gt;如果算上这篇文章，今年我一共写了48篇文章了，平均一周一篇的节奏。公众号的订阅数也在持续上涨，在这里我要感谢所有订阅了我公众号和一直关注我博客的朋友，祝大家2016年新年快乐！新年新气象，无论学业、事业还是家庭都能顺顺利利。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2016年，我们一起努力！&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>大家都应该做的 Code Review</title>
            <link>http://blog.coderzh.com/2015/12/27/code-review/</link>
            <pubDate>Sun, 27 Dec 2015 18:49:15 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/12/27/code-review/</guid>
            <description>&lt;p&gt;代码审查（Code Review）是个老生常谈的话题了，我以前呆过的大公司也好，创业公司也好，都知道 Code Review 的好处，但真正去有效执行的却很少。有人认为“存在即合理”，大家都不愿意做 Code Review ，可能 Code Review 真的不好，影响开发效率。有的人想做，但是执行起来太困难。&lt;/p&gt;

&lt;p&gt;造成大家放弃 Code Review 的原因有哪些呢？我仔细想了想，大概有这几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;时间紧&lt;/strong&gt;：项目赶着上线，一个人干两人的活，天天加班累成狗，哪有时间 Review ，怕影响项目进度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等不了&lt;/strong&gt;：工作被阻塞，发起评审后，啥也干不了了，我是该催一催那家伙评审一下呢，还是催一催那家伙评审一下呢，什么？他休假了！WTF！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效果差&lt;/strong&gt;：我写的那么有气质的代码你看出来了吗？看出来了吗？！什么？！单词拼写错误？代码逻辑为什么是这样？来来来，搬个小板凳过来，我给你解释一下午。（评审者不了解被评审人工作）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嫌麻烦&lt;/strong&gt;：代码不能直接 commit 或 push ，必须先走评审流程，还能不能愉快的提交代码了？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再加上，创业团队成功率本来就低，一种普遍的想法是：最重要是项目能活下去，代码写的挫一点没关系，可以以后再搞。代码写的再好，项目死了也是白搭。&lt;/p&gt;

&lt;p&gt;貌似好有道理啊，要不 Code Review 就不做了吧。不！&lt;strong&gt;我认为，不论大小什么团队，都应该做 Code Review 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的核心观点是，产品开发周期内，代码编写所占的时间比例其实是很小的，之后有大量的时间是花在代码调试，修复 Bug 和填之前的坑上。&lt;strong&gt;做 Code Review ，其实可以减少代码调试的时间，更快的定位和修复 Bug 和少挖一些坑。&lt;/strong&gt;在代码编写的阶段通过 Code Review 把控质量，从总的项目周期来看是划算的，甚至是事半功倍的。&lt;/p&gt;

&lt;p&gt;当然，上面提到的“时间紧、等不了、效果差、嫌麻烦”也是真实存在的。要做好 Code Review ，就必须去解决这些问题。核心是提高 Code Review 效率，我的建议也很简单，&lt;strong&gt;用好的工具，做充分的沟通。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先要避免 Code Review 工具提交过程过于复杂冗长，相关的工具有很多，不管是开源的还是商业的（比如：&lt;a href=&#34;http://phabricator.org/&#34;&gt;Phabricator&lt;/a&gt;、&lt;a href=&#34;https://www.gerritcodereview.com/&#34;&gt;Gerrit&lt;/a&gt;）。GitHub 的 Pull Request 其实是很好的 Code Review 工具。在 GitHub 上，你发现一个好项目想改进它，你只要点击 Fork ，增加你要的功能，然后通过 Pull Request 贡献你的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/pr.jpg&#34; alt=&#34;pr&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“废话少说，Send me a pull request!” 是不是感觉这句话叼叼的。&lt;/p&gt;

&lt;p&gt;GitHub 的 Pull Request Merge 相当于 Code Review 的过程，代码原作者 Review 代码，提出意见，最终合并只需要在 GitHub 点几个按钮就可以完成。据了解，已经有不少创业公司的代码直接托管在 GitHub，并采用 PR 的开发模式。&lt;/p&gt;

&lt;p&gt;其次是要做好充分的沟通。实现某个功能时，可以指派给两人，一人负责写代码，一人负责跟踪和讨论，然后交叉进行，有点类似结对编程。如果做到这个比较难，那就需要在代码编写过程中尽可能多的和别人讨论沟通，让评审者充分了解你的工作。可行的方法是老员工带新员工，老员工对新员工的工作比较了解，可以很好的给出评审意见。另一种是老员工之间互相评审，互相交流容易擦出火花。&lt;/p&gt;

&lt;p&gt;而且，做好 Code Review ，除了提高代码质量之外，还可以：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;把控代码的风格和规范，提高代码的可维护性。&lt;/li&gt;
&lt;li&gt;展示自己的工作内容，让同事对你的工作成果更加了解。&lt;/li&gt;
&lt;li&gt;从别人的代码里学习到很多编程技巧，解决问题的思路。&lt;/li&gt;
&lt;li&gt;通过别人的评审意见发现自己的不足，优化自己的代码，扩宽自己的思路。&lt;/li&gt;
&lt;li&gt;很好的给予新人指导，给出有建设性的意见，帮助新人成长，做好知识的传承。&lt;/li&gt;
&lt;li&gt;通过评审摩擦火花，互相欣赏，找到心灵相惜的好基友或终身伴侣。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/code-review.jpg&#34; alt=&#34;code-review&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Code Review ，你做了就知道！&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
