<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title> on CoderZh Blog</title>
        <link>http://blog.coderzh.com/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Sun, 22 Nov 2015 10:36:35 CST</updated>
        
        <item>
            <title>程序员的思考：分享即学习</title>
            <link>http://blog.coderzh.com/2015/11/22/hacker-thinking-study/</link>
            <pubDate>Sun, 22 Nov 2015 10:36:35 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/22/hacker-thinking-study/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/learning.jpg-wt&#34; alt=&#34;learning&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从今年2月底开通微信公众账号以来，到现在差不多9个月的时间，订阅的用户差不多有 500 人了。这个数字当然不能和那些大 V 的订阅数相比，甚至那些大 V 在文章结尾处给别人的账号做个推荐，一天的订阅数也许都会超过我的。但是，我对 500 个订阅数的结果是很满意的。&lt;/p&gt;

&lt;p&gt;记得最早开通公众号那会，我还在上家游戏公司。我离开公司前给程序组的同学做了一次关于游戏服务端开发的讲座。在演讲稿的最后一页，我贴出了我的公众号二维码。我说，我马上就要离开公司了，这是最后一次做分享了。不过，可以关注我的这个公众号，之后我的学习心得和最新动态都会在这个公众号里发出来。大家都在广州，也有的是交流的机会。&lt;/p&gt;

&lt;p&gt;所以，前公司的同事成了我的公众号最早的订阅者。&lt;strong&gt;即使订阅数很少，我也写的很认真，因为我明白，写公众号收获最大的不是读者，而是自己。&lt;/strong&gt;它锻炼了我写作的能力，让我静下心来思考，通过不断的学习、思考、总结、汇集成文字，最后常常有种豁然开朗的感觉，感觉对一个东西的理解又深入了一个层次。&lt;/p&gt;

&lt;p&gt;在我刚工作第一年的时候，我就养成了写博客的习惯。仔细想了想，也许是在更早的时候就开始写博客的。我记得大四（2006年左右）那会，&lt;a href=&#34;http://www.cnblogs.com&#34;&gt;博客园&lt;/a&gt; 可谓是如日中天，百花齐放。在博客园里我如饥似渴的学习着微软的技术，那时候园子里大神辈出，每每让我仰视。那时候加的 QQ 群：湖南微软开发者俱乐部，直到现在还在里面，虽然不发言，也没有被管理员踢掉，可见这是一份大家共同的记忆，谁都不想去破坏它。&lt;/p&gt;

&lt;p&gt;于是我学习大神在博客园里的开通了博客。在博客园开通博客是需要一番自我介绍的，当时还有些担心像我这种学生菜鸟，会不会不让我开通。于是在自我介绍里使劲把自己胡吹了一通，最后申请成功了总算松了一口气。&lt;strong&gt;不知道现在博客园的注册流程是否还是一样，我觉得那样挺好的，看似提高了注册门槛，最后能让用户有种注册不易，且行且珍惜的感觉。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;工作之后，有一天看到一个同事把自己的 QQ 名改成了 &lt;code&gt;coder&lt;/code&gt; 。这位同事姓刘，和我同一批校招进来，一起参加了金山的首批训练营。那时的他已经在训练营里声名显赫，在课堂上经常有惊人之举，常常有人议论。号称在学校的时候已经写了 10 W 行代码，样子看上去是一个典型的程序员。认识的同学大概已经知道是谁了。&lt;code&gt;coder&lt;/code&gt; &lt;strong&gt;是一个极其普通的词，但在当时的我看来，&lt;code&gt;coder&lt;/code&gt; 代表了专注，专心研究代码，写代码，不浮夸，不浮躁，不因外界的纷杂变化干扰心境。&lt;/strong&gt;于是我把博客园里的 ID 修改成了 &lt;code&gt;CoderZh&lt;/code&gt; ，我姓张，Zh 表示 Zhang 。&lt;/p&gt;

&lt;p&gt;印象中我删除了学校期间稍显稚嫩的文章，也算有个新的开始。从 2007 开始到现在，我在博客园里写了大约 200 多篇文章，收到的评论 2000 多。阅读数最高的文章《&lt;a href=&#34;http://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html&#34;&gt;玩转Google开源C++单元测试框架Google Test系列(gtest)&lt;/a&gt;》，总阅读数到现在约有 58 W。&lt;/p&gt;

&lt;p&gt;后来博客园逐渐没落了，即使发到首页阅读数也少的可怜，而博客流量的首要来源依然是搜索引擎。于是今年我完全放弃了博客园，搭建了自己的独立博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt; ，把之前的文章也导入了过来，同时也开通了微信公众号。&lt;/p&gt;

&lt;p&gt;说回微信公众号。我也希望能有更多人订阅，也算是对我的付出的一种肯定吧。于是，我在我的各个社交账号上贴了微信公众号的二维码，在之前博客园的博客签名里进行导流，给开发者头条投稿等等。订阅数有了一些起色，下面是从开通以来累积用户数的变化曲线：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/wp-tend.jpg-ws&#34; alt=&#34;wp-tend&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从 9 月份开始，曲线开始变抖了一些，开始越来越多人关注我的公众号了，我也在不断的思考我的公众号的定位到底是什么。看过我的独立博客的同学应该会发现，我的独立博客的文章分类只有三个：读书笔记、技术文章、思考感悟。技术类的文章不管前端后端，Python 还是 Go，通通归到了技术文章分类。而之前的我喜欢细分每个技术类别，到后来我发现人的精力是有限的，研究的技术方向也会很有限，通归到技术文章分类可以少一些分类的纠结，也能跳出技术的思维去看待世界。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，我的公众号的内容主要也会围绕这三个主题：读书笔记、技术文章、思考感悟。我更希望偏重于思考感悟方面，这也是这个公众号名称的由来：一个程序员的思考。&lt;/strong&gt;我的公众号介绍是这么写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;作为一个程序员，

思考程序的每一行代码，

思考生活的每一个细节，

思考人生的每一种可能。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在订阅数突破 500 之际，我想可以正式的来聊一聊作为一个程序员对一些东西的思考。首先申明，我并没有什么惊世骇俗的想法，也没有想要一语道破天机的妄想，我不会使用诸如“粗大事了！xxx”、“有人@你 xxx”之类的诱导标题，因为那样吸引而来的订阅者并不是我的目标读者。&lt;strong&gt;我想写的，只是一些朴实无华的想法，和一些自己的切身经历。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;回到本文的正题：分享即学习。你有没有注意到，&lt;strong&gt;程序员是一个最乐于分享的群体&lt;/strong&gt;    。很多程序员都喜欢写技术博客，学习了一些什么新技术，发现一个什么新技巧，都毫无保留的在博客里进行分享。&lt;/p&gt;

&lt;p&gt;比方说，你花了 1 个周的时间研究了 Facebook 最新的框架 React ，明白了里面大致是怎么回事，学习到了这个框架的用法，甚至领悟到了 React 设计的精髓，然后你又花了半天的时间把这些东西总结出来，发布到了你的博客里。&lt;/p&gt;

&lt;p&gt;这时另外一个人小 A 在网上浏览到了你的文章，他没有看过 React 的文档，也不太明白 React 到底为何物，但是隐约听过一些。而你的文章写的十分生动，把 React 总结的非常清晰易懂，又有条理，甚至看完后就可以开始和别人高谈阔论。&lt;/p&gt;

&lt;p&gt;然而，小 A 认真看完了你的文章就真正掌握了 React 吗？你把对 React 的所以理解都写出来了，小 A 即使全部记住了，他对 React 的理解会和你一样吗？答案是肯定的，不一样。&lt;strong&gt;没有经历苦难，怎知幸福的可贵。没有经过漫长的学习，怎能体会最后豁然开朗的瞬间。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而有的人会有这样的想法，我那么辛苦学习得来的东西，怎能给你分享，让你这么容易就学了去。他们抱着“好东西不会给别人分享”的想法，因为他们要靠那些所谓的别人不知道的秘密来获取更多的资源（比如：赚钱、一份工作、或者赚取声望）。这样的做法无可厚非，事实上很多人都是这么做的，也许这源于人的本性：自私。&lt;/p&gt;

&lt;p&gt;而为什么那么多成功的企业家乐于去分享呢？通过演讲、出书，把自己管理公司的理念、遇到困难时处理问题的想法和思路，公司的战略，毫无保留的分享给别人。（当然，有些企业家只是为了作秀和市场营销的目的，就另当别论了。）他们不怕竞争对手学了去吗？他们真的不怕。他们经常说的“小步快跑，快速试错”的互联网开发模式，你都要听烂了，但你真正理解了吗？知道具体该如何实施吗？遇到问题知道该如何处理吗？&lt;/p&gt;

&lt;p&gt;我相信有些企业家到最后成功的时候，也没有真正理解自己到底是如何成功的。通过总结，才让他们意识到原来成功是这么来的，通过分享，才让他们对成功的理解更加透彻，他们明白他们的成功是不可复制的，而这过程中他们的一些难能可贵的精神或坚持，才是其中最重要的因素。&lt;/p&gt;

&lt;p&gt;你在写 React 的文章时，每遇到一个含糊不清的问题时，你都必须把它彻底搞懂。为了让别人更容易理解，你还要假装自己对 React 一无所知，从一个更高的角度就看待 React ，理解别人的疑惑，调整自己的文字，让文章更加循序渐进，接近你当初学 React 时过程变化。这无疑是对自己学习内容的再一次洗礼，你说，写这篇文章，收获最大的不是你自己吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;学习从来没有什么捷径。古人云：学海无涯苦作舟。是很有道理的。&lt;/strong&gt;若不是你平时就花了很多时间学习了很多关于 React 的资料，当你看到别人写的关于 React 的学习总结的文章时并不会有多少感觉。前段时间公司有同事很深入的了研究了 TLS 协议（安全传输层协议），看了大量文献 Paper，深入理解了里面的大量技术细节，然后他在公司内部的平台上分享了一篇自己总结的 TLS 的文章。当我打开一看时，堪称史诗巨作，不仅仅在于篇幅的长度，更在于研究的深度。据了解，这位同事利用业余的时间，源于兴趣爱好，花了大量的时间去专研 TLS ，非常令人敬佩。&lt;/p&gt;

&lt;p&gt;然而，即使我认认真真的花了 1 个小时的时间把这位同事的文章看完，我就能达到他花了几个月研究的水准吗？答案肯定是不能的。我没有经历学习 TLS 的苦，所以无法领悟 TLS 的甘。即使最后这位同事被邀请做了一次现场的分享，把他的文章再次提炼总结，我去听了也只能留下他很牛逼的印象。而最后收获最大的肯定是他自己，通过写作和分享，不仅加深了自己对 TLS 的理解，还顺带赚取了声望。&lt;/p&gt;

&lt;p&gt;所以，沉下心，多花一些时间去看书，学习。&lt;strong&gt;学习一手的知识，看专业经典的名著，而不是看经过别人总结汇总的二手知识。&lt;/strong&gt;这点很重要，学习没有捷径，不要想着一步登天。当你学习领悟之后，分享出来，会有更深的理解。那些和你一样花了时间专研的人看了你的文章，会和你产生共鸣，或者有所启发。那些没有花时间学习的人看了你的文章，也许会是他的一个入门指引，为他打开了一扇窗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分享即学习，通过分享，收获最大的是你自己。&lt;/strong&gt;很庆幸，在我刚工作的时候，就有人告诉了我这一点。他就是我的良师益友：TinyFish（外号鱼头，中文名就不写啦），出来创业做游戏也是和他一起的。在他身上，我学习了很多。他常常和我说，有时候自己问题想不明白时，拉上别人，在和别人叙述分享问题的过程中，突然就能发现问题所在，找到解决的方法，别人甚至没有说一个字。因为你在叙述的过程，你的大脑在经历不断的思考、总结、梳理的过程。&lt;strong&gt;一个你想不明白的问题，通过和别人分享，你能自己找到答案。一个你以为想明白了的问题，通过和别人分享，你会突然发现，之前所说的，都是错的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以上就是我这篇文章想要分享的内容，通过写这篇文章，我又对分享本身理解更深了。你呢？&lt;/p&gt;

&lt;p&gt;如果你喜欢我的文章，就订阅我的微信公众号：hacker-thinking 吧。&lt;/p&gt;

&lt;p&gt;微信扫一扫：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo 自动化部署脚本</title>
            <link>http://blog.coderzh.com/2015/11/21/hugo-deploy-script/</link>
            <pubDate>Sat, 21 Nov 2015 17:48:04 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/21/hugo-deploy-script/</guid>
            <description>

&lt;p&gt;之前我写了一个脚本用来自动部署我的 Hugo 博客，今天闲来无事完善了一下这个脚本，使这个脚本更加通用一些。&lt;/p&gt;

&lt;p&gt;脚本路径：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;原理:5dd178ee6323378b401661424ca0e072&#34;&gt;原理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;deploy.py&lt;/code&gt; 会自动执行 hugo 命令生成静态站点，然后将生成的文件拷贝到上层的一个目录里，然后，在那个目录里将文件 push 到你指定的 Git Repository 里。&lt;/p&gt;

&lt;h3 id=&#34;使用方法:5dd178ee6323378b401661424ca0e072&#34;&gt;使用方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 &lt;code&gt;deploy.py&lt;/code&gt; 放到你的 Hugo 站点目录。（和 config.yaml 等文件放一起）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑 &lt;code&gt;deploy.py&lt;/code&gt; 文件，修改你要部署到的 Git Repository：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;GIT_REPO = [
    # [别名,   分支名,     Git Repo 路径]
    [&#39;origin&#39;,  &#39;gh-pages&#39;, &#39;git@github.com:coderzh/hugo-blog-deployed.git&#39;],
    [&#39;gitcafe&#39;, &#39;gh-pages&#39;, &#39;git@gitcafe.com:coderzh/coderzh-hugo-blog.git&#39;],
]
# 部署到哪里，相对上一级目录。比如下面的配置，会部署到 ../gh-pages 目录里
DEPLOY_DIR = &#39;gh-pages&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你的网站需要指定皮肤，需要在 config 文件中指定 &lt;code&gt;theme&lt;/code&gt; 。因为我的脚本在生成静态文件时并不会指定皮肤。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;theme: &amp;quot;rapid&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第一次执行，使用 &lt;code&gt;first&lt;/code&gt; 参数，它会做一些初始化的操作。并使用 &lt;code&gt;-t&lt;/code&gt; 表示只是测试一下，并不会真的 push 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py first -t
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间可能需要输入密码，如果是自动化部署，可在 Git Repo 里添加一个没有密码的 SSH Key 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一切正常，切换到 &lt;code&gt;DEPLOY_DIR&lt;/code&gt; 目录，&lt;code&gt;git log&lt;/code&gt; 看看 commit 记录是否正常。如果一切也如你所愿。则可以把 &lt;code&gt;-t&lt;/code&gt; 参数去掉重新执行一遍，执行真的 push 操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py first
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行完成后，应该已经将生成的静态页面自动 push 到了你指定的 &lt;code&gt;GIT_REPO&lt;/code&gt; 里。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后如需再次手工部署，只需要使用 &lt;code&gt;manual&lt;/code&gt; 参数，速度会快很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py manual
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你想通过 &lt;code&gt;webhook&lt;/code&gt; 来自动部署，使用 &lt;code&gt;auto&lt;/code&gt; 参数，这样在执行 deploy.py 时，会使用 Git 自动更新你当前的 Hugo 站点目录 ，然后部署：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py auto
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s all, 祝你好运！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：Vue.js</title>
            <link>http://blog.coderzh.com/2015/11/15/front-end-dev-vuejs/</link>
            <pubDate>Sun, 15 Nov 2015 21:53:51 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/15/front-end-dev-vuejs/</guid>
            <description>&lt;p&gt;上一篇中，探讨了前端框架的前世今生，最后还列举了当前比较火的几个前端框架，比如：Google 的 Angular，老牌的 Backbone , Facebook 的 React 等等。今天，我只想介绍一个小而美的前端框架：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;为什么说 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 是一个小而美的前端框架呢？因为它小， min 版本大小是 72K （ gzip 压缩后是23 K），而 min 版本的 Angular 144K，React 132K。说它小而美并不单单指它的体积，因为还有很多体积比它小的框架，小而美主要是它使用起来太 TM 的简单直观了！&lt;/p&gt;

&lt;p&gt;Vue.js 的中文主页：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;http://cn.vuejs.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在主页中，号称“10 秒钟看懂 Vue.js”，的确是这么回事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;demo&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;{{message}}&amp;lt;/p&amp;gt;
  &amp;lt;input v-model=&amp;quot;message&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var demo = new Vue({
  el: &#39;#demo&#39;,
  data: {
    message: &#39;Hello Vue.js!&#39;
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子的效果是在 input 里输入任何内容，会自动出现在 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 里。非常简单直观的进行了数据绑定，只要数据发生变化， View 会自动发生变化。这就是数据驱动的。&lt;/p&gt;

&lt;p&gt;并不是每个人都需要或者有机会去开发一个大型的 Web 应用，那些流行的框架又需要一定的学习曲线，而且很多功能并不需要使用到。或者说，你只想干一件简单的事情，但是由于引入了那些框架，使得自己不得不按照框架的规定定义一个又一个东西，最后仅仅是为了实现一个简单的功能。&lt;/p&gt;

&lt;p&gt;所以，&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 非常适合用于一些小型项目（当然，大型项目也适合。），因为可以快速上手，简单的看下它的文档就可以开始动手了。而且， Vue.js 的执行速度也非常的快。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;https://github.com/lhorie/todomvc-perf-comparison&#34;&gt;TodoMVC Benchmark&lt;/a&gt; 的评测中，得出的综合评价：Mercury, &lt;strong&gt;Vue&lt;/strong&gt; and Mithril are king.&lt;/p&gt;

&lt;p&gt;在 Safari 6.1, OS X 的评测里，Vue.js 的性能直接排到了第一的位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/todomvc-pef-Safari.png&#34; alt=&#34;todomvc-perf-Safari&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以，我现在就有冲动拿 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 来做点东西了，刚好目前要做的一个项目可以用上，这样可以少写很多烦人的 JavaScript 代码了，简直完美。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt;（读音 /vjuː/, 类似于 view），是一个构建数据驱动的 web 界面的库。它的作者是个中国人：尤小右，真名尤雨溪，之前在 Google Creative Lab 工作过。正是目睹了 Angular 、 Ember 框架的笨重不够灵活，Backbone 不支持数据绑定 ， Knockout 和 Ractive 在组件的嵌套和组合上不够理想，于是他决定自己重新设计一个简洁的 MVVM 数据绑定的前端框架。&lt;/p&gt;

&lt;p&gt;在 GitHub 上， &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 已经收集了 9500 多个 Star，为了让更多人参与进来贡献代码，作者坚持保持代码测试的覆盖率为 100% 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/vue-cov.jpg&#34; alt=&#34;vue-cov&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的目标是通过尽可能简单的 API 实现&lt;strong&gt;响应的数据绑定&lt;/strong&gt;和&lt;strong&gt;组合的视图组件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;响应的数据绑定&lt;/strong&gt; 就是数据驱动视图的概念。它让你在写 Web 应用界面时，只需要关注两件事：数据如何展示和数据如何变化。一旦数据发生变化时，比如用户输入，或者 ajax 请求返回后数据发现修改，对应的视图界面会自动的进行更新。（之前的做法是使用 jQuery 手动操作 DOM 更新界面元素。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mvvm.jpg&#34; alt=&#34;mvvm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;定义好数据如何展示，绑定数据后，就只需要关心数据如何变化的事情了，是不是感觉 So Easy ！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合的视图组件&lt;/strong&gt; 是 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的一个重要概念，有了组件系统，可以很好的复用组件，提高效率，从而也为开发一个大型应用提供了很好的技术保证。&lt;/p&gt;

&lt;p&gt;本文并不是要详细介绍 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的特点及使用方法，因为要学习 Vue.js ，看官方的文档是最好的学习方式。作者是中国人，自带中文文档已经足够方便让你学习起步。本文的目的只是想介绍 Vue.js ，因为我认为它很了不起。&lt;/p&gt;

&lt;p&gt;在如此激烈的前端框架竞争环境下， 凭借作者一己之力，用小而美，精简易用，性能还那么好的 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 直接挑战了像 Google 、 Facebook 这样公司开发的前端框架。作者在设计框架时，时时刻刻遵循简单、精巧、易用的设计哲学让人钦佩。为保证代码的质量，获得更多的开发者的信赖，作者的每一行代码都经过单元测试，体现了作者的严谨性。这就是我从他身上学到的东西。&lt;/p&gt;

&lt;p&gt;最后，再次给出 Vue.js 的链接：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;http://cn.vuejs.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;走进前端开发系列：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/&#34;&gt;走进前端开发之：Bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/11/07/front-end-dev/&#34;&gt;走进前端开发之：框架的演变&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>网站被随机挂广告，疑似被 HTTP 劫持</title>
            <link>http://blog.coderzh.com/2015/11/14/http-dns-hijack/</link>
            <pubDate>Sat, 14 Nov 2015 19:36:38 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/14/http-dns-hijack/</guid>
            <description>

&lt;p&gt;最近发现我的博客网站随机的会在右下角出现一个 google 的广告，郁闷至极，我的博客网站根本没有任何广告。于是今天特意去查了查，这广告到底从何而来。&lt;/p&gt;

&lt;h2 id=&#34;现象:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;首先，广告长这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/blogads.jpg&#34; alt=&#34;blogads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;太可恨了！我的网站是 &lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;， 检查了网站的源文件，没有被修改的痕迹，也根本不会有什么广告代码。所以怀疑是被运营商劫持了！&lt;/p&gt;

&lt;p&gt;我使用的是广州电信100M光纤，被挂广告只有在家里上电信光纤时会出现，连手机里访问也会有广告：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/phoneads.jpg&#34; alt=&#34;phoneads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是如果手机连的是联通4G，就没有一点问题！&lt;/p&gt;

&lt;p&gt;后来在追查过程中，发现遇到这个问题的不止我一个人，比如，云风在他的新浪微博里说到：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://weibo.com/2388714105/D2013qUSo?type=comment#_rnd1447506909896&#34;&gt;http://weibo.com/2388714105/D2013qUSo?type=comment#_rnd1447506909896&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/yunfengads.jpg-ws&#34; alt=&#34;yunfengads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另一个博主也遇到这个问题：&lt;a href=&#34;http://www.lovefcwr.com/20151110-google-ca-pub-8129816473729933&#34;&gt;网站被黑了随机挂ca-pub-8129816473729933的google广告，怎么办？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还有一个用户在 Google Adsens 也举报了这个广告主：&lt;a href=&#34;https://productforums.google.com/forum/#!topic/adsense/qeeYrD7kvUA;context-place=forum/adsense&#34;&gt;Please help us to stop this Google Adsense user &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;初步分析:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;初步分析&lt;/h2&gt;

&lt;p&gt;这个问题出现在最近1，2个月，被插入广告的都属于同一个广告主：ca-pub-8129816473729933 。&lt;/p&gt;

&lt;p&gt;很多网站广告插入的方式和表现是完全一致的。广告隔断时间会出现一次，刷新网页后就消失了。&lt;/p&gt;

&lt;p&gt;我和云风使用的宽带都是广州电信！（我手机换成联通移动 4G 就没问题。）&lt;/p&gt;

&lt;p&gt;所以，不得不怀疑是电信做了手脚，对访问的网站进行了劫持！电信也不是第一次做 &lt;strong&gt;HTTP 劫持&lt;/strong&gt; 这种事。&lt;/p&gt;

&lt;p&gt;于是，我捕捉了一些现场证据，分析了劫持的脚本和基本原理，然后拨通了中国电信 10000 号。&lt;/p&gt;

&lt;h2 id=&#34;10000-号:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;10000 号&lt;/h2&gt;

&lt;p&gt;电信工作人员矢口否认进行了 HTTP 劫持，把原因归咎到电脑是否中毒了，WIFI 路由器被做了手脚等等。我说我的电脑杀过毒并没有问题，不仅电脑，iPhone 手机访问网页也会被嵌入广告，你是说我的 iPhone 也中毒了吗？而且切换成联通 4G 就没有问题，你说和你们没关系？ WIFI 路由器我也试了把 DNS 设置成各种不同的，包括默认的，甚至把路由器恢复出厂设置，通通没用！&lt;/p&gt;

&lt;p&gt;最后他说可能和我拨号分配到的 IP 是内网 IP有关，帮我恢复到公网 IP 试试。 What ! 难道我的网络之前一直属于你们的局域网？？不应该默认就是公网 IP 吗？？&lt;/p&gt;

&lt;p&gt;然而，切换公网 IP 后也并没有什么用！（中间还出现切换出错，导致我几个小时拨号不成功上不了网，哭了~~）&lt;/p&gt;

&lt;p&gt;打 10000 号目前还未解决问题，解决不了去工信部投诉去。&lt;/p&gt;

&lt;h2 id=&#34;深入分析:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;深入分析&lt;/h2&gt;

&lt;p&gt;访问一个网站，网站的内容都是被恶意篡改过的，这多么可怕。&lt;/p&gt;

&lt;p&gt;于是在 Chrome 里 “审查元素”里跟踪了一下，看看到底是如何篡改的。通过查看 Elements ，发现 html 里被嵌入了以下代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/adsjs2.jpg-w&#34; alt=&#34;adjs2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picturefill.min.js 是我网站使用的一个正常的 js 文件，查看网页源码发现，出现了两条关于 picturefill.min.js 的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;assets/picturefill/picturefill.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;http://blog.coderzh.com/assets/picturefill/picturefill.min.js?_Ax144746802655173=xxA.baidu.com&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再查看请求 picturefill.min.js 时返回了什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/fakejs.jpg-w&#34; alt=&#34;fakejs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/rightjs.jpg-w&#34; alt=&#34;rightjs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面显示，请求 picturefill.min.js 时，返回的竟然是被篡改的内容，被篡改的内容里，先是再次请求了一次原版的 picturefill.min.js ，然后就是插入 google 的广告代码。&lt;/p&gt;

&lt;p&gt;从 google 的广告代码看出，广告主的 ID 是：ca-pub-8129816473729933 ， 正是和云风及之前一位博主说到的广告主是同一个！ Google 你还不赶紧查查他！&lt;/p&gt;

&lt;p&gt;最后这段恶意篡改的 js 代码生成出来的嵌入广告是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/adsjs.jpg-w&#34; alt=&#34;adjs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后又试验了多次，总结了进行 HTTP 劫持的基本套路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;劫持任一 js 的请求，返回包含原 js 及恶意代码的假的 js 内容。&lt;/li&gt;
&lt;li&gt;假的 js 通过 DOM 操作，强行在原来的网页内植入广告。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种恶意修改 DOM 的方式，和之前常见的把原网站套入一个 iframe 的方式有所不同。基本很难防范。&lt;/p&gt;

&lt;h2 id=&#34;解决方法:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;打 10000 号，投诉，投诉，再投诉。&lt;/p&gt;

&lt;p&gt;工信部投诉地址：&lt;a href=&#34;http://www.chinatcc.gov.cn:8080/cms/shensus/&#34;&gt;http://www.chinatcc.gov.cn:8080/cms/shensus/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了找出哪一层路由做了手脚，大家通过 traceroute ( Windows 里是 tracert ) 看看访问被植入广告的网站到底经过哪些路由。下面是我的 tracert 结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;D:\Code\Go\coderzh-hugo-blog&amp;gt;tracert blog.coderzh.com

通过最多 30 个跃点跟踪
到 github.map.fastly.net [103.245.222.133] 的路由:

  1    &amp;lt;1 毫秒   &amp;lt;1 毫秒   &amp;lt;1 毫秒 192.168.0.1
  2    12 ms     2 ms     1 ms  113.109.112.1
  3     3 ms     3 ms     3 ms  183.56.38.209
  4     5 ms     3 ms     3 ms  183.56.30.21
  5     9 ms     8 ms     8 ms  202.97.34.114
  6     9 ms     8 ms     7 ms  202.97.34.74
  7   156 ms   158 ms   156 ms  202.97.60.214
  8   158 ms   168 ms   166 ms  ae-1.r30.tokyjp05.jp.bb.gin.ntt.net [129.250.2.157]
  9   164 ms   176 ms   175 ms  ae-17.r01.tokyjp03.jp.bb.gin.ntt.net [129.250.6.117]
 10     *        *        *     请求超时。
 11   164 ms   164 ms   163 ms  103.245.222.133

跟踪完成。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你不是对一个网站很熟悉，你压根发现不了这广告根本不是网站主投放的。&lt;/p&gt;

&lt;p&gt;这种强行修改你访问网页的内容来植入广告的方式，非常可怕。使得我们在上网的时候没有一点安全感。如果你访问一个网站，都不能保证获取到的内容是该网站原版的内容，而是被肆意的插入广告，被修改的内容。那么之后他很可能会骗取你的账号密码，偷走你的隐私，拿走你的存款，这是多么可怕和不可接受的事。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：框架的演变</title>
            <link>http://blog.coderzh.com/2015/11/07/front-end-dev/</link>
            <pubDate>Sat, 07 Nov 2015 08:44:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/07/front-end-dev/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/angular-backbone-react-logo.jpg-wt&#34; alt=&#34;angular-backbone-react-logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上周挖了个坑，这周末怎么也得填上。对于大多数前端框架，我都并未用过，但我还是想聊一聊，这些前端框架从何而来，解决了什么问题，又有哪些高明之处。&lt;/p&gt;

&lt;p&gt;认识了解问题，切忌一头扎进去研究而未了解其全貌。为此，我们追溯到20世纪90年代，网景浏览器横空出世，占据了浏览器市场第一的份额。那时的网景浏览器已经搭载了 Cookie、 Frames 和 JavaScript 等功能，可惜好景不长，再后来与微软的“浏览器大战”中败下了阵来。&lt;/p&gt;

&lt;p&gt;于是网景公司将代码开源，创造了 Mozilla ，也就是现在的 Firefox。可以说，浏览器大战从未停止过，Opera 、 Safari 、 Google Chrome …… 当然，还有微软的 Internet Explorer 以及一些其他的浏览器。各浏览器引擎不同，标准不一，苦了的就是我们的主角：前端开发。&lt;/p&gt;

&lt;h3 id=&#34;排版引擎:4349a6351ab7878e819f52676aaa004b&#34;&gt;排版引擎&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/web-kit-renders.jpg-wt&#34; alt=&#34;web-kit-renders&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所有这些浏览器，使用最广泛的无非是这些引擎： &lt;strong&gt;Gecko 、 WebKit 和 Trident&lt;/strong&gt; 。最早的 Netscape 使用的是 Gecko 排版引擎，后来的 Firefox 继承了它的衣钵。微软从 Spyglass 公司买来技术开发了 Internet Explorer ， 使用了 Trident 引擎。苹果开发了 WebKit ，做出了 Safari 浏览器，后来引擎开源， Google 做出了基于 WebKit 的 Chrome 。&lt;/p&gt;

&lt;p&gt;有人会说，那 QQ浏览器、360浏览器、世界之窗、搜狗浏览器之类的，这些浏览器只是套了 Chrome 或 IE 的内核罢了。&lt;/p&gt;

&lt;p&gt;而和前端程序员打交道的，最终就是这三样东西： HTML 、 CSS 、 JavaScript 。&lt;/p&gt;

&lt;h3 id=&#34;javascript:4349a6351ab7878e819f52676aaa004b&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;HTML 负责描述界面的元素结构， CSS 负责描述界面的样式表现， JavaScript 负责界面元素的交互和与后台数据的交互。早期的静态网页，甚至不需要 JavaScript ，因为不需要太多的交互。即使用到 JavaScript ，最多也是用于表单验证、弹弹提示框。&lt;/p&gt;

&lt;p&gt;随着 Web2.0 的概念炒起来，动态网站逐渐成为主流。早期的动态网站，随便的一个数据更新都要刷新整个页面，体验逐渐变得不可接受。于是，局部数据刷新成了当时的热点，这就是当年炒的很热的 Ajax 技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/ajax.jpg&#34; alt=&#34;Ajax&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ajax 的全称是 Asynchronous JavaScript and XML , 即异步 JavaScript 和 XML 技术。当时炒的神乎其神，而其根本本质其实很简单，就是 XMLHttpRequest ，然后配合 DOM 的操作，就可以变化出各种不同的花样出来。 XMLHttpRequest 负责和服务器交互，返回数据后通过 DOM 的操作动态实时的更新界面元素。&lt;/p&gt;

&lt;p&gt;然而，一个简简单单的 Ajax ，各个浏览器的支持却不同。为了兼容不同的浏览器，导致写 Ajax 变得异常痛苦。比如，一个 XmlHttpRequest 的跨浏览器的通用写法就必须写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Provide the XMLHttpRequest class for IE 5.x-6.x:
// Other browsers (including IE 7.x-8.x) ignore this
//   when XMLHttpRequest is predefined
var xmlHttp;
if (typeof XMLHttpRequest != &amp;quot;undefined&amp;quot;) {
    xmlHttp = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    var aVersions = [&amp;quot;Msxml2.XMLHttp.5.0&amp;quot;, &amp;quot;Msxml2.XMLHttp.4.0&amp;quot;, &amp;quot;Msxml2.XMLHttp.3.0&amp;quot;, &amp;quot;Msxml2.XMLHttp&amp;quot;, &amp;quot;Microsoft.XMLHttp&amp;quot;];
    for (var i = 0; i &amp;lt; aVersions.length; i++) {
        try {
            xmlHttp = new ActiveXObject(aVersions[i]);
            break;
        } catch (e) {}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单单一个 XmlHttpRequest 就让前端程序员百苦难辩，更别说跨浏览器的 DOM 选择与操作、 CSS 的差异…… 前端程序员只能默默檫干眼泪，为了解决这些问题， jQuery 横空出世。&lt;/p&gt;

&lt;h3 id=&#34;jquery:4349a6351ab7878e819f52676aaa004b&#34;&gt;jQuery&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/jQuery.jpg&#34; alt=&#34;jQuery&#34; /&gt;&lt;/p&gt;

&lt;p&gt;jQuery 是一套跨浏览器的 JavaScript 库，既然大家都这么痛苦要处理兼容问题，那何不让我一个人来承受。自 jQuery 从 2006 年 1 月发布第一个版本以来，现在已完全占领市场。据统计，全球前10,000个访问最高的网站中，有65%使用了jQuery 。&lt;/p&gt;

&lt;p&gt;jQuery 不仅解决了浏览器兼容的问题，还提供了大量的简便语法，用于选择和操作 DOM 对象、创建动画效果、处理事件以及 Ajax 的支持。&lt;/p&gt;

&lt;p&gt;得麒麟才子者，可得天下。 jQuery 出来后，有种得 jQuery 者可得前端天下的感觉。随后基于 jQuery 的各种 UI 插件、组件层出不穷，如 YUI 等等，也呈现出百花齐放的气象。&lt;/p&gt;

&lt;p&gt;似乎 jQuery 已经解决了所有问题，而我对前端开发的经验，也止于 jQuery 。 jQuery 的确能解决之前的诸多问题，然而互联网在发展，浏览器的地位不断提高，人们对浏览器里的体验的要求也逐渐变高，Web 端的功能越来越重。 Google 甚至认为你的电脑仅仅需要一个浏览器即可。&lt;/p&gt;

&lt;p&gt;需求越来越多，功能越来越复杂，使得 JavaScript 本身的缺点暴露了出来。 JavaScript 过于灵活，代码的组织过于零散，一旦需求变得复杂，这一大坨一大坨的 JavaScript 代码将变得难以维护。特别是如今崇尚的快速开发、快速试错的开发模式，臃肿、难以组织和维护的 JavaScript 代码成了一个需要重要解决的问题。&lt;/p&gt;

&lt;p&gt;于是，如何将 JavaScript 代码有效的组织和分类，如何简化代码的写法成为了研究的重点。就连 1978 年就被提出的 MVC 模式也被应用到了前端开发的框架之中。&lt;/p&gt;

&lt;h3 id=&#34;mvc:4349a6351ab7878e819f52676aaa004b&#34;&gt;MVC&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mvc.jpg&#34; alt=&#34;MVC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MVC 是一种软件架构分层的思想。将软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（控制器 Controller）- 负责转发请求，对请求进行处理。&lt;/li&gt;
&lt;li&gt;（视图 View） - 界面设计人员进行图形界面设计。&lt;/li&gt;
&lt;li&gt;（模型 Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVC 的优点是将系统进行了分层，单独的分层变得逻辑更加清晰，便于维护，提高了代码的可重用性，由于各司其职，在响应变化时，也能做出快速反应。&lt;/p&gt;

&lt;p&gt;更多关于 MVC 的历史和介绍，可以参考 Martin Fowler 的文章： &lt;a href=&#34;http://www.martinfowler.com/eaaDev/uiArchs.html&#34;&gt;http://www.martinfowler.com/eaaDev/uiArchs.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;应用到前端开发， MVC 里的 Model 、 View 、 Controller 分别对应：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（控制器 Controller）：业务逻辑，URL Router&lt;/li&gt;
&lt;li&gt;（视图 View）：用户界面，DOM 处理。&lt;/li&gt;
&lt;li&gt;（模型 Model）：数据保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了 MVC ，还有 MVP、 MVVM 等模型。然而，这些所谓的概念真的重要吗？黑猫白猫都是好猫，能解决问题的才是好模型好框架。&lt;/p&gt;

&lt;h3 id=&#34;xxx-js:4349a6351ab7878e819f52676aaa004b&#34;&gt;xxx.js&lt;/h3&gt;

&lt;p&gt;后面出来的 xxx.js 我就不太懂了。比如：&lt;strong&gt;Ember.js、Angular.js、Backbone.js、Knockout.js、React.js&lt;/strong&gt; 。直到写这篇文章前，才打开各自的主页，粗略的浏览了一下各自的 Quick Start ， 了解了一点各自的特性。&lt;/p&gt;

&lt;p&gt;首先，我们来对比一下这几个库在 GitHub 上的 关注度 ：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Ember.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Angular.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Backbone.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Knockout.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;React.js&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Watch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1149&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4036&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1676&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;604&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2261&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Star&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;15036&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;43986&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;23349&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;6903&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30894&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fork&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3233&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;19973&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;5230&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1180&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4833&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从上面的数据可以看出， &lt;strong&gt;Angular.js 、 Backbone.js 、 React.js&lt;/strong&gt; 几乎占据了半壁江山。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;Angular.js&lt;/a&gt; 由 Google 推出，从上面的 Fork 数据看出， Angular 在社区支持和贡献上最为突出。从首页的介绍示例看出， Angular 使用简单，代码逻辑清晰一看就明白，比如数据双向绑定的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;Name:&amp;lt;/label&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;yourName&amp;quot; placeholder=&amp;quot;Enter a name here&amp;quot;&amp;gt;
      &amp;lt;hr&amp;gt;
      &amp;lt;h1&amp;gt;Hello {{yourName}}!&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://backbonejs.org/&#34;&gt;Backbone.js&lt;/a&gt; 是一个老牌的 JavaScript 框架了，据说后来的 JavaScript 框架都受了它的影响。它的特点是简单、灵活，但是很多事情却要你自己来做。我只是不明白，为什么 Backbone.js 的 Getting Started 会写的那么冗长，对于初学者真的好吗？也许真的是应该是老牌框架的原因吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React.js&lt;/a&gt; 由 FaceBook 开发，现在也是火的不行。 React.js 让人为之眼前一亮的功能是 &lt;strong&gt;虚拟 DOM&lt;/strong&gt; 的机制。前面提到，为了能支持局部刷新，就需要通过 DOM 操作局部更新元素，一旦项目变大需求变的复杂，也会变得难以维护。而虚拟 DOM 解决了这一问题，通过虚拟 DOM ，你只需要关注整体的 DOM ，当数据发生变化时， React 会重新构建整个 DOM 树， 然后与上一次的 DOM 树进行对比，自己计算出需要变化的部分。由于虚拟 DOM 都是在内存中操作，所以性能会非常好。&lt;/p&gt;

&lt;p&gt;React 推崇组件化开发，提供了专有的语言 JSX ，不过并非必须。一个简单的 React 组件的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var HelloMessage = React.createClass({
  render: function() {
    return &amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;;
  }
});

ReactDOM.render(&amp;lt;HelloMessage name=&amp;quot;John&amp;quot; /&amp;gt;, mountNode);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;趋势:4349a6351ab7878e819f52676aaa004b&#34;&gt;趋势&lt;/h3&gt;

&lt;p&gt;关于 Angular.js 、 Backbone.js 、 React.js ， 如果你是这三种的使用者，也许更有发言权一些。我在百度指数里对比了 angularjs , backbone , react 这三个关键字：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/angular-backbone-react.jpg-ws&#34; alt=&#34;angular-backbone-react&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见 Angular 一经推出便先发制人增长迅猛，而 React 开始阶段和 Backbone几乎并列，但从 2015 年开始爆发，增长速度直指 Angular ， 发展不可估量。&lt;/p&gt;

&lt;h3 id=&#34;总结:4349a6351ab7878e819f52676aaa004b&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;未来前端的世界必定会是天翻地覆，过往的发展历史我能力有限也只能提到这么多。虽然前端框架还在一直往前发展，但我回过头来仔细想想，这样的发展方向正确吗？&lt;/p&gt;

&lt;p&gt;即使很多人并不喜欢 JavaScript ， 但是 JavaScript 凭借早期的浏览器奠定了坚不可摧的地位， JavaScript 有诸多缺陷，后续的框架只是在不断的弥补它的缺陷而已。还有关于各浏览器的支持问题，后续的框架也是在不断的填坑。你们有没有想过，是否有一天，我们能从根本上去解决这些问题，而不是一次又一次的背上历史的包袱。&lt;/p&gt;

&lt;p&gt;为了解决 JavaScript 的问题，甚至出现各种替代语言，而这些所谓的替代语言，也只能算是 JavaScript 的预处理语言，最终还是编译成了 JavaScript 代码，你不觉得有点可笑吗？&lt;/p&gt;

&lt;p&gt;比如，&lt;strong&gt;CoffeeScript、 Flow 、 Dart 、 Babel 、 TypeScript&lt;/strong&gt; 。 而说到 &lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;，它的作者是鼎鼎大名的 &lt;strong&gt;Anders Hejlsberg&lt;/strong&gt; 。刚才说麒麟之才，这个才真的是麒麟之才！他是 Turbo Pascal 编译器的作者，后来发明了 Delphi ， 加入微软后主导开发了 C# 。现在，他正致力于 TypeScript 的开发。看了最近关于的他的报道，他表示 TypeScript 并不追求替代 JavaScript ， 并不计划直接运行在浏览器或系统里，而仅仅关注如何编译成 JavaScript 。 这是一种妥协吗？ 还是暂时的低调？未来会如何发展，这是留给前端同学的问题。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo中文文档翻译计划</title>
            <link>http://blog.coderzh.com/2015/11/01/hugo-translate/</link>
            <pubDate>Sun, 01 Nov 2015 23:52:31 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/01/hugo-translate/</guid>
            <description>

&lt;p&gt;中文文档：&lt;a href=&#34;http://www.gohugo.org/doc/&#34;&gt;http://www.gohugo.org/doc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;https://github.com/coderzh/gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo-介绍:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;Hugo 介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://spf13.com&#34;&gt;spf13&lt;/a&gt; 对于 Hugo 的英文原版介绍地址在这，就不另行翻译了：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原文大致意思是当前的静态网站生成工具对环境依赖过多，性能较差，于是使用 Go 语言写了一个静态网站生成器 Hugo 。不仅解决了环境依赖、性能较差的问题，还有使用简单、部署方便等诸多优点，通过 Liveload 实时刷新，极大的优化文章的写作体验。&lt;/p&gt;

&lt;h4 id=&#34;hugo-能做什么:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;Hugo 能做什么&lt;/h4&gt;

&lt;p&gt;通过 Hugo 你可以快速搭建你的静态网站，比如博客系统、文档介绍、公司主页、产品介绍等等。相对于其他静态网站生成器来说，Hugo 具备如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;极快的页面编译生成速度。（ ~1&amp;nbsp;ms 每页面）&lt;/li&gt;
&lt;li&gt;完全跨平台支持，可以运行在 &lt;i class=&#34;fa fa-apple&#34;&gt;&lt;/i&gt;&amp;nbsp;Mac OS&amp;nbsp;X, &lt;i class=&#34;fa fa-linux&#34;&gt;&lt;/i&gt;&amp;nbsp;Linux, &lt;i class=&#34;fa fa-windows&#34;&gt;&lt;/i&gt;&amp;nbsp;Windows, 以及更多!&lt;/li&gt;
&lt;li&gt;安装方便 &lt;a href=&#34;http://www.gohugo.org/doc/overview/installing/&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本地调试 &lt;a href=&#34;http://www.gohugo.org/doc/overview/usage/&#34;&gt;Usage&lt;/a&gt; 时通过 &lt;a href=&#34;http://www.gohugo.org/doc/extras/livereload/&#34;&gt;LiveReload&lt;/a&gt; 自动即时刷新页面。&lt;/li&gt;
&lt;li&gt;完全的皮肤支持。&lt;/li&gt;
&lt;li&gt;可以部署在任何的支持 HTTP 的服务器上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于翻译文档:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;关于翻译文档&lt;/h3&gt;

&lt;p&gt;中文翻译文档目的是让 Hugo 在中国能得到更好的推广，让有需要和对 Hugo 感兴趣的人能从此文档中获得微薄帮助。&lt;/p&gt;

&lt;p&gt;此中文文档的英文原版皆从 Hugo 官方 GitHub 上来：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/tree/v0.14.docs&#34;&gt;https://github.com/spf13/hugo/tree/v0.14.docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;取自 v0.14.0 版本，基于 revision: &lt;a href=&#34;https://github.com/spf13/hugo/tree/acd6ad92c181cd7cdb485467cef0e8986911fb02&#34;&gt;acd6ad9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译文档最麻烦的是能否跟上官方文档的更新， Hugo 官方文档目前虽在 v0.14.0 版本，但也经常有些更新，待本文档翻译完成之后，每隔一定的周期，根据本文所记录的 revision 对原文档进行 diff，然后补上更新内容。&lt;/p&gt;

&lt;p&gt;此次翻译我也希望借助社区之力，如果你对此有兴趣，请前往本站的 GitHub &lt;strong&gt;提交一个 Issue，标题注明希望翻译的文档名称&lt;/strong&gt; 即可。&lt;/p&gt;

&lt;p&gt;Issue 提交地址： &lt;a href=&#34;https://github.com/coderzh/gohugo.org/issues&#34;&gt;https://github.com/coderzh/gohugo.org/issues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;待翻译文档路径： &lt;a href=&#34;https://github.com/coderzh/gohugo.org/tree/master/content/doc&#34;&gt;https://github.com/coderzh/gohugo.org/tree/master/content/doc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后 Fork 该 &lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;Repo&lt;/a&gt; ，通过 Pull Request 的方式提交过来便是。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：Bootstrap</title>
            <link>http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/</link>
            <pubDate>Sun, 01 Nov 2015 07:37:56 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bootstrap.jpg-wt&#34; alt=&#34;bootstrap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如今互联网创业热潮此起彼伏，特别是移动互联网，使得前端开发这一职位变得愈加炙手可热。大量公司欲求高端前端开发而不得，进入前端开发浩瀚大军的同学也是日益增多，大家相互厮杀，占领 &lt;code&gt;GitHub&lt;/code&gt; ，只为获得前端开发的一席之地。新技术新框架如雨后春笋，层出不穷，未跟上步伐者也以迅雷不及掩耳之势被取代淘汰。这是一个前端开发百花齐放的时代。&lt;/p&gt;

&lt;p&gt;这段文绉绉的开场白，只为说明一个道理：再不了解学习前端，你就老了。在我们那个年代（好吧，其实也不久），还未有前端开发这样的职位。那时的网站开发同学哪个不是一把辛酸一把泪的不断挑弄着 &lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; ，纵然有一万个草泥马崩腾而过，也只能默默忍受这混乱不堪的一切，在浏览器兼容这一世纪难题面前，心中只能默念：能用就行，习惯就好。除了搬弄前端的 CSS 和 Javascript ，那时的网站开发同学还要兼顾后端。那时的MVC更像是一个整体的概念，而如今随着前端表现日益丰富，重心不断往前端移，后端只需提供类似 &lt;code&gt;Restful&lt;/code&gt; 接口、处理逻辑、存储数据。单单一个前端，已经衍生出各种MVC框架：Embejs、Angular.js、Backbone.js、Knockout.js、React.js……&lt;/p&gt;

&lt;p&gt;然而，这些前端框架我一个也没有用过。我也不是一个前端程序员，所以在写这篇文章时，我也是诚惶诚恐的。毕竟我一个外行，要是让专做前端开发的读者看了，难免班门弄斧贻笑大方，也许还少不了几句点评指责。当然，我也是虚心接受的。“走进前端开发”我打算写成一个系列文章，目的并不是多深入的介绍和学习前端开发，而是“走进”，或者说“走近”、“了解”，站在一个旁观者的角度去观察了解，前端开发到底是怎样一个群体。&lt;/p&gt;

&lt;p&gt;这是第一篇，主角是： &lt;code&gt;Bootstrap&lt;/code&gt; 。我在做 &lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt; 时就使用到了 Bootstrap 。或多或少你也许听过 Bootstrap 的大名，或者“响应式布局”是否在哪里听过？何为“响应式布局”？响应式布局是指，一个网站只需要做一个版本，就能自动适应和兼容各个终端平台，比如：PC、手机、平板，呈现出最好的表现效果。&lt;/p&gt;

&lt;h3 id=&#34;多终端适配:0b0432fd07b093099631d3dfda0706d0&#34;&gt;多终端适配&lt;/h3&gt;

&lt;p&gt;这样又要说到“多终端适配”的问题了。在响应式布局出现之前，人们是怎么处理多终端适配的呢？主要有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;跳转适配&lt;/p&gt;

&lt;p&gt;跳转适配会根据你使用的设备类型跳转到对应的单独地址。比如：你在手机浏览器里输入 163.com ，会自动跳转到 3g.163.com 。实现的方法是在通过 Meta 信息申明，或是 Server 根据 User-Agent 进行跳转。跳转适配需要针对不同设备类型，使用不同的url，做多套界面。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码适配&lt;/p&gt;

&lt;p&gt;代码适配在不同设备中使用同一个 URL ， Server 会根据 User-Agent 的不同生成不同的 HTML 页面。比如在手机里输入： weixin.qq.com ，虽然地址一样，但看到的内容和PC端是完全不一样的。（你会发现找不到“公众平台”的入口）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然，这两种适配方式的维护成本都比较大。因为要针对不同平台维护不同版本，常常会出现移动版和 PC 版不同步的问题。&lt;/p&gt;

&lt;p&gt;接着，就要提到第三种适配方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自适应：同一 URL ，同一套 HTML 界面，根据使用设备（PC、移动设备、平板电脑）的不同，根据屏幕尺寸呈现出不同的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“响应式布局”就是自适应适配的一种布局方式。为了让自适应适配更加方便易用，Bootstrap框架应运而生。&lt;/p&gt;

&lt;h3 id=&#34;bootstrap:0b0432fd07b093099631d3dfda0706d0&#34;&gt;Bootstrap&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://getbootstrap.com/&#34;&gt;Bootstrap&lt;/a&gt; 是 Twitter 推出的一个用于前端开发的开源工具包。它由 Twitter 的设计师 Mark Otto 和 Jacob Thornton 合作开发，是一个 CSS/HTML 框架。通过 Bootstrap ，你可以非常轻松的设计出移动端友好，又能在不同设备适配良好的网站。&lt;/p&gt;

&lt;p&gt;Bootstrap 天生为移动设备而设计，框架由内到外默认都是移动设备优先的。使用 Bootstrap 非常简单，首先将页面设置成 HTML5 文档类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
  ...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 之间添加 viewport 元数据标签：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以设置禁用缩放功能，让你的网站在浏览器里看上去更像一个原生应用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 Bootstrap 最简单快速的方式是直接使用 Bootstrap 中文网提供的 CDN 加速服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 新 Bootstrap 核心 CSS 文件 --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&amp;quot;&amp;gt;

&amp;lt;!-- 可选的Bootstrap主题文件（一般不用引入） --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css&amp;quot;&amp;gt;

&amp;lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&amp;gt;
&amp;lt;script src=&amp;quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&amp;gt;
&amp;lt;script src=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以使用 &lt;code&gt;Bower&lt;/code&gt; 、 &lt;code&gt;npm&lt;/code&gt; 、 &lt;code&gt;Composer&lt;/code&gt; 等工具进行安装。为了更强的定制性，你还可以使用 &lt;code&gt;Less/Sass&lt;/code&gt; 源码进行编译。&lt;/p&gt;

&lt;p&gt;编译？其实就是CSS文件的生成过程。我们知道，CSS 在处理样式时异常灵活，以至于不同人写出来的样式代码五花八门，各种元素之间相互影响相互制约，某处稍一改动就有牵一发而动全身的效果。再加上不同浏览器支持的特性千差万别，使得CSS代码变得非常难以组织和维护。&lt;/p&gt;

&lt;p&gt;由此，CSS 预处理应运而生。通过定义一种新的语言，自动实现浏览器兼容、变量、结构体等功能，还支持逻辑判断和循环，最后通过编译生成最终的 CSS 目标文件。使得代码更加简洁，容易维护。而 Less/Sass 就是目前最流行的CSS预处理器。&lt;/p&gt;

&lt;p&gt;除了上面的方式，你还可以像我这种懒人一样直接下载现成的示例模板，然后再做一些细微的调整。&lt;/p&gt;

&lt;h3 id=&#34;bootstrap-布局:0b0432fd07b093099631d3dfda0706d0&#34;&gt;Bootstrap 布局&lt;/h3&gt;

&lt;p&gt;Bootstrap 提供了一套完整的基础 CSS 模块，预定义了一套简单易用的样式组件，同时结合jQuery 提供了一套基础的方便的 Javascript 交互组件。简直就是提供了 Web 前端的一站式解决方案。&lt;/p&gt;

&lt;p&gt;这里我只介绍一下自适应适配最核心之处： Bootstrap 的栅格布局系统。&lt;/p&gt;

&lt;p&gt;首先，我们要为页面内容和栅格系统包裹一个 &lt;code&gt;.container&lt;/code&gt; 容器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.container&lt;/code&gt; 类用于固定宽度和响应式布局的容器，如果占据 100% 的宽度，使用 &lt;code&gt;.container-fluid&lt;/code&gt; 类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;container-fluid&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栅格系统会根据屏幕和视口（viewport）的尺寸，将一行分为最多 &lt;strong&gt;12&lt;/strong&gt; 列，通过预设好的栅格类表示需要占多少个列宽度。比如，可以使用 3 个 &lt;code&gt;.col-xs-4&lt;/code&gt; 可以将页面容器分成 3 个等分。使用 1 个 &lt;code&gt;.col-xs-3&lt;/code&gt; 和 1 个 &lt;code&gt;.col-xs-9&lt;/code&gt; ，可以对页面容器进行 3：9 比例分割，实现一个左侧 Sidebar 的效果。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bootstrap-grid.jpg&#34; alt=&#34;bootstrap-grid&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-8&amp;quot;&amp;gt;.col-md-8&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;.col-md-6&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;.col-md-6&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了指定宽度，还可以通过指定 &lt;code&gt;.col-md-offset-*&lt;/code&gt; 等进行偏移。回到一个重要的问题，知道了大致如何布局，那如何进行移动适配呢？&lt;/p&gt;

&lt;p&gt;上面的例子我们看到，有 &lt;code&gt;.col-xs-*&lt;/code&gt; 和 &lt;code&gt;.col-md-*&lt;/code&gt; 等等，其实 xs 、 md 等对应的是不同显示设备。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.col-xs-*&lt;/code&gt; ：超小屏幕、手机 (&amp;lt;768px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-sm-*&lt;/code&gt; ：小屏幕 平板 (≥768px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-md-*&lt;/code&gt; ：中等屏幕 桌面显示器 (≥992px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-lg-*&lt;/code&gt; ：大屏幕 大桌面显示器 (≥1200px)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过给 div 定义多个 &lt;code&gt;col-xx-*&lt;/code&gt; 的组合就可以达到不同移动设备进行布局适配的目的。&lt;/p&gt;

&lt;p&gt;比如下面的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-xs-6 col-md-3&amp;quot;&amp;gt;.col-xs-6 .col-md-3&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-xs-6 col-md-9&amp;quot;&amp;gt;.col-xs-6 .col-md-9&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将实现在手机端进行 6：6 布局，在中等屏幕的PC端进行 3 : 9 布局。&lt;/p&gt;

&lt;h3 id=&#34;总结:0b0432fd07b093099631d3dfda0706d0&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;如今 Bootstrap 已经被广泛使用，国内外大量网站使用 Bootstrap 数不胜数。如果你需要开发一个移动端友好的网站， Bootstrap 是你的不二选择。本文只是 Bootstrap 的粗浅入门，有兴趣的同学可以找资料进行更加深入的学习。&lt;/p&gt;

&lt;p&gt;Bootstrap 官方网站：&lt;a href=&#34;http://getbootstrap.com/&#34;&gt;http://getbootstrap.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于前端开发的 Bootstrap 这把利器多少有了一些了解，接下来可以去了解了解那些号称1，2周就有大更新，1，2个月就有新冒出来的，3，4个月不学就要落伍的前端框架了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo中文网站gohugo.org上线</title>
            <link>http://blog.coderzh.com/2015/10/25/gohugo-org/</link>
            <pubDate>Sun, 25 Oct 2015 23:37:16 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/25/gohugo-org/</guid>
            <description>

&lt;p&gt;之前我在博客里写了一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;，之后有很多人给我留言或者邮件，列举了在搭建Hugo时遇到的各种问题，并且提出希望能有一个中文的Hugo网站。&lt;/p&gt;

&lt;p&gt;于是，我利用周末的时间，注册域名（居然注册到了 &lt;code&gt;gohugo.org&lt;/code&gt; 这个域名），用&lt;code&gt;Hugo&lt;/code&gt;本身搭建了这个网站，运行在 &lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;DigitalOcean&lt;/a&gt; 的 &lt;code&gt;VPS&lt;/code&gt; 上。这就是 &lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;gohugo-org:39bef422aa544bc9d53b933146f67273&#34;&gt;gohugo.org&lt;/h3&gt;

&lt;p&gt;网站的地址是：&lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网站所有内容都在 &lt;code&gt;GitHub&lt;/code&gt; 开源，地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;https://github.com/coderzh/gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该Repository已经设置了WebHook，只要有push就会自动触发 &lt;code&gt;VPS&lt;/code&gt; 更新部署。如果你感兴趣，可以加入进来，你提的PR一旦被Merged将立即在网站更新出来。&lt;/p&gt;

&lt;h3 id=&#34;截图:39bef422aa544bc9d53b933146f67273&#34;&gt;截图&lt;/h3&gt;

&lt;h4 id=&#34;首页:39bef422aa544bc9d53b933146f67273&#34;&gt;首页&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-index.jpg-w&#34; alt=&#34;gohugo-index&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;文章列表:39bef422aa544bc9d53b933146f67273&#34;&gt;文章列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-post.jpg-w&#34; alt=&#34;gohugo-post&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;皮肤列表:39bef422aa544bc9d53b933146f67273&#34;&gt;皮肤列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-theme.jpg-w&#34; alt=&#34;gohugo-theme&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;示例网站:39bef422aa544bc9d53b933146f67273&#34;&gt;示例网站&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-showcase.jpg-w&#34; alt=&#34;gohugo-showcase&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于hugo:39bef422aa544bc9d53b933146f67273&#34;&gt;关于Hugo&lt;/h3&gt;

&lt;p&gt;使用Hugo可以快速的制作一个静态站点，同时Hugo还在不断更新和发展中，相信未来会更加易用、功能越来越好。我给Hugo提过几次PR，看过Hugo的代码，从代码的角度来看，Hugo的代码写非常简洁清晰，模块分类非常的清楚，并且配备完善的单元测试。&lt;/p&gt;

&lt;p&gt;对于如此优秀的东西，希望能与更多人分享，通过分享和交流，希望能促进Hugo变得越来越好，让它更加广为人知。&lt;/p&gt;

&lt;p&gt;因此，所有对Hugo感兴趣的朋友欢迎加入贡献内容，同时也欢迎有任何疑问、建议或交流的朋友加入Hugo交流QQ群：512499080。&lt;/p&gt;

&lt;p&gt;或者微信扫一扫关注我的微信公众号：hacker-thinking&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.coderzh.com/public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>程序员直播写代码网站livecoding.tv即将登陆中国，你有兴趣吗？</title>
            <link>http://blog.coderzh.com/2015/10/23/livecoding</link>
            <pubDate>Fri, 23 Oct 2015 07:08:11 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/23/livecoding</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/livecoding.jpg-wt&#34; alt=&#34;livecoding&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;lol直播:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;LOL直播&lt;/h3&gt;

&lt;p&gt;之前玩LOL那段时间，在不玩游戏的时候最爱的就是看别人直播打游戏。最早的时候，是在own3d.tv上看，后来twitch.tv异军突起，直接统领了国外竞技游戏直播平台。比如那时候看HotshotGG玩豹女，Dyrus玩奥拉夫，甚至看他在Ban/Pick阶段切出去玩俄罗斯方块，也极为有趣。后来twitch.tv越来越卡了，随之YY直播主播兴起，以及现在的斗鱼直播，我也十分爱看。有的主播不但技术强，也十分风趣幽默，看他们和高手对决，或者代练虐菜，也十分享受。比如我比较喜欢的主播有阿倪蛋糕店、董小飒，还有玩德莱文玩到逆天的文森特。这些人都不是职业选手，但是他们的操作意识都十分让人惊叹。（也许之前关于LOL的那些好玩事可以单独开一篇来讲。）&lt;/p&gt;

&lt;p&gt;没玩LOL已经一年多了，不知道现在的情况如何了。有一点可以确定，LOL还是那么的火，直播LOL让主播赚的盆满钵满。观众也十分爱看。就像我们小时候总喜欢站在高手后边看他们怎么玩游戏，怎么一币通关是一个道理。&lt;/p&gt;

&lt;h3 id=&#34;直播写代码:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;直播写代码&lt;/h3&gt;

&lt;p&gt;直播越来越火，有人直播唱歌，有人直播玩游戏，甚至有人直播睡觉打呼。&lt;/p&gt;

&lt;p&gt;然而，程序员直播写代码，你会喜欢看吗？&lt;/p&gt;

&lt;p&gt;第一次听说直播写代码，是在《内核恐慌》的第5期关于编程字体的，里面提到美国有个经验丰富的游戏引擎开发者在网上直播写游戏。&lt;/p&gt;

&lt;p&gt;后来查了下资料，具体是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HandmadeHero.jpg-w&#34; alt=&#34;HandmadeHero&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mollyrocket.com/casey/about.html&#34;&gt;Casey Muratori&lt;/a&gt;是西雅图的一名经验丰富的游戏引擎开发者，据他的介绍，他已经拥有30年的游戏开发经验，参与开发的游戏引擎被数以千计的游戏采用。但是他经常抱怨现在的开发者有那么好的硬件条件，却做不出高效率的游戏出来。&lt;/p&gt;

&lt;p&gt;于是他决定在网上直播写一个游戏：&lt;a href=&#34;http://handmadehero.org/&#34;&gt;Handmade Hero&lt;/a&gt;，这个游戏不会使用任何游戏引擎，而是一行一行代码直播码出来。在直播的过程中，他除了敲代码，还会有大量的讲解，让观看直播的人获得更多系统的知识。你还可以给他支持15美元，这样你就可以随时获取到他的最新源代码，当游戏最终发布的时候，你还可以直接获得最终的发行版本。&lt;/p&gt;

&lt;p&gt;他是在twitch.tv上直播的，地址是：&lt;a href=&#34;http://www.twitch.tv/handmade_hero&#34;&gt;http://www.twitch.tv/handmade_hero&lt;/a&gt;，在&lt;a href=&#34;https://www.youtube.com/user/handmadeheroarchive&#34;&gt;You Tube&lt;/a&gt;（当然，这个网站并不存在）上可以观看之前的直播内容。&lt;/p&gt;

&lt;p&gt;优酷里有关于这个项目的宣传视频，非常炫酷：&lt;a href=&#34;http://v.youku.com/v_show/id_XODU2NDQxODky.html&#34;&gt;http://v.youku.com/v_show/id_XODU2NDQxODky.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这样牛逼的程序员在网上直播写代码，你有兴趣看吗？&lt;/p&gt;

&lt;p&gt;我觉得我会喜欢看。&lt;/p&gt;

&lt;h3 id=&#34;livecoding-tv:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;Livecoding.tv&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/livecoding-example.jpg-w&#34; alt=&#34;livecoding-example&#34; /&gt;&lt;/p&gt;

&lt;p&gt;后来甚至出来一个专门的直播写代码网站：&lt;a href=&#34;http://www.livecoding.tv&#34;&gt;Livecoding&lt;/a&gt;，是Y-Combinator孵化器下的项目，确实是正儿八经的要进军这个看起来非常小众的市场。&lt;/p&gt;

&lt;p&gt;于是我上Livecoding，注册账号，观看直播。在上面你可以针对自己的喜好选择不同的编程语言，可以看当天直播也可以看过往录像，看的时候还可以聊天互动，功能基本和twitch.tv差不多。然而，在国内访问，体验只能用一个字来形容：卡。卡到根本看不了，在我做了各种尝试之后，最后还是放弃了。&lt;/p&gt;

&lt;p&gt;今早收到一封邮件，是Livecoding发来的，标题和正文都是中文。内容是：Livecoding即将全面登录中国。 Livecoding正在国内组建团队，在国内架设服务器，预计2016年能登录中国。有任何意见、想法或者经验的同学，可以联系他们michael@livecoding.tv。&lt;/p&gt;

&lt;h3 id=&#34;小众市场才会比较有趣:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;小众市场才会比较有趣&lt;/h3&gt;

&lt;p&gt;这无疑是个好消息，到时候除了可以顺畅的观看各路大神写代码，甚至自己也可以尝试一下当一回主播，比如直播帮学美术的堂弟写个毕业设计要求的小游戏之类的。&lt;/p&gt;

&lt;p&gt;不过，已经有人尝试过了在虎牙和斗鱼上直播写代码，但观看的人数非常少。相对于美女直播和大神游戏玩家，直播撸代码对大众没有多少吸引力，这确实是一个小众市场。&lt;/p&gt;

&lt;p&gt;然而，小众市场才会更加有趣。大众的东西虽然能吸引到更多的人，但往往趋于平庸，能被小众市场吸引的人，往往本身就对这个东西非常感兴趣，如果在小众市场上挖掘的很深，能更加深入小众用户的心，获得更高的忠诚度。&lt;/p&gt;

&lt;p&gt;假如在程序圈内兴起了一股直播撸代码的热潮，你会想从观看直播过程中获得一些什么呢？比如，我就非常好奇，各路BAT或者业界专家大牛，你们写代码时是怎样一种状态，你们使用什么样的编辑器或IDE，选用什么样的字体，使用哪些快捷键，实现功能的思路是怎样的，怎样查文档，怎么Google，用哪些新奇好玩的工具软件，有哪些实用有趣的编程技巧……&lt;/p&gt;

&lt;p&gt;我可以想象到这是一种什么样的场景，就如同我在大学时看一位牛X同学现场教学如何从零开始做一个网站一样，包括写代码、美工P图切图、排版，噼里啪啦一顿快捷键一气呵成，让你看的眼花缭乱，顿时感觉不明觉厉。可惜这位牛X的同学最后还是选择了留校继续研读土木工程。&lt;/p&gt;

&lt;p&gt;对于Livcoding登录中国，我还是有些小期待的。你有兴趣吗？&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>一篇文章了解什么是增长黑客</title>
            <link>http://blog.coderzh.com/2015/10/17/read-growth-hacker/</link>
            <pubDate>Sat, 17 Oct 2015 10:16:41 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/17/read-growth-hacker/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/GrowthHacker.jpg-wt&#34; alt=&#34;GrowthHacker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近在Kindle上读了范冰的《增长黑客》，对增长黑客有了更系统的了解。联想到我自己的微信公众号hacker-thinking和独立博客&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;blog.coderzh.com&lt;/a&gt;，我也在苦苦寻找用户增长的终极奥义。我也尝试过各种SEO（搜索引擎优化），比如规范链接地址、nofollow防止权重降低、提供sitemap、增加关键词、规范robots.txt、加快访问速度、增加反向链接等等。肯定有人会说，这些东西然并卵，高质量的内容才是最重要的。这点我同意。&lt;/p&gt;

&lt;p&gt;通过看《增长黑客》，我了解到了作为一个增长黑客必须具备的素质，了解到了大量的国内外活生生的增长黑客的案例。即使书中提到的很多方法，在今天看来已经是司空见惯的做法，但是在当时，想到和高效执行那些想法，是非常了不起的举措。&lt;/p&gt;

&lt;p&gt;想实现产品或用户增长，需要的是开放的想象力、敏锐的思维和大胆高效的执行，绝不是看了《增长黑客》照搬几个例子就可以实现的。但我还是觉得书中例子很多很丰富，极大的拓宽了我的思维，因此决定写这篇主要内容是书摘的文章，一方面看第二遍可以让我加深印象，另一方面是之后回顾该书内容时，可以快速的找到核心重点。&lt;/p&gt;

&lt;p&gt;本文适合的读者：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读过《增长黑客》的朋友。可以当做重新温习一遍。&lt;/li&gt;
&lt;li&gt;还未有时间读《增长黑客》的朋友，可看此文快速了解该书的主要内容。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再次声明，以下内容主要是根据我的个人喜好，从《增长黑客》一书中摘录，经过我的归纳总结提炼出来的内容，只有少部分是个人的观点和想法。如果你看了有感觉，请支持原著《增长黑客》。&lt;/p&gt;

&lt;p&gt;以下主要是书摘：&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;什么是“增长黑客”？&lt;/p&gt;

&lt;p&gt;增长黑客说法源于硅谷，最早在2010年由Qualaroo的创始人兼CEO肖恩·埃利斯（Sean Ellis）提出，真正引起广泛关注是因为安德鲁·陈（Anrew Chen）在2014年发表的《&lt;a href=&#34;http://andrewchen.co/2012/04/27/how-to-be-a-growth-hacker-an-airbnbcraigslist-case-study/&#34;&gt;Growth Hacker is the new VP Marketing&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;这是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。他们通常既了解技术，又深谙用户心理，擅长发挥创意、绕过限制，通过低成本的手段解决初创公司产品早期的增长问题。&lt;strong&gt;在外行人眼里，他们就像是极客、发明家和广告狂人的混合体。&lt;/strong&gt;再通俗一点形容，他们的职责接近于专门为初创公司设立的市场推广部门，因为很少有用于营销的大笔经费， 所以更多的是将注意力聚焦在产品策略本身带来的自发增长上。&lt;/p&gt;

&lt;h2 id=&#34;growth-hacker:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Growth Hacker&lt;/h2&gt;

&lt;h3 id=&#34;timothy-c-draper:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Timothy C. Draper&lt;/h3&gt;

&lt;p&gt;Hotmail上线时，Timothy C. Draper给Hotmail两位创始人Sabeer Bhatia和Jack Smith建议在&lt;strong&gt;邮件底部打广告：“附言：我爱你，你可以到Hotmail获得免费电子邮箱”&lt;/strong&gt;。最后广告内容简化成“你可以到Hotmail注册免费电子邮件”。随后促成了产品的几何级数传播。&lt;/p&gt;

&lt;p&gt;这一改动几小时后，新注册用户以每天3000个增长，六个月内斩获100万用户，仅五周后，又获得100万用户，一年半后出售给微软时已经达到了1200万。&lt;/p&gt;

&lt;h3 id=&#34;安迪-琼斯:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;安迪·琼斯&lt;/h3&gt;

&lt;p&gt;安迪·琼斯（Andy Johns）是硅谷富有经验的增长黑客，曾效力于Facebook、Twitter、Quora等公司的增长部门。&lt;/p&gt;

&lt;p&gt;2008年，Facebook，接到任务，12个月获得2亿新用户。主要方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提供Facebook博客小挂件，用户可以把小挂件放在自己的公共主页或博客上，对外展示炫耀。带来了十亿次展示量，千万次点击量和百万级的注册量。&lt;/li&gt;
&lt;li&gt;收购一批第三世界的国家的通讯录服务提供商。以此获得潜在用户的Email地址，对其精准广告推送。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2008年5月，Facebook全球独立访问用户首次超过MySpace。&lt;/p&gt;

&lt;p&gt;安迪总结的方法论：数据分析、用户获取（SEO、PPC、电子邮件广告）、产品研发、文化建设、人才招聘。&lt;/p&gt;

&lt;p&gt;2010年加入Twitter，组建25人的用户增长团队。主要方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;改造首页，突出登录注册区域。砍掉热门微博和搜索框，减少用户头像显示面积，简化文案，登录注册区域占据整个页面的三分之一。24小时内用户注册率提升了约250%。&lt;/li&gt;
&lt;li&gt;每当新用户注册，立即推荐关注至少10个用户。让用户有东西可看，活跃和留存得到提高。&lt;/li&gt;
&lt;li&gt;开发和优化邮件自动发送功能。提高了单位时间发送的数量，每当用户获得粉丝、被转发收藏能第一时间收到邮件提醒。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在所有措施的运转下，两年间，Twitter的活跃用户数量由1亿增长到5亿。&lt;/p&gt;

&lt;p&gt;2011年末，加入问答社区Quora。主要琢磨用户的行为模式，并将之归纳为一套“标准动作”，然后引导其他用户去执行这套标准动作。如完善个人信息，关注感兴趣的行业领袖。&lt;/p&gt;

&lt;p&gt;从安迪身上看出的增长黑客的特质：数据为王、专注目标、关注细节、富于创意、信息通透。&lt;/p&gt;

&lt;h2 id=&#34;数据为王:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;数据为王&lt;/h2&gt;

&lt;p&gt;不同产品的核心数据指标是不一样的。比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;eBay的核心指标是商品价值量和eBay网站上的活跃卖家在全球电商平台的占比。&lt;/li&gt;
&lt;li&gt;Facebook的核心指标是月活跃用户数。&lt;/li&gt;
&lt;li&gt;MySpace、Compact更关注注册用户数。&lt;/li&gt;
&lt;li&gt;WhatsApp创始人简（Jan）从来只对外公布发送消息的数量。&lt;/li&gt;
&lt;li&gt;陌陌对活跃用户的定义是“登录成功并提交地理位置一次”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据分析，保证数据来源正确的前提下，做定性和定量分析。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;了解微信公众号订阅者画像，推送适合的内容。&lt;/li&gt;
&lt;li&gt;根据统计分析“免费注册”比“立即注册”点击率高30%。&lt;/li&gt;
&lt;li&gt;某日在线订餐网站数据量猛升，猜测是否与天气阴雨，用户不愿出门有关。&lt;/li&gt;
&lt;li&gt;电商网站婴儿车销量增加，奶粉销量也会相应同步增加。（经典的啤酒和尿布的销售案例）&lt;/li&gt;
&lt;li&gt;某天LinkedIn发现来自雷曼公司的访问量骤升，结果第二天雷曼公司就宣布破产倒闭。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;增长黑客工具箱:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;增长黑客工具箱&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.google.com/analytics/&#34;&gt;Google Analytics&lt;/a&gt;（百度统计、CNZZ统计）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mixpanel.com/&#34;&gt;Mixpanel&lt;/a&gt; 用户行为分析&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kissmetrics.com/&#34;&gt;KissMetrics&lt;/a&gt; 用户行为分析&lt;/li&gt;
&lt;li&gt;UserCycle 用户分组实验&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://customer.io/&#34;&gt;Customer.io&lt;/a&gt; 基于用户不同行为发送不同的邮件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.optimizely.com/&#34;&gt;Optimize.ly&lt;/a&gt;（Unbouce）A/B测试利器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://basecamp.com/&#34;&gt;Basecamp&lt;/a&gt; 37signals旗下的项目管理软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.umeng.com/&#34;&gt;友盟&lt;/a&gt; 国内最大的移动应用统计分析平台之一&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;创造正确的产品:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;创造正确的产品&lt;/h2&gt;

&lt;p&gt;凯文·斯特罗姆（Kevin Systrom）开发的基于地理位置服务的签到抢地盘应用Burbn未见起色，发现用户只喜欢使用Burbn的照片分享功能，于是调转方向，孤注一掷只做照片分享，一个月后吸引了100万用户，仅创立551天后，于2012年4月以10亿美元天价被Facebook收购。这就是照片分享社区Instagram。&lt;/p&gt;

&lt;p&gt;美国市场研究公司CB Insights通过分析101家科技创业公司的失败案例，总结出了创业失败的20大主要原因，其中“没有市场需求”以42％的绝对占比成为首要因素。&lt;/p&gt;

&lt;p&gt;足迹仅靠“大片”效果滤镜，让它火爆了一把。美国版大众点评Yelp在2004年创立之初旨在提供基于电子邮件的交友服务，结果发现用户乐于给商家写点评，于是转型成“商户黄页”。YouTube在2005年创立时只是聚焦在视频约会这一小众市场，当发现流量增长难以继后，改旗易帜成在线视频分享。Flickr曾是一款失败的在线角色扮演游戏的衍生产品。Flickr创始人在之后另一款游戏创业失败后，鬼使神差的在该项目上孵化出了在线协作工具Slack。&lt;/p&gt;

&lt;p&gt;QQ在创业早期从事网络寻呼机业务，在寻呼机市场江河日下时，马化腾一度想以60万的价格出售。百度在成为中国最大的独立搜索引擎之前，曾甘居幕后为其他门户网站提供搜索技术。盛大网络在依靠网络游戏发家致富前，做的是网络虚拟社区“史丹莫”。从百团大战到化妆品限时特卖的聚美优品。从独立论坛系统转型为页游公司的动网。从视频网站转型为在线直播平台的六间房。网络聊天室转型为棋牌游戏的博雅互动。坐拥1亿用户的VeryCD转型“心动游戏”。&lt;/p&gt;

&lt;p&gt;Gmail团队曾经进行过一次名为“你不是用户”的内部演示，援引大量用户数据阐释产品团队 做出每一项决策的具体援引：之所以去除某些功能，是因为大多数Gmail用户没有相关需求，从来都不使用它们。&lt;/p&gt;

&lt;p&gt;QQ邮箱的产品人员曾做了一个特性：将用户收到的所有邮件的附件单列出来，显示在一处。结果发现用户根本没有这样的需求。&lt;/p&gt;

&lt;p&gt;雷军称创业“就是要做最肥的市场”。他投资的YY最早是游戏门户，但雷军觉得最多只值1亿美金，劝李学凌改做直播平台，结果一炮打响。&lt;/p&gt;

&lt;h3 id=&#34;mvp:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;MVP&lt;/h3&gt;

&lt;p&gt;精益创业是指开发团队通过提供最小化可行产品（MVP）获取用户反馈，在此基础上持续快速 迭代（或谋求转型），直至产品达到PMF阶段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dropbox：在Digg.com上发布虚构的Dropbox产品功能，引发大量用户兴趣，最终诞生Dropbox。&lt;/li&gt;
&lt;li&gt;Groupon：最早使用WordPress搭建，手工制作商品礼券。&lt;/li&gt;
&lt;li&gt;Zappos：鞋类电商平台，最早并没有自己的仓库和物流基地，只是跑到隔壁鞋店拍摄一批照片，有人下单再去买回来。&lt;/li&gt;
&lt;li&gt;大众点评：初期手工添加1000家饭店，验证用户是否愿意点评。&lt;/li&gt;
&lt;li&gt;Hyperlapse：延时摄影应用，功能极简，三步完成。&lt;/li&gt;
&lt;li&gt;微信游戏：为快速验证游戏策划是否可行，制作人和策划用“暴力拼图法”感受最终效果，一旦方案不可行便“尽快放弃，不再纠结”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于微信公众平台的MVP策略，开发周期短、成本低、无需适配、分发方便、便于收集反馈、数据得以沉淀。（示例：女神进化史、悠泊）&lt;/p&gt;

&lt;h2 id=&#34;获取用户:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;获取用户&lt;/h2&gt;

&lt;p&gt;微信的张小龙曾经说过：如果你不了解女性，你将失去一半以上的用户（在他的推荐书单中包含《女性的起源》这样专门从进化学角度探讨女性的著作）。&lt;/p&gt;

&lt;h3 id=&#34;筛选种子用户:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;筛选种子用户&lt;/h3&gt;

&lt;p&gt;Facebook这家起源于哈佛大学校园的全球最大社交网站，在上线之初仅对常青藤大学的学生开放，随后逐渐向附近学校乃至全美、全世界拓展。这一聪明的策略帮助其在初期积累了大量的高质量种子用户，也勾起了外部世界融入这个精英社交圈的兴趣，为日后向普罗大众扩张奠定了牢靠的基础。&lt;/p&gt;

&lt;p&gt;知乎早期走的是精英路线。它采用了严格的邀请和审核机制，李开复、徐小平、雷军等互联网 大佬和一批投资圈、媒体圈的从业者成为了它的种子用户。这从根源上奠定了知乎的调性，也它 在圈内迅速成为话题产品，一码难求。有幸受邀加入知乎的用户们谨言慎行，创造了一批高质量 的内容。&lt;/p&gt;

&lt;p&gt;动漫爱好者的聚集地——哔哩哔哩弹幕视频网为了过滤出高质量的早期内容贡献者，维持社区 的健康生态，采用了一套答题机制来拦截不够“ 资深”的动漫爱好者。&lt;/p&gt;

&lt;p&gt;小米从竞品的网站精心筛选并主动邀请一批人成为MIUI的第一批种子用户。&lt;/p&gt;

&lt;p&gt;要警惕“产品蝗虫”。产品早期的用户不都是“种子用户”。&lt;/p&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;聚美优品创始人在办公室搭起“摄影棚”，给化妆品拍照，然后精心修图以吸引女性的注意。&lt;/li&gt;
&lt;li&gt;Strikingly创始人David Chen在Facebook上添加了2000名好友，邀请用户出来喝茶，成为生活中的挚友，甚至在外出演讲时住在了用户家里。&lt;/li&gt;
&lt;li&gt;网易云笔记首先拉来公司内部50个员工高强度使用，不断提需求和反馈问题。然后通过邀请审核逐渐扩大种子用户。&lt;/li&gt;
&lt;li&gt;Airbnb在2009年时每周营收仅200美元，创始人一一查阅网站上的配图，发现那些随便用手机拍出来的照片毫无吸引力，于是租了一个昂贵的相机，挨家挨户上门帮房东拍照。一周后效果立竿见影。&lt;/li&gt;
&lt;li&gt;利用社交网络获取海量用户（开心农场、Zynga、啪啪、唱吧、抬杠、美拍）。啪啪从一开始就未提供独立账号注册登录功能，必须使用新浪微博和QQ登录，使得更容易分享到社交平台。&lt;/li&gt;
&lt;li&gt;在合法的前提下，通过数据抓取“借鸡生蛋”。比如Windows Live Space准备关闭时，网易博客通过RSS抓取，提供了“一键搬家”功能。（作者自己的“追TA”的例子，即在网络上抓取用户头像来模仿真实用户，感觉有侵权嫌疑啊。）&lt;/li&gt;
&lt;li&gt;通过内容营销：吸引流量、培养潜在用户、劝诱转化。撰写耸动的标题，Upworthy总结出的标题技巧包括：不要在标题里透露全部内容、抛出疑问而不是总结陈词、 反复修改直到满意等。&lt;/li&gt;
&lt;li&gt;KISSmetrics的联合创始人尼尔· 帕特尔（Neil Patel）发布的一项针对Google搜索排名与被 收录文章长度关系的调查数据显示，一般排在前十名的文章需要包括至少2000个单词。病毒内容提供商Buzzsumo的调查结果与KISSmetrics近似，他们认为文章篇幅在3000字至10000字的范围内 最容易获得人们的主动分享。&lt;/li&gt;
&lt;li&gt;搜索引擎优化（SEO）和应用商店优化（ASO）。SEO主要有提供sitemap、标注关键词、增加反向链接（通过维基百科）等手段。ASO主要有通过副标题堆关键词（如：大姨吗），引导高满意度用户为应用评分，在用户需求得到满足、感受到成功喜悦时提醒用户去评分。&lt;/li&gt;
&lt;li&gt;捆绑下载，比如豌豆荚、百度应用市场，搜索应用时，先下载的是一个市场APK，然后再下到搜索的软件。（有点流氓手段）&lt;/li&gt;
&lt;li&gt;Mailbox利用排队玩“饥饿营销”，Robinhood甚至提供了“插队”功能，用户只需要发布邀请链接到社交网络就能插队。Track.io甚至更加极端，在技术上无法解决性能问题的情况下，提供付费免除排队功能，找到“有迫切需要的用户”，从而使得项目起死回生。&lt;/li&gt;
&lt;li&gt;利用嵌入式代码和小挂件让你的品牌无处不在。比如：YouTube和Gleam。&lt;/li&gt;
&lt;li&gt;从线上到线下。打车软件Uber最早在旧金山低调推出，因为当地糟糕的出租车打车体验和经常下雨的环境使其迅速得到青睐。手机约会应用Tinder渗透到洛杉矶派对圈，拉拢大批年轻貌美的长期在线用户。&lt;/li&gt;
&lt;li&gt;走向海外。（Facebook、触宝、猎豹）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;激发活跃:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;激发活跃&lt;/h2&gt;

&lt;p&gt;A/B测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LinkedIn通过A/B测试，确定了新注册用户愿意邀请的用户数量定在了“4”个魔法数字。&lt;/li&gt;
&lt;li&gt;Airbnb曾测试过把“保存到心愿单”的收藏图标由星形改为爱心，结果仅凭这一改动就让心愿列表的使用率提升了30％。&lt;/li&gt;
&lt;li&gt;移动端通过下发HTML5执行A/B测试（百姓网）&lt;/li&gt;
&lt;li&gt;A/B测试的结果也要理性对待。百姓网通过A/B测试发现将“拨打电话”改成“投递简历”后，点击率并没有下降。后来却收到很多用户反馈“为什么不能直接拨打电话”，因为用户需要打电话，在不得已情况下才点了投递简历。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诱饵效应，影响用户决策：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tinder交友应用的产品团队发现，当配对异性照片界面上面只有一个“喜欢”按钮时，平均每天点击数为7000次。而在旁边增加一个“不喜欢”按钮后，“喜欢”的点击数达到12000次左右。&lt;/li&gt;
&lt;li&gt;迅雷在引导用户升级“VIP尊享版”时，仅有一个“华丽地变身”比旁边加一个“残忍地拒绝”点击率低了20%。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;游戏改变世界：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;星巴克的会员成长体系（星成就、徽章、亲友券、邀请券）。比如要获得名为“晨型人”的徽章，必须完成五次9: 00之前的门店签到。&lt;/li&gt;
&lt;li&gt;Foursquare的游戏化策略：积分排名、徽章挑战、抢夺地主。&lt;/li&gt;
&lt;li&gt;滴滴打车的“滴米”激励系统，根据这一单的难易程度增减滴米。&lt;/li&gt;
&lt;li&gt;百度贴吧的签到、QQ会员的钻石点亮和VIP成长体系。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;机器人模拟用户&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Quora早期面临内容少质量差的问题时，采取了员工自问自答的方法，通过机器人来模拟用户问答。&lt;/li&gt;
&lt;li&gt;很有网络游戏里看到在线玩家，实际上执行AI的机器人。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;提高留存:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;提高留存&lt;/h2&gt;

&lt;p&gt;根据美国贝恩公司的调查，在商业社会中5％的客户留存率增长意味着公司利润30％的增长，而 把产品卖给老客户的概率是卖给新客户的3倍。所以在“增长黑客”圈内有一句名言：留住已有的 用户胜过拓展新的客户。&lt;/p&gt;

&lt;h3 id=&#34;留存率:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;留存率&lt;/h3&gt;

&lt;p&gt;衡量产品留存率的常用指标包括次日留存率、7日留存（周留存）率、30日留存（月留存）率，其计算公式为：第1天的新增用户中，在往后的第N天依然在使用的用户数/第1天的新增用户数。其中的N对应的就是留存指标中代表天数的2、7或30。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次日留存率：可于第一时间发现产品新版本的品质变动和渠道优劣。&lt;/li&gt;
&lt;li&gt;7日留存率：可反映出用户完成一个完整体验周期后的去留状况。&lt;/li&gt;
&lt;li&gt;30日留存率：更能反映出一次版本迭代后的稳定性，辅助判断产品的演进方向是否合理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;渠道留存也是一项值得钻研玩味的指标。由于渠道来源不一，用户质量也千差万别，所以有必要针对渠道用户单独剥离进行留存率分析，选择留存率较高的优质渠道进行重点投放。&lt;/p&gt;

&lt;p&gt;提高留存率的方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;优化产品性能。（加快打开速度、减少电池消耗、提升弱网络下的体验）&lt;/li&gt;
&lt;li&gt;有损服务，放下不必要的坚持。微信逢年过节时服务器压力巨大，因此放弃了微信群里的群聊信息先后一致性的严格要求。小米抢购排队时，放弃了精确的排队数量，而是模糊的“仅剩5万部”。手游《刀塔传奇》每逢大版本更新时，尽量先使用“低清版”资源，虽然视觉效果不够细腻，但能让玩家尽快先玩起来。&lt;/li&gt;
&lt;li&gt;引导新用户快速上手。如Twitter在新注册后会自动推荐关注5到10人，让用户的时间线有内容可读。&lt;/li&gt;
&lt;li&gt;社交维系和社交解绑。微信游戏“全民飞机大战”提供“合体”功能，选择一名微信或QQ好友帮助自己。玩家因“求合体”被召回，发现“躺着赚钱”坐收了合体奖励，可能重新被激活。Facebook在用户有冲动注销账号时，确认环节最后一步，页面会显示几名和用户关系最亲密的好友的照片，并可怜巴巴的说“他们会想念你的”。这一设计，使得Facebook的非活跃账户数降低了7%，相当于100万用户量。社交解绑的例子：Same。&lt;/li&gt;
&lt;li&gt;设计唤醒机制：电子邮件唤醒、消息推送、网页内唤醒移动应用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;增加收入:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;增加收入&lt;/h2&gt;

&lt;p&gt;免费模式大行其道的原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互联网极大地降低了信息的传播成本，这是免费模式的基石所在。&lt;/li&gt;
&lt;li&gt;产品通过互联网面向全球的海量用户，这进一步摊薄了边际成本。&lt;/li&gt;
&lt;li&gt;“ 免费”天然地对人们有着难以抗拒的魅力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;免费模式如何赚钱：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本功能免费，高级功能收费的Freemium策略。&lt;/li&gt;
&lt;li&gt;交叉补贴。如：吉列剃须刀的刀身免费刀头收费。&lt;/li&gt;
&lt;li&gt;三方市场流量变现。如：陌陌导流到自家（陌陌争霸）或合作伙伴的游戏成为一大盈利来源。&lt;/li&gt;
&lt;li&gt;开源接受捐赠，或者提供定制开发及文档收费。如：RootTools。&lt;/li&gt;
&lt;li&gt;公司上市或被收购。如：优酷上市。最新新闻又被阿里收购。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;天下没有免费的午餐。通过取消免费账户，收入获得大幅提升。如：设计师网页服务Bidesketch、网站分析服务CrazyEgg、财务软件LessAccounting。&lt;/p&gt;

&lt;p&gt;重定向广告，追踪消费者曾经搜过或打开的网页。比如在淘宝或京东搜过某个商品，在访问别的网站时，依然显示刚刚搜过的商品广告，让犹豫不决的用户点击过去直接下单。&lt;/p&gt;

&lt;p&gt;变惩为奖，堵不如疏。2011年，有网友发现了腾讯QQ会员的技术漏洞，公然在淘宝上以1元钱的价格挂出了“QQ会员点灯”业务。腾讯在修复漏洞后，并未对用户进行惩罚，反而给这部分用户提供八折的优惠折扣，将他们转化为真正的QQ会员。（同理，作者使用的CleanMyMac由破解转正版的优惠）&lt;/p&gt;

&lt;p&gt;建立商业智能系统，精细化管理业绩指标。（百姓网）&lt;/p&gt;

&lt;h2 id=&#34;病毒传播:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;病毒传播&lt;/h2&gt;

&lt;p&gt;凯文·凯利在1998年出版《新经济，新规则》一书中提出了大名鼎鼎的“传真机效应”：单独一台传真机是没有什么价值的，只有它处于一个网络中时才能被赋予价值。对于拥有一台传真机的人而言，网络中中的传真机越多，你的传真机价值也就越大。&lt;/p&gt;

&lt;p&gt;去中心化：人人都是节点，传播的效果能够以几何级数倍增。&lt;/p&gt;

&lt;p&gt;衡量病毒传播的两大核心指标是K因子（K Factor）和病毒循环周期（Virial Cycle Time）。K因子＝感染率 X 转化率。病毒循环周期，是指从用户发出病毒邀请，到新用户完成转化（如点击阅读、注册、消费的行为）所花费的时间。&lt;/p&gt;

&lt;p&gt;坏事传千里，Bug营销：百度云网盘支付BUG（只需要1/1000价格）、迅雷支付Bug（1分钱买180元白金年卡）。&lt;/p&gt;

&lt;p&gt;借势营销，如12306抢票插件、SegmentFault举行的“光棍节程序员闯关秀”。&lt;/p&gt;

&lt;p&gt;产品体外的病毒循环：朋友圈小游戏。如“围住神经猫”、“整蛊”、“财务包子铺”及各种小测试。&lt;/p&gt;

&lt;p&gt;产品体内的病毒循环：通过推荐好友解锁功能（AirDroid）、美图秀秀各种“趣味活动”（如“测试与明星的撞脸程度”）分享、百度魔图的“PK大咖”（上传照片，自动告诉你和哪位明星最像）。&lt;/p&gt;

&lt;p&gt;病毒传播中的用户心理把控：喜爱、逐利、互惠、求助、炫耀、稀缺、害怕失去或错过、懒惰。&lt;/p&gt;

&lt;p&gt;作者的实践：云诺网盘通过用户点击获得无限容量的活动营销。&lt;/p&gt;

&lt;h2 id=&#34;实例:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;实例&lt;/h2&gt;

&lt;h3 id=&#34;airbnb:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Airbnb&lt;/h3&gt;

&lt;p&gt;2007年，住在美国旧金山的两位设计师——布莱恩·彻斯基（Brian Chesky）与乔伊·杰比亚（Joe Gebbia）正在为他们付不起房租而困扰。为了赚点外快，他们计划将阁楼出租出去。传统 的做法是在Craigslist网站发帖子。“但我们不想这么干，因为在Craigslist发千篇一律的帖子会显得冷冰冰的，于是我们打算自己动手建一个网站Airbed&amp;amp;Breakfast。”&lt;/p&gt;

&lt;p&gt;如今，Airbed&amp;amp;Breakfast已经摇身一变成为享誉全球的“共享经济”代表性服务：Airbnb。&lt;/p&gt;

&lt;p&gt;早期两位创始人曾在美国大选时卖麦片来筹集资金，因此受到与硅谷创业教父保罗·格雷厄姆（Paul Graham）青睐。&lt;/p&gt;

&lt;p&gt;格雷厄姆事后承认，“这群甚至可以靠卖麦片来挣取收入的人，他们的项目死不了”。&lt;/p&gt;

&lt;p&gt;Airbnb实现用户增长的秘诀：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;挖竞争对手的用户。租房信息提供同步发送到竞争对手Craigslist网站、在Craigslist上模拟客户给屋主留言推荐Airbnb。&lt;/li&gt;
&lt;li&gt;5000美金租借高档相机挨家挨户给招租者的房屋拍照。后签约专业摄影师成立项目组，专门给房东提供拍摄服务。&lt;/li&gt;
&lt;li&gt;打通社交关系链。让屋主和租客信息更透明，解决基本的人与人的信任问题。&lt;/li&gt;
&lt;li&gt;“心愿列表”将星形改成心形，用户使用率提升了30%。&lt;/li&gt;
&lt;li&gt;拥抱移动设备。&lt;/li&gt;
&lt;li&gt;推广时，通过A/B测试发现，“邀请好友可以获得25美元”的效果就不如“向你的好友赠送25美元旅行经费”更打动人。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（Tinder、Github、美丽说、外卖库的例子见原书）&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于开源的思考</title>
            <link>http://blog.coderzh.com/2015/10/11/open-source-thinking/</link>
            <pubDate>Sun, 11 Oct 2015 17:17:19 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/11/open-source-thinking/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/OpenSource.png-wt&#34; alt=&#34;OpenSource&#34; /&gt;&lt;/p&gt;

&lt;p&gt;程序员是一个热衷于开放、分享、协作的群体。他们将有创造力的代码公开分享，供大家审阅、评判、学习和使用，他们接受用户的意见，欢迎一切用户提交的PR改进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源是需要勇气的。&lt;/strong&gt;用户会用脚投票，依赖混乱、晦涩难懂、风格糟糕的代码会被用户所遗弃。代码也是要看脸的，选择开源意味着需要把自己最美的部分展示。如果一个项目一开始就是开源的，在代码编写过程中肯定会格外注意。根据以往的经验，那些表面光鲜的商业软件，内部的代码往往都是混乱不堪，难以示众的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源不仅仅是把代码公开。&lt;/strong&gt;如果仅仅将代码公开就算开源的话，那和真正的开源离的十万八千里呢。开放源代码只是第一步，后续的社区建设，吸引开发者或用户一起来共同参与，形成社区化的协作模式，将开源社区这个轮子滚动起来才是关键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源的协作模式是高效的。&lt;/strong&gt;一个出色的开源项目，可以吸引到全世界出色的程序员，他们大都基于爱好或使用需要，无偿贡献自己的代码。当然，最宝贵的是他们付出的时间。他们往往是在业余时间参与开源项目。在GitHub上，不同时区的人们通过Pull Request的方式跟进和推动项目前进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源需要对代码质量提出更高的要求。&lt;/strong&gt;通过Pull Rquest机制提交的代码，天然需要经过项目维护者的CodeReview才能合入的。在提PR时，需要让代码尽量的整洁，注释规范，有的项目还要求你通过squash合并成1次commit再提交。最后，最重要的环节是给修改的代码补充单元测试案例，保证测试案例是通过的。GitHub提供了这一整套流程的跟踪协作方式，所以程序员们对GitHub如此的爱不释手。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参与开源是一种极好的学习方式。&lt;/strong&gt;如果还没机会自己创建和维护一个好的开源项目，参与到别人的开源项目中会是一个很好的学习提高的方式。你可以看到牛人的代码是怎么写的，然后偷偷记下来。最好的方式是参与其中，不一定需要你贡献多少有价值的代码，也许一个简单的文档内容修改，也能拉近你和牛人之间的距离。当你对代码有一定的熟悉，你就可以打开Issue列表，看看有哪些问题你可以大展拳脚了。一旦你这么做了，相信对你的帮助是巨大的。这也是我近期的深刻体会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码不需要藏着掖着，用户资源和核心数据才是。&lt;/strong&gt;Facebook大多代码都是直接开源的，给社区贡献了大量高质量的开源代码。对他们来说，选择完全开放，吸引更多的开发者参与其中，只要将用户核心数据和平台资源掌握在手里，这个雪球是可以越滚越大的。这就如同RSA算法，加解密的算法是完全公开的，只要你保证了私钥不被泄露，其他的东西全部公开都是安全的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源并不意味着免费，也许还能赚到钱。&lt;/strong&gt;很多程序员参与开源并不是为了赚钱，有的纯粹是爱好，有的是自我价值的实现。随着开源项目越来越大，越来越多人参与，需要参与维护和打理的时间就会变多，甚至有的人会全职来做这个。他们可以通过商业授权、培训咨询、捐赠等方式获得收入。只要认真经营，机会就会自己找上门来。&lt;/p&gt;

&lt;h3 id=&#34;我的切身体会:3583956c9bd42a05e9ead1f80dfc8eab&#34;&gt;我的切身体会&lt;/h3&gt;

&lt;p&gt;很早前我也经常丢一些代码到google code，正如前面所说的，这离真正的开源差的很远。因为我只是把代码一丢，然后就不管不顾了，渐渐下来，代码愈加的鲜人问津。对于别人的开源代码，我也基本是拿来主义。&lt;/p&gt;

&lt;p&gt;今年开始真正的参与到GitHub中去，其中之一就是Hugo静态网站生成器项目。由于对Go语言感兴趣，本着边学边用的态度，尝试给Hugo提了第一个PR，Hugo的维护者@bep和@anthonyfok都非常Nice，整个过程非常舒服和顺畅，随之我又陆续提了几个PR。&lt;/p&gt;

&lt;p&gt;下面是我给Hugo贡献的几个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add config option &amp;ldquo;disablePathToLower&amp;rdquo; &lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;#1392&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WordCount and Summary support CJK Language &lt;a href=&#34;https://github.com/spf13/hugo/pull/1399&#34;&gt;#1399&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hugo import from Jekyll &lt;a href=&#34;https://github.com/spf13/hugo/pull/1469&#34;&gt;#1469&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的链接可以追溯每次代码提交的详细过程。有的经过了反复讨论和反复修改，大家身处世界各地，时差不同。每天一早起来就可以看到他们给出的反馈。在讨论的过程中，可以看到别人对同一个问题的思考，互相交流，也学习到很多东西。&lt;/p&gt;

&lt;p&gt;Hugo的作者spf13(Steve Francia)可是一个牛人。spf13是大名鼎鼎的开源项目Docker和MongoDB的Chief Operator，另外他还是spf13-vim, Hugo, Cobra &amp;amp; Viper等开源项目的作者。能和这样的牛人交流学习，是一种不错的体验。他的博客地址：&lt;a href=&#34;http://spf13.com&#34;&gt;http://spf13.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国庆在家给Hugo提了一个不大也不小的功能。就是上面的第三点：Hugo import from Jekyll。给Hugo提供了内置的import命令，将原来的Jekyll博客一键导入到Hugo来。这次提交的代码加上测试案例，有近600行，也算一个不小而且非常有用的改动了。详细介绍见上一篇博客：&lt;a href=&#34;http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/&#34;&gt;使用Hugo Import一键迁移Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过hugo import功能刷了近600行代码之后，我在Hugo的贡献者列表里可以看到，已经一共刷了近千行代码了，算上删除的话。：）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-coderzh.png-ws&#34; alt=&#34;hugo-coderzh&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于时区和远程协作的关系，GitHub上协作时有时候需要等待，但我依然认为这是一种非常高效的协作方式。因为社区的力量是强大的，在大量社区用户的推动之下，项目每天都在改进，每天都在向更好的方向推动和前进，这才是项目保持长久活力的重要根本。&lt;/p&gt;

&lt;p&gt;关于开源，我还会继续下去，参与和发掘更多更好玩的东西。也欢迎访问我的GitHub和博客，和我交流，谢谢！&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&#34;https://github.com/coderzh&#34;&gt;https://github.com/coderzh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用Hugo Import一键迁移Jekyll</title>
            <link>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</link>
            <pubDate>Sun, 11 Oct 2015 10:06:11 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoImportJekyll.png-wt&#34; alt=&#34;HugoImportJekyll&#34; /&gt;&lt;/p&gt;

&lt;p&gt;国庆长假期间，给Hugo提了几个PR，其中最主要的一个是给Hugo增加了内置的Jekyll迁移工具。这样之前的Jekyll用户可以通过一个简单的命令就可以将网站转化成Hugo站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll your-jekyll-dir target-dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得益于Hugo代码可读性非常好，原来计划需要几天来完成的功能1天左右的时间就完成了。完整的PR过程请见：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1469&#34;&gt;https://github.com/spf13/hugo/pull/1469&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo-import:9d9792e5f5806aca19497d8888e47a21&#34;&gt;Hugo Import&lt;/h3&gt;

&lt;p&gt;主要实现了将原来的Jeklly网站一键转换为Hugo网站，具体实现了如下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成新的Hugo站点结构。(hugo new site)&lt;/li&gt;
&lt;li&gt;读取Jeklly的_config.yml，相应内容转化到Hugo的config.yaml。&lt;/li&gt;
&lt;li&gt;转换所有MarkDown的文章。（具体转换规则见下文）&lt;/li&gt;
&lt;li&gt;拷贝Jekyll其他目录及文件到Hugo的static目录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;@bep在他的OS X上做了一些测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll qrush.github.com qr2
  Importing...
  Congratulations! 72 posts imported!
  Now, start Hugo by yourself:
  $ git clone https://github.com/spf13/herring-cove.git qr2/themes/herring-cove
  $ cd qr2
  $ hugo server -w --theme=herring-cove
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;markdown文章转换规则:9d9792e5f5806aca19497d8888e47a21&#34;&gt;MarkDown文章转换规则&lt;/h3&gt;

&lt;p&gt;Hugo和Jekyll都是使用MarkDown来写文章的，文章内容基本上是兼容的，除了一些FrontMatter的细节和局部细节。Hugo Import Jekyll主要的转换规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保持原Jekyll文章目录结构及文件名不变，将文章拷贝到了content/post目录下。&lt;/li&gt;
&lt;li&gt;尽量保持原Jekyll文章链接地址不变，在文章的FrontMatter自动填入url字段。&lt;/li&gt;
&lt;li&gt;date字段转换成Hugo要求的time.RFC3339格式。&lt;/li&gt;
&lt;li&gt;draft字段自动生成。&lt;/li&gt;
&lt;li&gt;删除layout字段。&lt;/li&gt;
&lt;li&gt;category字段转换成categories字段。&lt;/li&gt;
&lt;li&gt;excerpt_separator智能替换。(比如： &amp;lt;!--more--&amp;gt;)&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;{% raw %}{% endraw %}&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;替换&lt;code&gt;{% highlight %}{% endhighlight %}&lt;/code&gt;标签为 {{&amp;lt; highlight &amp;gt;}}{{&amp;lt; / highlight &amp;gt;}}&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;代码:9d9792e5f5806aca19497d8888e47a21&#34;&gt;代码&lt;/h3&gt;

&lt;p&gt;import.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;import_test.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import_test.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import_test.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我fork的Hugo Repo（我的最新改动都在这里）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/hugo&#34;&gt;https://github.com/coderzh/hugo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;最后:9d9792e5f5806aca19497d8888e47a21&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;这个功能将会在下个正式版推出，现在需要使用的同学自行pull最新的Hugo代码编译吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get -u -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;欢迎试用，并且提出意见或建议！谢谢！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go语言极速入门手册.go</title>
            <link>http://blog.coderzh.com/2015/09/28/go-tips/</link>
            <pubDate>Mon, 28 Sep 2015 22:43:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/28/go-tips/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/golang.jpg&#34; alt=&#34;golang&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/CodeTips&#34;&gt;https://github.com/coderzh/CodeTips&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
gotips_test.go:
  Golang速学速查速用代码手册

Source: github.com/coderzh/CodeTips/blob/master/gotips_test.go

Author: coderzh(github.com/coderzh)
Blog: http://blog.coderzh.com
参考：《Go语言编程》
*/

package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;math&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
    &amp;quot;regexp&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;testing&amp;quot;
    &amp;quot;time&amp;quot;
)

// 0. 注释
/*
规范：
 1. 命名：骆驼命名法（不要用下划线）

命令:
 go get github.com/coderzh/xxx
 go build calc
 go run xxx.go
 go install calc
*/

// 1. Hello World
func helloWorld() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}

// 2.变量类型
func typeDemo() {
    // 变量声明
    var v1 int
    var (
        v2 int
        v3 string
    )
    //var p *int // 指针类型

    // 变量初始化
    var v4 int = 10
    // 等价于:
    var v5 = 10
    // 一般这样就好
    v6 := 10

    // 赋值，多重赋值
    v1 = 10
    v2, v3 = 20, &amp;quot;test&amp;quot;
    // 匿名变量 _
    _, v4 = v5, v6

    fmt.Println(v1, v2, v3, v4)

    // 常量
    const Pi float64 = 3.1415926
    const MaxPlayer = 10

    // 枚举
    const (
        Sunday = iota // iota从0递增
        Mondy
        Tuesday
        // ...
    )

    // 类型
    // 1. 布尔
    var b1 bool
    b1 = true
    b1 = (1 == 2)

    fmt.Println(b1)

    // 2. 整形
    // int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint uintptr
    var i32 int32
    // 强制转换
    i32 = int32(64)
    // 运算：+, -, *, /, %（求余）
    // 比较：&amp;gt;, &amp;lt;, ==, &amp;gt;=, &amp;lt;=, !=
    // 位运算：x &amp;lt;&amp;lt; y, x &amp;gt;&amp;gt; y, x ^ y, x &amp;amp; y, x | y, ^x （取反）

    fmt.Println(i32)

    // 3. 浮点
    // float32, float64
    var f1 float64 = 1.0001
    var f2 float64 = 1.0002
    // 浮点比较
    isEqual := math.Dim(f1, f2) &amp;lt; 0.0001

    fmt.Println(isEqual)

    // 4. 字符串
    var s1 string
    s1 = &amp;quot;abc&amp;quot;
    // 字符串连接
    s1 = s1 + &amp;quot;ddd&amp;quot;
    // 取长度
    n := len(s1)
    // 取字符
    c1 := s1[0]
    // 反引号，不转义，常用于正则表达式
    s1 = `\w+`

    fmt.Println(c1)

    fmt.Println(strings.HasPrefix(&amp;quot;prefix&amp;quot;, &amp;quot;pre&amp;quot;)) // true
    fmt.Println(strings.HasSuffix(&amp;quot;suffix&amp;quot;, &amp;quot;fix&amp;quot;)) // true

    // 字节遍历
    for i := 0; i &amp;lt; n; i++ {
        ch := s1[i]
        fmt.Println(ch)
    }
    // Unicode字符遍历
    for i, ch := range s1 {
        fmt.Println(i, ch)
    }

    // 5. 数组
    var arr1 [32]int
    //var arr2 [3][8]int // 二维数组
    // 初始化
    arr1 = [32]int{0}
    array := [5]int{1, 2, 3, 4, 5}
    // 临时结构体数组
    structArray := []struct {
        name string
        age  int
    }{{&amp;quot;Tim&amp;quot;, 18}, {&amp;quot;Jim&amp;quot;, 20}}

    // 数组遍历
    for i := 0; i &amp;lt; len(array); i++ {
        fmt.Println(array[i])
    }
    for i, v := range structArray {
        fmt.Println(i, v)
    }
    // 数组是值类型，每次参数传递都是一份拷贝

    // 数组切片Slice
    var mySlice []int = arr1[:2]
    mySlice1 := make([]int, 5)
    mySlice2 := make([]int, 5, 10)

    fmt.Println(&amp;quot;len(mySlice2:&amp;quot;, len(mySlice2)) // 5
    fmt.Println(&amp;quot;cap(mySlice2:&amp;quot;, cap(mySlice2)) // 10

    mySlice3 := append(mySlice, 2, 3, 4)
    mySlice4 := append(mySlice, mySlice1...)

    copy(mySlice3, mySlice4)

    // 6. Map
    var m map[int]string
    m[1] = &amp;quot;ddd&amp;quot;
    m1 := make(map[int]string)
    m2 := map[int]string{
        1: &amp;quot;a&amp;quot;,
        2: &amp;quot;b&amp;quot;,
    }

    delete(m2, 1)

    value, ok := m1[1]
    if ok {
        fmt.Println(value)
    }

    for k, v := range m2 {
        fmt.Println(k, v)
    }

}

// 3. 流程控制
func flowDemo() {
    // if else
    a := 10
    if a &amp;lt; 10 {
        // ..
    } else {
        // ..
    }

    // switch
    switch a {
    case 0:
        fmt.Println(&amp;quot;0&amp;quot;)
    case 10:
        fmt.Println(&amp;quot;10&amp;quot;)
    default:
        fmt.Println(&amp;quot;default&amp;quot;)
    }

    switch {
    case a &amp;lt; 10:
        fmt.Println(&amp;quot;&amp;lt;10&amp;quot;)
    case a &amp;lt; 20:
        fmt.Println(&amp;quot;&amp;lt;20&amp;quot;)
    }

    // 循环
    for i := 0; i &amp;lt; 10; i++ {
    }
    // 无限循环
    sum := 0
    for {
        sum++
        if sum &amp;gt; 10 {
            break
            // 指定break
            // break JLoop
        }
    }

    goto JLoop

JLoop:
    // break to here

}

// 4. 函数
// func 函数名(参数列表)(返回值列表) {
// }
func sum1(value1 int, value2 int) (result int, err error) {
    // err = errors.New(&amp;quot;xxxx&amp;quot;)
    return value1 + value2, nil
}

func sum2(value1, value2 int) int {
    return value1 + value2
}

// 不定参数
// myFunc(1, 2, 3, 4, 5)
func myFunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
    // 传递
    // myFunc2(args...)
    // myFunc2(args[1:]...)
}

// 任意类型的不定参数
func myPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
        case int:
            fmt.Println(arg, &amp;quot;is int&amp;quot;)
        case string:
            fmt.Println(arg, &amp;quot;is string&amp;quot;)
        default:
            fmt.Println(arg, &amp;quot;is unknown&amp;quot;)
        }
    }
}

// 匿名函数
func anonymousFunc() {
    f := func(a, b int) int {
        return a + b
    }

    f(1, 2)
}

// defer
func deferDemo(path string) {
    f, err := os.Open(path)
    if err != nil {
        return
    }

    defer f.Close()
    // or
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf(&amp;quot;Runtime error caught: %v&amp;quot;, r)
        }
    }()
}

// 5. 结构体
type Rect struct {
    // 小写为private
    x, y float64
    // 大写为public
    Width, Height float64
}

// 大写方法为public，小写为private
func (r *Rect) Area() float64 {
    return r.Width * r.Height
}

func netRect(x, y, width, height float64) *Rect {
    // 实例化结构体
    // rect1 := new(Rect)
    // rect2 := &amp;amp;Rect{}
    // rect3 := &amp;amp;Rect{Width:100, Height:200}
    return &amp;amp;Rect{x, y, width, height}
}

// 匿名组合
type Base struct {
    Name string
}

func (base *Base) Foo() {}
func (base *Base) Bar() {}

type Foo struct {
    Base
    *log.Logger
}

func (foo *Foo) Bar() {
    foo.Base.Bar()
    // ...
}

// 非侵入式接口
type IFile interface {
    Read(buf []byte) (n int, err error)
    Write(buf []byte) (n int, err error)
}

type File struct {
}

func (file *File) Read(buf []byte) (n int, err error) {
    return 0, nil
}

func (file *File) Write(buf []byte) (n int, err error) {
    return 0, nil
}

func interfaceDemo() {
    // 只要实现了Read, Write方法即可
    var file IFile = new(File)

    // 接口查询
    // 是否实现了IFile接口
    if file2, ok := file.(IFile); ok {
        file2.Read([]byte{})
    }
    // 实例类型是否是File
    if file3, ok := file.(*File); ok {
        file3.Read([]byte{})
    }

    // 类型查询
    switch v := file.(type) {
    }
}

// 6. 并发编程
func counting(ch chan int) {
    ch &amp;lt;- 1
    fmt.Println(&amp;quot;counting&amp;quot;)
}

func channelDemo() {
    chs := make([]chan int, 10)
    for i := 0; i &amp;lt; len(chs); i++ {
        chs[i] = make(chan int)
        // 带缓冲区大小
        // c: = make(chan int, 1024)
        // for i:= range c {
        // }
        go counting(chs[i])
    }

    for _, ch := range chs {
        &amp;lt;-ch
        // channel select
        /*
            select {
            case &amp;lt;-ch:
                // ...
            case ch &amp;lt;- 1:
            }
        */
    }

    // 单向Channel
    var ch1 chan&amp;lt;- int // 只能写入int
    var ch2 &amp;lt;-chan int // 只能读出int

    // 关闭Channel
    close(ch1)
    _, ok := &amp;lt;-ch2
    if !ok {
        // already closed
    }
}

// 锁
var m sync.Mutex

func lockDemo() {
    m.Lock()
    // do something
    defer m.Unlock()
}

// 全局唯一操作
var once sync.Once

// once.Do(someFunction)

// 7. 网络编程
// import &amp;quot;net&amp;quot;
// net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8080&amp;quot;)

// 8. json处理
// import &amp;quot;encoding/json&amp;quot;
// json.Marshal(obj) 序列化
// json.Unmarshal() 反序列化

// 9. Web开发
// import &amp;quot;net/http&amp;quot;
// 模板
// import &amp;quot;html/template&amp;quot;

// 10. 常用库
// import &amp;quot;os&amp;quot;
// import &amp;quot;io&amp;quot;
// import &amp;quot;flag&amp;quot;
// import &amp;quot;strconv&amp;quot;
// import &amp;quot;crypto/sha1&amp;quot;
// import &amp;quot;crypto/md5&amp;quot;

// 11. 单元测试
// _test结尾的go文件： xxx_test.go
// 函数名以Test开头
func TestDemo(t *testing.T) {
    r := sum2(2, 3)
    if r != 5 {
        t.Errorf(&amp;quot;sum2(2, 3) failed. Got %d, expect 5.&amp;quot;, r)
    }

    assert.Equal(t, 1, 1)
}

// 12. 性能测试
func benchmarkAdd(b *testing.B) {
    b.StopTimer()
    // dosometing
    b.StartTimer()
}

/*
 其他常用的代码片段
*/

// 1. 遍历文件 filepath.Walk
// import &amp;quot;path/filepath&amp;quot;
func doHashWalk(dirPath string) error {

    fullPath, err := filepath.Abs(dirPath)

    if err != nil {
        return err
    }

    callback := func(path string, fi os.FileInfo, err error) error {
        return hashFile(fullPath, path, fi, err)
    }

    return filepath.Walk(fullPath, callback)
}

func hashFile(root string, path string, fi os.FileInfo, err error) error {
    if fi.IsDir() {
        return nil
    }
    rel, err := filepath.Rel(root, path)
    if err != nil {
        return err
    }
    log.Println(&amp;quot;hash rel:&amp;quot;, rel, &amp;quot;abs:&amp;quot;, path)
    return nil
}

// 2. 读取文件
// import &amp;quot;io/ioutil&amp;quot;
func readFileDemo(filename string) {
    content, err := ioutil.ReadFile(filename)
    if err != nil {
        //Do something
    }
    lines := strings.Split(string(content), &amp;quot;\n&amp;quot;)
    fmt.Println(&amp;quot;line count:&amp;quot;, len(lines))
}

// 判断目录或文件是否存在
func existsPathCheck(path string) (bool, error) {
    // 判断不存在
    if _, err := os.Stat(path); os.IsNotExist(err) {
        // 不存在
    }

    // 判断是否存在
    _, err := os.Stat(path)
    if err == nil {
        return true, nil
    }
    if os.IsNotExist(err) {
        return false, nil
    }
    return true, err
}

// 文件目录操作
func fileDirDemo() {
    // 级联创建目录
    os.MkdirAll(&amp;quot;/path/to/create&amp;quot;, 0777)
}

// 拷贝文件
func copyFile(source string, dest string) (err error) {
    sf, err := os.Open(source)
    if err != nil {
        return err
    }
    defer sf.Close()
    df, err := os.Create(dest)
    if err != nil {
        return err
    }
    defer df.Close()
    _, err = io.Copy(df, sf)
    if err == nil {
        si, err := os.Stat(source)
        if err != nil {
            err = os.Chmod(dest, si.Mode())
        }

    }
    return
}

// 拷贝目录
func copyDir(source string, dest string) (err error) {
    fi, err := os.Stat(source)
    if err != nil {
        return err
    }
    if !fi.IsDir() {
        return errors.New(source + &amp;quot; is not a directory&amp;quot;)
    }
    err = os.MkdirAll(dest, fi.Mode())
    if err != nil {
        return err
    }
    entries, err := ioutil.ReadDir(source)
    for _, entry := range entries {
        sfp := filepath.Join(source, entry.Name())
        dfp := filepath.Join(dest, entry.Name())
        if entry.IsDir() {
            err = copyDir(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        } else {
            err = copyFile(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        }

    }
    return nil
}

// 3. 时间处理
// import &amp;quot;time&amp;quot;
func TestTimeDemo(t *testing.T) {
    // Parse
    postDate, err := time.Parse(&amp;quot;2006-01-02 15:04:05&amp;quot;, &amp;quot;2015-09-30 19:19:00&amp;quot;)
    fmt.Println(postDate, err)

    // Format
    assert.Equal(t, &amp;quot;2015/Sep/30 07:19:00&amp;quot;, postDate.Format(&amp;quot;2006/Jan/02 03:04:05&amp;quot;))
    assert.Equal(t, &amp;quot;2015-09-30T19:19:00Z&amp;quot;, postDate.Format(time.RFC3339))
}

// 4. 正则表达式
// import &amp;quot;regexp&amp;quot;
func TestRegexp(t *testing.T) {
    // 查找匹配
    re := regexp.MustCompile(`(\d+)-(\d+)`)
    r := re.FindAllStringSubmatch(&amp;quot;123-666&amp;quot;, -1)

    assert.Equal(t, 1, len(r))
    assert.Equal(t, &amp;quot;123&amp;quot;, r[0][1])
    assert.Equal(t, &amp;quot;666&amp;quot;, r[0][2])

}

func main() {
    helloWorld()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>说说刚入手的程序员键盘神器：HHKB Pro2</title>
            <link>http://blog.coderzh.com/2015/09/26/my-hhkb-pro2/</link>
            <pubDate>Sat, 26 Sep 2015 13:54:33 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/26/my-hhkb-pro2/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hhkb-types.jpg&#34; alt=&#34;hhkb-types&#34; /&gt;&lt;/p&gt;

&lt;p&gt;几周前，托朋友从日本捎带了一块静电容键盘HHKB（Happy Hacking Keyboard） Pro2，大约RMB1200。整个键盘只有60个键，没有数字小键盘，甚至没有方向键和最上排的F1~F12功能键。大小写切换键替换成了Control键。整个键盘非常小巧紧凑，敲起来非常舒服。&lt;/p&gt;

&lt;p&gt;然而，这个键盘并不适合非程序员使用，因为少了很多按键。即使是程序员，也并不一定适合。因为HHKB主要是为Linux用户设计的，特别是Vim和Emacs党。用这块键盘，可以很方便的敲出常用的快捷键而不用手离键盘。（现在才发现原来学Emacs时为什么感觉小指要按到抽筋了，原来是键盘不对。。）&lt;/p&gt;

&lt;p&gt;我日常使用的是Windows，但我特别喜欢Vim，即使是在IDE里，我也要切换到Vim模式，不然我感觉敲不出代码。在我体验了几周HHKB之后，感觉即使是在Windows环境里，HHKB也是可以很好的使用的。HHKB有一组DIP开关，可以在几种模式下切换。比如HHKB模式和Mac模式，在Mac下使用这块键盘也是不错的选择。&lt;/p&gt;

&lt;p&gt;这块键盘非常的漂亮，由于是静电容键盘，利用电容容量的变化来判断按键的开关，由于无物理接触点就可以实现敲击，因而磨损更小，非常的耐用，据说可以用到传给你孙子，告诉他你爷爷当年就是用这块键盘敲的代码。。。&lt;/p&gt;

&lt;p&gt;这是一块明星级键盘，备受黑客级程序员追捧，比如：GNU之父Richard StallMan&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/StallmanHHKB.jpg&#34; alt=&#34;StallmanHHK&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再比如，C++ 之父 Bjarne Stroustrup&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bjarne_hhkb.jpg&#34; alt=&#34;bjarne_hhkb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HHKB比想象中还小一些，比如和我的Cherry G80-3800放在一起：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/MyHHKB2.JPG-w&#34; alt=&#34;MyHHKB&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我的电脑桌面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/MyDesktop2.JPG-w&#34; alt=&#34;MyDesktop&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK，图晒完了，记录一点实用的。前面讲了HHKB有一组DIP开关，用来切换不同的输入模式。在键盘的背面，有6个DIP开关的说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HHKB-DIP1.png&#34; alt=&#34;HHKB-DIP1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HHK模式和Lite Ext.模式的区别是，Lite模式可以用Fn+Tab切换大小写（相当于Caps键），以及右边的◇键可以当Windows键或Mac的Command键。所以，一般情况下，Lite模式是更适合的。如果你是Mac，选Macintosh模式是更适合的，因为这种模式下，你可以使用Fn-A,Fn-S,Fn-D,Fn-F等多媒体组合键。&lt;/p&gt;

&lt;p&gt;我目前使用的是SW1 OFF，SW2 OFF，即HHK模式，因为我在想按Alt+Tab切换窗口时，经常误按到左◇+Tab，在Lite模式下直接切换了大小写。。之后适应了不会按错之后再改回来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HHKB-DIP2.png-ws&#34; alt=&#34;HHKB-DIP2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在尝试了不同组合之后，目前我打开的是：SW3，SW4。我觉得这两个对于大多数人来说都是必须的吧，没有退格键是多么不方便。当然，Delete键改成了退格键之后，要删除文件时，就得按Fn+` 键来Delete了。由于F1~F12键我还是需要使用的，所以，Fn键的使用频率会远远大约Alt键，所以，SW5设成OFF，不要交换◇键和Alt键。如果你是Emacs用户，经常需要使用Alt键，可以把SW5设成ON。&lt;/p&gt;

&lt;h4 id=&#34;一些心得:15e5c3c642bde6d107bfd34058e7c128&#34;&gt;一些心得&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;最下排最左右的Alt键正常是不容易按到的。技巧是用直接用小指下面一点的手掌压，突然变得很容易按了：）&lt;/li&gt;
&lt;li&gt;开始会觉得通过Fn移动方向键会非常痛苦，当然现在也是。毕竟小指并没有那么灵活。目前左右移动还稍微习惯一些了。&lt;/li&gt;
&lt;li&gt;Control调到CapsLock键位置之后，Control+s键按的有些别扭，其他的还好。&lt;/li&gt;
&lt;li&gt;感觉最右边的Fn键太远了，按到的频率略少，感觉设计有点不合理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再说一点，键盘是每天上班或者娱乐时间里对着电脑时用的最多的东西之一了，花点代价买一块称心如意的键盘是非常值得的。再加上静电容键盘或者机械键盘是超长时间耐用的，花些投入绝对是值得的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于最近的XcodeGhost事件，我也来说两句</title>
            <link>http://blog.coderzh.com/2015/09/21/xcode-ghost/</link>
            <pubDate>Mon, 21 Sep 2015 00:56:13 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/21/xcode-ghost/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/xcodeghost.jpg-w&#34; alt=&#34;xcodeghost&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近几天讨论的最多的就是XcodeGhost事件了，首先来简要的回顾一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;某个后来自称XcodeGhost作者的程序员，自称本着玩一玩的心态，在苹果的APP开发工具Xcode里嵌入了一段恶意代码。&lt;/li&gt;
&lt;li&gt;该段代码会自动收集用户的信息，发送到一个地址近似苹果的服务器。也有专家分析存在更多的隐患和危害。&lt;/li&gt;
&lt;li&gt;一群苦逼的码农以开发iOS应用为生，发现苹果官方的APP开发工具Xcode下载龟速，于是在网上一顿乱搜，下载到了嵌入恶意代码的Xcode。&lt;/li&gt;
&lt;li&gt;大量这样的APP发布到了AppStore，包括一些大厂的。&lt;/li&gt;
&lt;li&gt;收集信息的恶意代码被发现，然后进一步扩散，称为了社会热点。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个事件有几个值得讨论的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;恶意代码到底危害有多大？&lt;/p&gt;

&lt;p&gt;腾讯的安全团队称，XcodeGhost除了收集APP版本、APP名称、本地语言、iOS版本、设备类型、国家码等设备信息，还可以通过openURL下发伪协议命令，让你的iPhone打开网页，发送短信，打电话，甚至操作具备伪协议能力的第三方APP。XcodeGhost可以让你的iPhone自动弹框，弹框的内容可以在服务端进行控制，而XcodeGhost恶意代码本身又存在安全漏洞，可以被中间人攻击，从而使得你的iPhone可能被更多人控制，成为一个肉鸡。&lt;/p&gt;

&lt;p&gt;看上去挺可怕的。不过也有另外一种观点：基于苹果系统级别的安全限制，恶意代码最多也只能收集一些基本的信息，像iCloud、AppStore的密码是不可能拿到的。而且恶意代码还未造成实质危害就被发现并关闭了，被植入恶意代码的APP也很快被苹果下架，大量APP已经更新了新版并修复了此问题，所以不用太担心。&lt;/p&gt;

&lt;p&gt;上面的说法都是有道理的，如果你还是觉得没有安全感，也可以把常用的密码修改一遍。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么一些大厂也中招？&lt;/p&gt;

&lt;p&gt;在人们的理解中，大厂应该流程比较规范，至少公司内部使用的软件应该都是正版的，为什么这次还是会中招？这里有一个误区，因为Xcode软件本身是免费的，所以根本不存在盗版一说。程序员下载Xcode时，发现苹果官方的下载太慢，于是在其他地方下载到了植入恶意代码的Xcode。&lt;/p&gt;

&lt;p&gt;然而，大厂可以因此推脱责任吗？我觉得不能。稍微懂点iOS开发的同学都知道，一个iOS应用开发完成后，需要编译打包，数字签名等操作，因为权限相关的原因，通常这些操作都会集中到指定的机器上来做，而这样的机器的软件安全性会更加重要的多。即使不是Xcode被植入了恶意代码，就算是系统上有其他恶意程序，也有可能在打包APP时被嵌入一段恶意代码。所以，在这样的机器上，安全性应该提高到另外一个更高的等级。对下载的官方软件，也要再做一次hash比较，检查是否下载到被篡改的软件。&lt;/p&gt;

&lt;p&gt;很多时候，用户是基于信任才使用你的APP，所以，不要因为你的安全意识上的疏忽，失去用户对你的信任。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;苹果为什么也不安全？&lt;/p&gt;

&lt;p&gt;如果你说安卓机不安全，我大概不会反驳。而一直被大家加以信任的苹果，为什么也会有安全隐患，为什么审核的时候没有发现，让这么多有问题的APP顺利的上架？为什么像openURL这样的超级API不能做到更安全？ 这些问题我回答不了，我没有开发过iOS的应用，对iOS的安全性研究不深，但我希望这次事件能更加引起苹果对安全的重视。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这件事件后，我能做什么？&lt;/p&gt;

&lt;p&gt;这件事情被爆出来后，特别是一个大厂的应用也曝光后，我也是第一时间先卸载了手机上的相关的应用。当有人爆出微信也中招时，肯定有很多人和我一样开始非常诧异，难以接受，删了微信我的手机还能干什么？呵呵。然后，你仔细一看，或者别人告诉你，微信6.2.5才有这个问题，最新版已经没有问题了。细心的人马上会发现，微信早在XcodeGhost被爆出来之前就早已发现了这个问题（最早被腾讯安全的团队发现的），然后第一时间加班加点发布了微信6.2.6版本修复了这个问题。&lt;/p&gt;

&lt;p&gt;现在有问题的APP基本已下架，上架的新版本也都修复了这个问题。如果你不放心可以修改一些密码。然而，这次事件之后，我能做什么？或者，给我的启示是什么？这次事件和程序员有关，从写恶意代码的程序员，到下载到含恶意代码的Xcode的程序员，而我刚好也是一名程序员。我能做什么？&lt;/p&gt;

&lt;p&gt;首先，我肯定不会去写恶意代码做坏事，顶多写个脚本抢个票刷个号，也是自己用。然后，在下载软件时，尽量到官方网站下载，对于比较重要的软件，最好下载后校验一下官方的hash。如果是商业付费软件，假如在你的承受范围之内，尽量还是购买正版。在你不断寻找破解补丁的过程中，有无数个包含恶意代码的软件正在向你招手。对于个人开发者，有很多软件都有了Community版本，像Visual Studio，Unity，JetBrains PyCharm等等开发工具，社区版本已经完全够用了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;最后:3500cef42208a15fa70ada140640cf08&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;希望这次事件正如自称XcodeGhost作者声称的那样不会有什么实际危害，同时，我更希望通过这次事件，能引起更多的人或公司关注我们的APP安全。用户信任你的APP，请做好你的APP的安全保护，不要辜负了用户对你的信任。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
