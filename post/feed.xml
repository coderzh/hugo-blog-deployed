<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on CoderZh Blog</title>
        <link>http://blog.coderzh.com/post/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Sun, 25 Oct 2015 23:37:16 CST</updated>
        
        <item>
            <title>Hugo中文网站gohugo.org上线</title>
            <link>http://blog.coderzh.com/2015/10/25/gohugo-org/</link>
            <pubDate>Sun, 25 Oct 2015 23:37:16 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/25/gohugo-org/</guid>
            <description>

&lt;p&gt;之前我在博客里写了一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;，之后有很多人给我留言或者邮件，列举了在搭建Hugo时遇到的各种问题，并且提出希望能有一个中文的Hugo网站。&lt;/p&gt;

&lt;p&gt;于是，我利用周末的时间，注册域名（居然注册到了 &lt;code&gt;gohugo.org&lt;/code&gt; 这个域名），用&lt;code&gt;Hugo&lt;/code&gt;本身搭建了这个网站，运行在 &lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;DigitalOcean&lt;/a&gt; 的 &lt;code&gt;VPS&lt;/code&gt; 上。这就是 &lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;gohugo-org:39bef422aa544bc9d53b933146f67273&#34;&gt;gohugo.org&lt;/h3&gt;

&lt;p&gt;网站的地址是：&lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网站所有内容都在 &lt;code&gt;GitHub&lt;/code&gt; 开源，地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;https://github.com/coderzh/gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该Repository已经设置了WebHook，只要有push就会自动触发 &lt;code&gt;VPS&lt;/code&gt; 更新部署。如果你感兴趣，可以加入进来，你提的PR一旦被Merged将立即在网站更新出来。&lt;/p&gt;

&lt;h3 id=&#34;截图:39bef422aa544bc9d53b933146f67273&#34;&gt;截图&lt;/h3&gt;

&lt;h4 id=&#34;首页:39bef422aa544bc9d53b933146f67273&#34;&gt;首页&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-index.jpg-w&#34; alt=&#34;gohugo-index&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;文章列表:39bef422aa544bc9d53b933146f67273&#34;&gt;文章列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-post.jpg-w&#34; alt=&#34;gohugo-post&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;皮肤列表:39bef422aa544bc9d53b933146f67273&#34;&gt;皮肤列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-theme.jpg-w&#34; alt=&#34;gohugo-theme&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;示例网站:39bef422aa544bc9d53b933146f67273&#34;&gt;示例网站&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-showcase.jpg-w&#34; alt=&#34;gohugo-showcase&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于hugo:39bef422aa544bc9d53b933146f67273&#34;&gt;关于Hugo&lt;/h3&gt;

&lt;p&gt;使用Hugo可以快速的制作一个静态站点，同时Hugo还在不断更新和发展中，相信未来会更加易用、功能越来越好。我给Hugo提过几次PR，看过Hugo的代码，从代码的角度来看，Hugo的代码写非常简洁清晰，模块分类非常的清楚，并且配备完善的单元测试。&lt;/p&gt;

&lt;p&gt;对于如此优秀的东西，希望能与更多人分享，通过分享和交流，希望能促进Hugo变得越来越好，让它更加广为人知。&lt;/p&gt;

&lt;p&gt;因此，所有对Hugo感兴趣的朋友欢迎加入贡献内容，同时也欢迎有任何疑问、建议或交流的朋友加入Hugo交流QQ群：512499080。&lt;/p&gt;

&lt;p&gt;或者微信扫一扫关注我的微信公众号：hacker-thinking&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.coderzh.com/public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>程序员直播写代码网站livecoding.tv即将登陆中国，你有兴趣吗？</title>
            <link>http://blog.coderzh.com/2015/10/23/livecoding</link>
            <pubDate>Fri, 23 Oct 2015 07:08:11 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/23/livecoding</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/livecoding.jpg-wt&#34; alt=&#34;livecoding&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;lol直播:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;LOL直播&lt;/h3&gt;

&lt;p&gt;之前玩LOL那段时间，在不玩游戏的时候最爱的就是看别人直播打游戏。最早的时候，是在own3d.tv上看，后来twitch.tv异军突起，直接统领了国外竞技游戏直播平台。比如那时候看HotshotGG玩豹女，Dyrus玩奥拉夫，甚至看他在Ban/Pick阶段切出去玩俄罗斯方块，也极为有趣。后来twitch.tv越来越卡了，随之YY直播主播兴起，以及现在的斗鱼直播，我也十分爱看。有的主播不但技术强，也十分风趣幽默，看他们和高手对决，或者代练虐菜，也十分享受。比如我比较喜欢的主播有阿倪蛋糕店、董小飒，还有玩德莱文玩到逆天的文森特。这些人都不是职业选手，但是他们的操作意识都十分让人惊叹。（也许之前关于LOL的那些好玩事可以单独开一篇来讲。）&lt;/p&gt;

&lt;p&gt;没玩LOL已经一年多了，不知道现在的情况如何了。有一点可以确定，LOL还是那么的火，直播LOL让主播赚的盆满钵满。观众也十分爱看。就像我们小时候总喜欢站在高手后边看他们怎么玩游戏，怎么一币通关是一个道理。&lt;/p&gt;

&lt;h3 id=&#34;直播写代码:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;直播写代码&lt;/h3&gt;

&lt;p&gt;直播越来越火，有人直播唱歌，有人直播玩游戏，甚至有人直播睡觉打呼。&lt;/p&gt;

&lt;p&gt;然而，程序员直播写代码，你会喜欢看吗？&lt;/p&gt;

&lt;p&gt;第一次听说直播写代码，是在《内核恐慌》的第5期关于编程字体的，里面提到美国有个经验丰富的游戏引擎开发者在网上直播写游戏。&lt;/p&gt;

&lt;p&gt;后来查了下资料，具体是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HandmadeHero.jpg-w&#34; alt=&#34;HandmadeHero&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mollyrocket.com/casey/about.html&#34;&gt;Casey Muratori&lt;/a&gt;是西雅图的一名经验丰富的游戏引擎开发者，据他的介绍，他已经拥有30年的游戏开发经验，参与开发的游戏引擎被数以千计的游戏采用。但是他经常抱怨现在的开发者有那么好的硬件条件，却做不出高效率的游戏出来。&lt;/p&gt;

&lt;p&gt;于是他决定在网上直播写一个游戏：&lt;a href=&#34;http://handmadehero.org/&#34;&gt;Handmade Hero&lt;/a&gt;，这个游戏不会使用任何游戏引擎，而是一行一行代码直播码出来。在直播的过程中，他除了敲代码，还会有大量的讲解，让观看直播的人获得更多系统的知识。你还可以给他支持15美元，这样你就可以随时获取到他的最新源代码，当游戏最终发布的时候，你还可以直接获得最终的发行版本。&lt;/p&gt;

&lt;p&gt;他是在twitch.tv上直播的，地址是：&lt;a href=&#34;http://www.twitch.tv/handmade_hero&#34;&gt;http://www.twitch.tv/handmade_hero&lt;/a&gt;，在&lt;a href=&#34;https://www.youtube.com/user/handmadeheroarchive&#34;&gt;You Tube&lt;/a&gt;（当然，这个网站并不存在）上可以观看之前的直播内容。&lt;/p&gt;

&lt;p&gt;优酷里有关于这个项目的宣传视频，非常炫酷：&lt;a href=&#34;http://v.youku.com/v_show/id_XODU2NDQxODky.html&#34;&gt;http://v.youku.com/v_show/id_XODU2NDQxODky.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这样牛逼的程序员在网上直播写代码，你有兴趣看吗？&lt;/p&gt;

&lt;p&gt;我觉得我会喜欢看。&lt;/p&gt;

&lt;h3 id=&#34;livecoding-tv:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;Livecoding.tv&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/livecoding-example.jpg-w&#34; alt=&#34;livecoding-example&#34; /&gt;&lt;/p&gt;

&lt;p&gt;后来甚至出来一个专门的直播写代码网站：&lt;a href=&#34;http://www.livecoding.tv&#34;&gt;Livecoding&lt;/a&gt;，是Y-Combinator孵化器下的项目，确实是正儿八经的要进军这个看起来非常小众的市场。&lt;/p&gt;

&lt;p&gt;于是我上Livecoding，注册账号，观看直播。在上面你可以针对自己的喜好选择不同的编程语言，可以看当天直播也可以看过往录像，看的时候还可以聊天互动，功能基本和twitch.tv差不多。然而，在国内访问，体验只能用一个字来形容：卡。卡到根本看不了，在我做了各种尝试之后，最后还是放弃了。&lt;/p&gt;

&lt;p&gt;今早收到一封邮件，是Livecoding发来的，标题和正文都是中文。内容是：Livecoding即将全面登录中国。 Livecoding正在国内组建团队，在国内架设服务器，预计2016年能登录中国。有任何意见、想法或者经验的同学，可以联系他们michael@livecoding.tv。&lt;/p&gt;

&lt;h3 id=&#34;小众市场才会比较有趣:37e28bab6010c5ed2db9ee61a3969639&#34;&gt;小众市场才会比较有趣&lt;/h3&gt;

&lt;p&gt;这无疑是个好消息，到时候除了可以顺畅的观看各路大神写代码，甚至自己也可以尝试一下当一回主播，比如直播帮学美术的堂弟写个毕业设计要求的小游戏之类的。&lt;/p&gt;

&lt;p&gt;不过，已经有人尝试过了在虎牙和斗鱼上直播写代码，但观看的人数非常少。相对于美女直播和大神游戏玩家，直播撸代码对大众没有多少吸引力，这确实是一个小众市场。&lt;/p&gt;

&lt;p&gt;然而，小众市场才会更加有趣。大众的东西虽然能吸引到更多的人，但往往趋于平庸，能被小众市场吸引的人，往往本身就对这个东西非常感兴趣，如果在小众市场上挖掘的很深，能更加深入小众用户的心，获得更高的忠诚度。&lt;/p&gt;

&lt;p&gt;假如在程序圈内兴起了一股直播撸代码的热潮，你会想从观看直播过程中获得一些什么呢？比如，我就非常好奇，各路BAT或者业界专家大牛，你们写代码时是怎样一种状态，你们使用什么样的编辑器或IDE，选用什么样的字体，使用哪些快捷键，实现功能的思路是怎样的，怎样查文档，怎么Google，用哪些新奇好玩的工具软件，有哪些实用有趣的编程技巧……&lt;/p&gt;

&lt;p&gt;我可以想象到这是一种什么样的场景，就如同我在大学时看一位牛X同学现场教学如何从零开始做一个网站一样，包括写代码、美工P图切图、排版，噼里啪啦一顿快捷键一气呵成，让你看的眼花缭乱，顿时感觉不明觉厉。可惜这位牛X的同学最后还是选择了留校继续研读土木工程。&lt;/p&gt;

&lt;p&gt;对于Livcoding登录中国，我还是有些小期待的。你有兴趣吗？&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>一篇文章了解什么是增长黑客</title>
            <link>http://blog.coderzh.com/2015/10/17/read-growth-hacker/</link>
            <pubDate>Sat, 17 Oct 2015 10:16:41 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/17/read-growth-hacker/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/GrowthHacker.jpg-wt&#34; alt=&#34;GrowthHacker&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近在Kindle上读了范冰的《增长黑客》，对增长黑客有了更系统的了解。联想到我自己的微信公众号hacker-thinking和独立博客&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;blog.coderzh.com&lt;/a&gt;，我也在苦苦寻找用户增长的终极奥义。我也尝试过各种SEO（搜索引擎优化），比如规范链接地址、nofollow防止权重降低、提供sitemap、增加关键词、规范robots.txt、加快访问速度、增加反向链接等等。肯定有人会说，这些东西然并卵，高质量的内容才是最重要的。这点我同意。&lt;/p&gt;

&lt;p&gt;通过看《增长黑客》，我了解到了作为一个增长黑客必须具备的素质，了解到了大量的国内外活生生的增长黑客的案例。即使书中提到的很多方法，在今天看来已经是司空见惯的做法，但是在当时，想到和高效执行那些想法，是非常了不起的举措。&lt;/p&gt;

&lt;p&gt;想实现产品或用户增长，需要的是开放的想象力、敏锐的思维和大胆高效的执行，绝不是看了《增长黑客》照搬几个例子就可以实现的。但我还是觉得书中例子很多很丰富，极大的拓宽了我的思维，因此决定写这篇主要内容是书摘的文章，一方面看第二遍可以让我加深印象，另一方面是之后回顾该书内容时，可以快速的找到核心重点。&lt;/p&gt;

&lt;p&gt;本文适合的读者：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读过《增长黑客》的朋友。可以当做重新温习一遍。&lt;/li&gt;
&lt;li&gt;还未有时间读《增长黑客》的朋友，可看此文快速了解该书的主要内容。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再次声明，以下内容主要是根据我的个人喜好，从《增长黑客》一书中摘录，经过我的归纳总结提炼出来的内容，只有少部分是个人的观点和想法。如果你看了有感觉，请支持原著《增长黑客》。&lt;/p&gt;

&lt;p&gt;以下主要是书摘：&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;什么是“增长黑客”？&lt;/p&gt;

&lt;p&gt;增长黑客说法源于硅谷，最早在2010年由Qualaroo的创始人兼CEO肖恩·埃利斯（Sean Ellis）提出，真正引起广泛关注是因为安德鲁·陈（Anrew Chen）在2014年发表的《&lt;a href=&#34;http://andrewchen.co/2012/04/27/how-to-be-a-growth-hacker-an-airbnbcraigslist-case-study/&#34;&gt;Growth Hacker is the new VP Marketing&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;这是一群以数据驱动营销、以市场指导产品，通过技术化手段贯彻增长目标的人。他们通常既了解技术，又深谙用户心理，擅长发挥创意、绕过限制，通过低成本的手段解决初创公司产品早期的增长问题。&lt;strong&gt;在外行人眼里，他们就像是极客、发明家和广告狂人的混合体。&lt;/strong&gt;再通俗一点形容，他们的职责接近于专门为初创公司设立的市场推广部门，因为很少有用于营销的大笔经费， 所以更多的是将注意力聚焦在产品策略本身带来的自发增长上。&lt;/p&gt;

&lt;h2 id=&#34;growth-hacker:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Growth Hacker&lt;/h2&gt;

&lt;h3 id=&#34;timothy-c-draper:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Timothy C. Draper&lt;/h3&gt;

&lt;p&gt;Hotmail上线时，Timothy C. Draper给Hotmail两位创始人Sabeer Bhatia和Jack Smith建议在&lt;strong&gt;邮件底部打广告：“附言：我爱你，你可以到Hotmail获得免费电子邮箱”&lt;/strong&gt;。最后广告内容简化成“你可以到Hotmail注册免费电子邮件”。随后促成了产品的几何级数传播。&lt;/p&gt;

&lt;p&gt;这一改动几小时后，新注册用户以每天3000个增长，六个月内斩获100万用户，仅五周后，又获得100万用户，一年半后出售给微软时已经达到了1200万。&lt;/p&gt;

&lt;h3 id=&#34;安迪-琼斯:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;安迪·琼斯&lt;/h3&gt;

&lt;p&gt;安迪·琼斯（Andy Johns）是硅谷富有经验的增长黑客，曾效力于Facebook、Twitter、Quora等公司的增长部门。&lt;/p&gt;

&lt;p&gt;2008年，Facebook，接到任务，12个月获得2亿新用户。主要方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提供Facebook博客小挂件，用户可以把小挂件放在自己的公共主页或博客上，对外展示炫耀。带来了十亿次展示量，千万次点击量和百万级的注册量。&lt;/li&gt;
&lt;li&gt;收购一批第三世界的国家的通讯录服务提供商。以此获得潜在用户的Email地址，对其精准广告推送。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2008年5月，Facebook全球独立访问用户首次超过MySpace。&lt;/p&gt;

&lt;p&gt;安迪总结的方法论：数据分析、用户获取（SEO、PPC、电子邮件广告）、产品研发、文化建设、人才招聘。&lt;/p&gt;

&lt;p&gt;2010年加入Twitter，组建25人的用户增长团队。主要方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;改造首页，突出登录注册区域。砍掉热门微博和搜索框，减少用户头像显示面积，简化文案，登录注册区域占据整个页面的三分之一。24小时内用户注册率提升了约250%。&lt;/li&gt;
&lt;li&gt;每当新用户注册，立即推荐关注至少10个用户。让用户有东西可看，活跃和留存得到提高。&lt;/li&gt;
&lt;li&gt;开发和优化邮件自动发送功能。提高了单位时间发送的数量，每当用户获得粉丝、被转发收藏能第一时间收到邮件提醒。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在所有措施的运转下，两年间，Twitter的活跃用户数量由1亿增长到5亿。&lt;/p&gt;

&lt;p&gt;2011年末，加入问答社区Quora。主要琢磨用户的行为模式，并将之归纳为一套“标准动作”，然后引导其他用户去执行这套标准动作。如完善个人信息，关注感兴趣的行业领袖。&lt;/p&gt;

&lt;p&gt;从安迪身上看出的增长黑客的特质：数据为王、专注目标、关注细节、富于创意、信息通透。&lt;/p&gt;

&lt;h2 id=&#34;数据为王:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;数据为王&lt;/h2&gt;

&lt;p&gt;不同产品的核心数据指标是不一样的。比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;eBay的核心指标是商品价值量和eBay网站上的活跃卖家在全球电商平台的占比。&lt;/li&gt;
&lt;li&gt;Facebook的核心指标是月活跃用户数。&lt;/li&gt;
&lt;li&gt;MySpace、Compact更关注注册用户数。&lt;/li&gt;
&lt;li&gt;WhatsApp创始人简（Jan）从来只对外公布发送消息的数量。&lt;/li&gt;
&lt;li&gt;陌陌对活跃用户的定义是“登录成功并提交地理位置一次”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;数据分析，保证数据来源正确的前提下，做定性和定量分析。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;了解微信公众号订阅者画像，推送适合的内容。&lt;/li&gt;
&lt;li&gt;根据统计分析“免费注册”比“立即注册”点击率高30%。&lt;/li&gt;
&lt;li&gt;某日在线订餐网站数据量猛升，猜测是否与天气阴雨，用户不愿出门有关。&lt;/li&gt;
&lt;li&gt;电商网站婴儿车销量增加，奶粉销量也会相应同步增加。（经典的啤酒和尿布的销售案例）&lt;/li&gt;
&lt;li&gt;某天LinkedIn发现来自雷曼公司的访问量骤升，结果第二天雷曼公司就宣布破产倒闭。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;增长黑客工具箱:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;增长黑客工具箱&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.google.com/analytics/&#34;&gt;Google Analytics&lt;/a&gt;（百度统计、CNZZ统计）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mixpanel.com/&#34;&gt;Mixpanel&lt;/a&gt; 用户行为分析&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kissmetrics.com/&#34;&gt;KissMetrics&lt;/a&gt; 用户行为分析&lt;/li&gt;
&lt;li&gt;UserCycle 用户分组实验&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://customer.io/&#34;&gt;Customer.io&lt;/a&gt; 基于用户不同行为发送不同的邮件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.optimizely.com/&#34;&gt;Optimize.ly&lt;/a&gt;（Unbouce）A/B测试利器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://basecamp.com/&#34;&gt;Basecamp&lt;/a&gt; 37signals旗下的项目管理软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.umeng.com/&#34;&gt;友盟&lt;/a&gt; 国内最大的移动应用统计分析平台之一&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;创造正确的产品:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;创造正确的产品&lt;/h2&gt;

&lt;p&gt;凯文·斯特罗姆（Kevin Systrom）开发的基于地理位置服务的签到抢地盘应用Burbn未见起色，发现用户只喜欢使用Burbn的照片分享功能，于是调转方向，孤注一掷只做照片分享，一个月后吸引了100万用户，仅创立551天后，于2012年4月以10亿美元天价被Facebook收购。这就是照片分享社区Instagram。&lt;/p&gt;

&lt;p&gt;美国市场研究公司CB Insights通过分析101家科技创业公司的失败案例，总结出了创业失败的20大主要原因，其中“没有市场需求”以42％的绝对占比成为首要因素。&lt;/p&gt;

&lt;p&gt;足迹仅靠“大片”效果滤镜，让它火爆了一把。美国版大众点评Yelp在2004年创立之初旨在提供基于电子邮件的交友服务，结果发现用户乐于给商家写点评，于是转型成“商户黄页”。YouTube在2005年创立时只是聚焦在视频约会这一小众市场，当发现流量增长难以继后，改旗易帜成在线视频分享。Flickr曾是一款失败的在线角色扮演游戏的衍生产品。Flickr创始人在之后另一款游戏创业失败后，鬼使神差的在该项目上孵化出了在线协作工具Slack。&lt;/p&gt;

&lt;p&gt;QQ在创业早期从事网络寻呼机业务，在寻呼机市场江河日下时，马化腾一度想以60万的价格出售。百度在成为中国最大的独立搜索引擎之前，曾甘居幕后为其他门户网站提供搜索技术。盛大网络在依靠网络游戏发家致富前，做的是网络虚拟社区“史丹莫”。从百团大战到化妆品限时特卖的聚美优品。从独立论坛系统转型为页游公司的动网。从视频网站转型为在线直播平台的六间房。网络聊天室转型为棋牌游戏的博雅互动。坐拥1亿用户的VeryCD转型“心动游戏”。&lt;/p&gt;

&lt;p&gt;Gmail团队曾经进行过一次名为“你不是用户”的内部演示，援引大量用户数据阐释产品团队 做出每一项决策的具体援引：之所以去除某些功能，是因为大多数Gmail用户没有相关需求，从来都不使用它们。&lt;/p&gt;

&lt;p&gt;QQ邮箱的产品人员曾做了一个特性：将用户收到的所有邮件的附件单列出来，显示在一处。结果发现用户根本没有这样的需求。&lt;/p&gt;

&lt;p&gt;雷军称创业“就是要做最肥的市场”。他投资的YY最早是游戏门户，但雷军觉得最多只值1亿美金，劝李学凌改做直播平台，结果一炮打响。&lt;/p&gt;

&lt;h3 id=&#34;mvp:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;MVP&lt;/h3&gt;

&lt;p&gt;精益创业是指开发团队通过提供最小化可行产品（MVP）获取用户反馈，在此基础上持续快速 迭代（或谋求转型），直至产品达到PMF阶段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dropbox：在Digg.com上发布虚构的Dropbox产品功能，引发大量用户兴趣，最终诞生Dropbox。&lt;/li&gt;
&lt;li&gt;Groupon：最早使用WordPress搭建，手工制作商品礼券。&lt;/li&gt;
&lt;li&gt;Zappos：鞋类电商平台，最早并没有自己的仓库和物流基地，只是跑到隔壁鞋店拍摄一批照片，有人下单再去买回来。&lt;/li&gt;
&lt;li&gt;大众点评：初期手工添加1000家饭店，验证用户是否愿意点评。&lt;/li&gt;
&lt;li&gt;Hyperlapse：延时摄影应用，功能极简，三步完成。&lt;/li&gt;
&lt;li&gt;微信游戏：为快速验证游戏策划是否可行，制作人和策划用“暴力拼图法”感受最终效果，一旦方案不可行便“尽快放弃，不再纠结”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于微信公众平台的MVP策略，开发周期短、成本低、无需适配、分发方便、便于收集反馈、数据得以沉淀。（示例：女神进化史、悠泊）&lt;/p&gt;

&lt;h2 id=&#34;获取用户:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;获取用户&lt;/h2&gt;

&lt;p&gt;微信的张小龙曾经说过：如果你不了解女性，你将失去一半以上的用户（在他的推荐书单中包含《女性的起源》这样专门从进化学角度探讨女性的著作）。&lt;/p&gt;

&lt;h3 id=&#34;筛选种子用户:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;筛选种子用户&lt;/h3&gt;

&lt;p&gt;Facebook这家起源于哈佛大学校园的全球最大社交网站，在上线之初仅对常青藤大学的学生开放，随后逐渐向附近学校乃至全美、全世界拓展。这一聪明的策略帮助其在初期积累了大量的高质量种子用户，也勾起了外部世界融入这个精英社交圈的兴趣，为日后向普罗大众扩张奠定了牢靠的基础。&lt;/p&gt;

&lt;p&gt;知乎早期走的是精英路线。它采用了严格的邀请和审核机制，李开复、徐小平、雷军等互联网 大佬和一批投资圈、媒体圈的从业者成为了它的种子用户。这从根源上奠定了知乎的调性，也它 在圈内迅速成为话题产品，一码难求。有幸受邀加入知乎的用户们谨言慎行，创造了一批高质量 的内容。&lt;/p&gt;

&lt;p&gt;动漫爱好者的聚集地——哔哩哔哩弹幕视频网为了过滤出高质量的早期内容贡献者，维持社区 的健康生态，采用了一套答题机制来拦截不够“ 资深”的动漫爱好者。&lt;/p&gt;

&lt;p&gt;小米从竞品的网站精心筛选并主动邀请一批人成为MIUI的第一批种子用户。&lt;/p&gt;

&lt;p&gt;要警惕“产品蝗虫”。产品早期的用户不都是“种子用户”。&lt;/p&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;聚美优品创始人在办公室搭起“摄影棚”，给化妆品拍照，然后精心修图以吸引女性的注意。&lt;/li&gt;
&lt;li&gt;Strikingly创始人David Chen在Facebook上添加了2000名好友，邀请用户出来喝茶，成为生活中的挚友，甚至在外出演讲时住在了用户家里。&lt;/li&gt;
&lt;li&gt;网易云笔记首先拉来公司内部50个员工高强度使用，不断提需求和反馈问题。然后通过邀请审核逐渐扩大种子用户。&lt;/li&gt;
&lt;li&gt;Airbnb在2009年时每周营收仅200美元，创始人一一查阅网站上的配图，发现那些随便用手机拍出来的照片毫无吸引力，于是租了一个昂贵的相机，挨家挨户上门帮房东拍照。一周后效果立竿见影。&lt;/li&gt;
&lt;li&gt;利用社交网络获取海量用户（开心农场、Zynga、啪啪、唱吧、抬杠、美拍）。啪啪从一开始就未提供独立账号注册登录功能，必须使用新浪微博和QQ登录，使得更容易分享到社交平台。&lt;/li&gt;
&lt;li&gt;在合法的前提下，通过数据抓取“借鸡生蛋”。比如Windows Live Space准备关闭时，网易博客通过RSS抓取，提供了“一键搬家”功能。（作者自己的“追TA”的例子，即在网络上抓取用户头像来模仿真实用户，感觉有侵权嫌疑啊。）&lt;/li&gt;
&lt;li&gt;通过内容营销：吸引流量、培养潜在用户、劝诱转化。撰写耸动的标题，Upworthy总结出的标题技巧包括：不要在标题里透露全部内容、抛出疑问而不是总结陈词、 反复修改直到满意等。&lt;/li&gt;
&lt;li&gt;KISSmetrics的联合创始人尼尔· 帕特尔（Neil Patel）发布的一项针对Google搜索排名与被 收录文章长度关系的调查数据显示，一般排在前十名的文章需要包括至少2000个单词。病毒内容提供商Buzzsumo的调查结果与KISSmetrics近似，他们认为文章篇幅在3000字至10000字的范围内 最容易获得人们的主动分享。&lt;/li&gt;
&lt;li&gt;搜索引擎优化（SEO）和应用商店优化（ASO）。SEO主要有提供sitemap、标注关键词、增加反向链接（通过维基百科）等手段。ASO主要有通过副标题堆关键词（如：大姨吗），引导高满意度用户为应用评分，在用户需求得到满足、感受到成功喜悦时提醒用户去评分。&lt;/li&gt;
&lt;li&gt;捆绑下载，比如豌豆荚、百度应用市场，搜索应用时，先下载的是一个市场APK，然后再下到搜索的软件。（有点流氓手段）&lt;/li&gt;
&lt;li&gt;Mailbox利用排队玩“饥饿营销”，Robinhood甚至提供了“插队”功能，用户只需要发布邀请链接到社交网络就能插队。Track.io甚至更加极端，在技术上无法解决性能问题的情况下，提供付费免除排队功能，找到“有迫切需要的用户”，从而使得项目起死回生。&lt;/li&gt;
&lt;li&gt;利用嵌入式代码和小挂件让你的品牌无处不在。比如：YouTube和Gleam。&lt;/li&gt;
&lt;li&gt;从线上到线下。打车软件Uber最早在旧金山低调推出，因为当地糟糕的出租车打车体验和经常下雨的环境使其迅速得到青睐。手机约会应用Tinder渗透到洛杉矶派对圈，拉拢大批年轻貌美的长期在线用户。&lt;/li&gt;
&lt;li&gt;走向海外。（Facebook、触宝、猎豹）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;激发活跃:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;激发活跃&lt;/h2&gt;

&lt;p&gt;A/B测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LinkedIn通过A/B测试，确定了新注册用户愿意邀请的用户数量定在了“4”个魔法数字。&lt;/li&gt;
&lt;li&gt;Airbnb曾测试过把“保存到心愿单”的收藏图标由星形改为爱心，结果仅凭这一改动就让心愿列表的使用率提升了30％。&lt;/li&gt;
&lt;li&gt;移动端通过下发HTML5执行A/B测试（百姓网）&lt;/li&gt;
&lt;li&gt;A/B测试的结果也要理性对待。百姓网通过A/B测试发现将“拨打电话”改成“投递简历”后，点击率并没有下降。后来却收到很多用户反馈“为什么不能直接拨打电话”，因为用户需要打电话，在不得已情况下才点了投递简历。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诱饵效应，影响用户决策：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tinder交友应用的产品团队发现，当配对异性照片界面上面只有一个“喜欢”按钮时，平均每天点击数为7000次。而在旁边增加一个“不喜欢”按钮后，“喜欢”的点击数达到12000次左右。&lt;/li&gt;
&lt;li&gt;迅雷在引导用户升级“VIP尊享版”时，仅有一个“华丽地变身”比旁边加一个“残忍地拒绝”点击率低了20%。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;游戏改变世界：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;星巴克的会员成长体系（星成就、徽章、亲友券、邀请券）。比如要获得名为“晨型人”的徽章，必须完成五次9: 00之前的门店签到。&lt;/li&gt;
&lt;li&gt;Foursquare的游戏化策略：积分排名、徽章挑战、抢夺地主。&lt;/li&gt;
&lt;li&gt;滴滴打车的“滴米”激励系统，根据这一单的难易程度增减滴米。&lt;/li&gt;
&lt;li&gt;百度贴吧的签到、QQ会员的钻石点亮和VIP成长体系。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;机器人模拟用户&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Quora早期面临内容少质量差的问题时，采取了员工自问自答的方法，通过机器人来模拟用户问答。&lt;/li&gt;
&lt;li&gt;很有网络游戏里看到在线玩家，实际上执行AI的机器人。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;提高留存:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;提高留存&lt;/h2&gt;

&lt;p&gt;根据美国贝恩公司的调查，在商业社会中5％的客户留存率增长意味着公司利润30％的增长，而 把产品卖给老客户的概率是卖给新客户的3倍。所以在“增长黑客”圈内有一句名言：留住已有的 用户胜过拓展新的客户。&lt;/p&gt;

&lt;h3 id=&#34;留存率:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;留存率&lt;/h3&gt;

&lt;p&gt;衡量产品留存率的常用指标包括次日留存率、7日留存（周留存）率、30日留存（月留存）率，其计算公式为：第1天的新增用户中，在往后的第N天依然在使用的用户数/第1天的新增用户数。其中的N对应的就是留存指标中代表天数的2、7或30。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;次日留存率：可于第一时间发现产品新版本的品质变动和渠道优劣。&lt;/li&gt;
&lt;li&gt;7日留存率：可反映出用户完成一个完整体验周期后的去留状况。&lt;/li&gt;
&lt;li&gt;30日留存率：更能反映出一次版本迭代后的稳定性，辅助判断产品的演进方向是否合理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;渠道留存也是一项值得钻研玩味的指标。由于渠道来源不一，用户质量也千差万别，所以有必要针对渠道用户单独剥离进行留存率分析，选择留存率较高的优质渠道进行重点投放。&lt;/p&gt;

&lt;p&gt;提高留存率的方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;优化产品性能。（加快打开速度、减少电池消耗、提升弱网络下的体验）&lt;/li&gt;
&lt;li&gt;有损服务，放下不必要的坚持。微信逢年过节时服务器压力巨大，因此放弃了微信群里的群聊信息先后一致性的严格要求。小米抢购排队时，放弃了精确的排队数量，而是模糊的“仅剩5万部”。手游《刀塔传奇》每逢大版本更新时，尽量先使用“低清版”资源，虽然视觉效果不够细腻，但能让玩家尽快先玩起来。&lt;/li&gt;
&lt;li&gt;引导新用户快速上手。如Twitter在新注册后会自动推荐关注5到10人，让用户的时间线有内容可读。&lt;/li&gt;
&lt;li&gt;社交维系和社交解绑。微信游戏“全民飞机大战”提供“合体”功能，选择一名微信或QQ好友帮助自己。玩家因“求合体”被召回，发现“躺着赚钱”坐收了合体奖励，可能重新被激活。Facebook在用户有冲动注销账号时，确认环节最后一步，页面会显示几名和用户关系最亲密的好友的照片，并可怜巴巴的说“他们会想念你的”。这一设计，使得Facebook的非活跃账户数降低了7%，相当于100万用户量。社交解绑的例子：Same。&lt;/li&gt;
&lt;li&gt;设计唤醒机制：电子邮件唤醒、消息推送、网页内唤醒移动应用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;增加收入:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;增加收入&lt;/h2&gt;

&lt;p&gt;免费模式大行其道的原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;互联网极大地降低了信息的传播成本，这是免费模式的基石所在。&lt;/li&gt;
&lt;li&gt;产品通过互联网面向全球的海量用户，这进一步摊薄了边际成本。&lt;/li&gt;
&lt;li&gt;“ 免费”天然地对人们有着难以抗拒的魅力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;免费模式如何赚钱：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;基本功能免费，高级功能收费的Freemium策略。&lt;/li&gt;
&lt;li&gt;交叉补贴。如：吉列剃须刀的刀身免费刀头收费。&lt;/li&gt;
&lt;li&gt;三方市场流量变现。如：陌陌导流到自家（陌陌争霸）或合作伙伴的游戏成为一大盈利来源。&lt;/li&gt;
&lt;li&gt;开源接受捐赠，或者提供定制开发及文档收费。如：RootTools。&lt;/li&gt;
&lt;li&gt;公司上市或被收购。如：优酷上市。最新新闻又被阿里收购。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;天下没有免费的午餐。通过取消免费账户，收入获得大幅提升。如：设计师网页服务Bidesketch、网站分析服务CrazyEgg、财务软件LessAccounting。&lt;/p&gt;

&lt;p&gt;重定向广告，追踪消费者曾经搜过或打开的网页。比如在淘宝或京东搜过某个商品，在访问别的网站时，依然显示刚刚搜过的商品广告，让犹豫不决的用户点击过去直接下单。&lt;/p&gt;

&lt;p&gt;变惩为奖，堵不如疏。2011年，有网友发现了腾讯QQ会员的技术漏洞，公然在淘宝上以1元钱的价格挂出了“QQ会员点灯”业务。腾讯在修复漏洞后，并未对用户进行惩罚，反而给这部分用户提供八折的优惠折扣，将他们转化为真正的QQ会员。（同理，作者使用的CleanMyMac由破解转正版的优惠）&lt;/p&gt;

&lt;p&gt;建立商业智能系统，精细化管理业绩指标。（百姓网）&lt;/p&gt;

&lt;h2 id=&#34;病毒传播:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;病毒传播&lt;/h2&gt;

&lt;p&gt;凯文·凯利在1998年出版《新经济，新规则》一书中提出了大名鼎鼎的“传真机效应”：单独一台传真机是没有什么价值的，只有它处于一个网络中时才能被赋予价值。对于拥有一台传真机的人而言，网络中中的传真机越多，你的传真机价值也就越大。&lt;/p&gt;

&lt;p&gt;去中心化：人人都是节点，传播的效果能够以几何级数倍增。&lt;/p&gt;

&lt;p&gt;衡量病毒传播的两大核心指标是K因子（K Factor）和病毒循环周期（Virial Cycle Time）。K因子＝感染率 X 转化率。病毒循环周期，是指从用户发出病毒邀请，到新用户完成转化（如点击阅读、注册、消费的行为）所花费的时间。&lt;/p&gt;

&lt;p&gt;坏事传千里，Bug营销：百度云网盘支付BUG（只需要1/1000价格）、迅雷支付Bug（1分钱买180元白金年卡）。&lt;/p&gt;

&lt;p&gt;借势营销，如12306抢票插件、SegmentFault举行的“光棍节程序员闯关秀”。&lt;/p&gt;

&lt;p&gt;产品体外的病毒循环：朋友圈小游戏。如“围住神经猫”、“整蛊”、“财务包子铺”及各种小测试。&lt;/p&gt;

&lt;p&gt;产品体内的病毒循环：通过推荐好友解锁功能（AirDroid）、美图秀秀各种“趣味活动”（如“测试与明星的撞脸程度”）分享、百度魔图的“PK大咖”（上传照片，自动告诉你和哪位明星最像）。&lt;/p&gt;

&lt;p&gt;病毒传播中的用户心理把控：喜爱、逐利、互惠、求助、炫耀、稀缺、害怕失去或错过、懒惰。&lt;/p&gt;

&lt;p&gt;作者的实践：云诺网盘通过用户点击获得无限容量的活动营销。&lt;/p&gt;

&lt;h2 id=&#34;实例:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;实例&lt;/h2&gt;

&lt;h3 id=&#34;airbnb:4c23b88e0ac16f3853bf56fcc20ed9c2&#34;&gt;Airbnb&lt;/h3&gt;

&lt;p&gt;2007年，住在美国旧金山的两位设计师——布莱恩·彻斯基（Brian Chesky）与乔伊·杰比亚（Joe Gebbia）正在为他们付不起房租而困扰。为了赚点外快，他们计划将阁楼出租出去。传统 的做法是在Craigslist网站发帖子。“但我们不想这么干，因为在Craigslist发千篇一律的帖子会显得冷冰冰的，于是我们打算自己动手建一个网站Airbed&amp;amp;Breakfast。”&lt;/p&gt;

&lt;p&gt;如今，Airbed&amp;amp;Breakfast已经摇身一变成为享誉全球的“共享经济”代表性服务：Airbnb。&lt;/p&gt;

&lt;p&gt;早期两位创始人曾在美国大选时卖麦片来筹集资金，因此受到与硅谷创业教父保罗·格雷厄姆（Paul Graham）青睐。&lt;/p&gt;

&lt;p&gt;格雷厄姆事后承认，“这群甚至可以靠卖麦片来挣取收入的人，他们的项目死不了”。&lt;/p&gt;

&lt;p&gt;Airbnb实现用户增长的秘诀：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;挖竞争对手的用户。租房信息提供同步发送到竞争对手Craigslist网站、在Craigslist上模拟客户给屋主留言推荐Airbnb。&lt;/li&gt;
&lt;li&gt;5000美金租借高档相机挨家挨户给招租者的房屋拍照。后签约专业摄影师成立项目组，专门给房东提供拍摄服务。&lt;/li&gt;
&lt;li&gt;打通社交关系链。让屋主和租客信息更透明，解决基本的人与人的信任问题。&lt;/li&gt;
&lt;li&gt;“心愿列表”将星形改成心形，用户使用率提升了30%。&lt;/li&gt;
&lt;li&gt;拥抱移动设备。&lt;/li&gt;
&lt;li&gt;推广时，通过A/B测试发现，“邀请好友可以获得25美元”的效果就不如“向你的好友赠送25美元旅行经费”更打动人。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（Tinder、Github、美丽说、外卖库的例子见原书）&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于开源的思考</title>
            <link>http://blog.coderzh.com/2015/10/11/open-source-thinking/</link>
            <pubDate>Sun, 11 Oct 2015 17:17:19 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/11/open-source-thinking/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/OpenSource.png-wt&#34; alt=&#34;OpenSource&#34; /&gt;&lt;/p&gt;

&lt;p&gt;程序员是一个热衷于开放、分享、协作的群体。他们将有创造力的代码公开分享，供大家审阅、评判、学习和使用，他们接受用户的意见，欢迎一切用户提交的PR改进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源是需要勇气的。&lt;/strong&gt;用户会用脚投票，依赖混乱、晦涩难懂、风格糟糕的代码会被用户所遗弃。代码也是要看脸的，选择开源意味着需要把自己最美的部分展示。如果一个项目一开始就是开源的，在代码编写过程中肯定会格外注意。根据以往的经验，那些表面光鲜的商业软件，内部的代码往往都是混乱不堪，难以示众的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源不仅仅是把代码公开。&lt;/strong&gt;如果仅仅将代码公开就算开源的话，那和真正的开源离的十万八千里呢。开放源代码只是第一步，后续的社区建设，吸引开发者或用户一起来共同参与，形成社区化的协作模式，将开源社区这个轮子滚动起来才是关键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源的协作模式是高效的。&lt;/strong&gt;一个出色的开源项目，可以吸引到全世界出色的程序员，他们大都基于爱好或使用需要，无偿贡献自己的代码。当然，最宝贵的是他们付出的时间。他们往往是在业余时间参与开源项目。在GitHub上，不同时区的人们通过Pull Request的方式跟进和推动项目前进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源需要对代码质量提出更高的要求。&lt;/strong&gt;通过Pull Rquest机制提交的代码，天然需要经过项目维护者的CodeReview才能合入的。在提PR时，需要让代码尽量的整洁，注释规范，有的项目还要求你通过squash合并成1次commit再提交。最后，最重要的环节是给修改的代码补充单元测试案例，保证测试案例是通过的。GitHub提供了这一整套流程的跟踪协作方式，所以程序员们对GitHub如此的爱不释手。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参与开源是一种极好的学习方式。&lt;/strong&gt;如果还没机会自己创建和维护一个好的开源项目，参与到别人的开源项目中会是一个很好的学习提高的方式。你可以看到牛人的代码是怎么写的，然后偷偷记下来。最好的方式是参与其中，不一定需要你贡献多少有价值的代码，也许一个简单的文档内容修改，也能拉近你和牛人之间的距离。当你对代码有一定的熟悉，你就可以打开Issue列表，看看有哪些问题你可以大展拳脚了。一旦你这么做了，相信对你的帮助是巨大的。这也是我近期的深刻体会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码不需要藏着掖着，用户资源和核心数据才是。&lt;/strong&gt;Facebook大多代码都是直接开源的，给社区贡献了大量高质量的开源代码。对他们来说，选择完全开放，吸引更多的开发者参与其中，只要将用户核心数据和平台资源掌握在手里，这个雪球是可以越滚越大的。这就如同RSA算法，加解密的算法是完全公开的，只要你保证了私钥不被泄露，其他的东西全部公开都是安全的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开源并不意味着免费，也许还能赚到钱。&lt;/strong&gt;很多程序员参与开源并不是为了赚钱，有的纯粹是爱好，有的是自我价值的实现。随着开源项目越来越大，越来越多人参与，需要参与维护和打理的时间就会变多，甚至有的人会全职来做这个。他们可以通过商业授权、培训咨询、捐赠等方式获得收入。只要认真经营，机会就会自己找上门来。&lt;/p&gt;

&lt;h3 id=&#34;我的切身体会:3583956c9bd42a05e9ead1f80dfc8eab&#34;&gt;我的切身体会&lt;/h3&gt;

&lt;p&gt;很早前我也经常丢一些代码到google code，正如前面所说的，这离真正的开源差的很远。因为我只是把代码一丢，然后就不管不顾了，渐渐下来，代码愈加的鲜人问津。对于别人的开源代码，我也基本是拿来主义。&lt;/p&gt;

&lt;p&gt;今年开始真正的参与到GitHub中去，其中之一就是Hugo静态网站生成器项目。由于对Go语言感兴趣，本着边学边用的态度，尝试给Hugo提了第一个PR，Hugo的维护者@bep和@anthonyfok都非常Nice，整个过程非常舒服和顺畅，随之我又陆续提了几个PR。&lt;/p&gt;

&lt;p&gt;下面是我给Hugo贡献的几个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add config option &amp;ldquo;disablePathToLower&amp;rdquo; &lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;#1392&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;WordCount and Summary support CJK Language &lt;a href=&#34;https://github.com/spf13/hugo/pull/1399&#34;&gt;#1399&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hugo import from Jekyll &lt;a href=&#34;https://github.com/spf13/hugo/pull/1469&#34;&gt;#1469&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的链接可以追溯每次代码提交的详细过程。有的经过了反复讨论和反复修改，大家身处世界各地，时差不同。每天一早起来就可以看到他们给出的反馈。在讨论的过程中，可以看到别人对同一个问题的思考，互相交流，也学习到很多东西。&lt;/p&gt;

&lt;p&gt;Hugo的作者spf13(Steve Francia)可是一个牛人。spf13是大名鼎鼎的开源项目Docker和MongoDB的Chief Operator，另外他还是spf13-vim, Hugo, Cobra &amp;amp; Viper等开源项目的作者。能和这样的牛人交流学习，是一种不错的体验。他的博客地址：&lt;a href=&#34;http://spf13.com&#34;&gt;http://spf13.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国庆在家给Hugo提了一个不大也不小的功能。就是上面的第三点：Hugo import from Jekyll。给Hugo提供了内置的import命令，将原来的Jekyll博客一键导入到Hugo来。这次提交的代码加上测试案例，有近600行，也算一个不小而且非常有用的改动了。详细介绍见上一篇博客：&lt;a href=&#34;http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/&#34;&gt;使用Hugo Import一键迁移Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过hugo import功能刷了近600行代码之后，我在Hugo的贡献者列表里可以看到，已经一共刷了近千行代码了，算上删除的话。：）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hugo-coderzh.png-ws&#34; alt=&#34;hugo-coderzh&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于时区和远程协作的关系，GitHub上协作时有时候需要等待，但我依然认为这是一种非常高效的协作方式。因为社区的力量是强大的，在大量社区用户的推动之下，项目每天都在改进，每天都在向更好的方向推动和前进，这才是项目保持长久活力的重要根本。&lt;/p&gt;

&lt;p&gt;关于开源，我还会继续下去，参与和发掘更多更好玩的东西。也欢迎访问我的GitHub和博客，和我交流，谢谢！&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&#34;https://github.com/coderzh&#34;&gt;https://github.com/coderzh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用Hugo Import一键迁移Jekyll</title>
            <link>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</link>
            <pubDate>Sun, 11 Oct 2015 10:06:11 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoImportJekyll.png-wt&#34; alt=&#34;HugoImportJekyll&#34; /&gt;&lt;/p&gt;

&lt;p&gt;国庆长假期间，给Hugo提了几个PR，其中最主要的一个是给Hugo增加了内置的Jekyll迁移工具。这样之前的Jekyll用户可以通过一个简单的命令就可以将网站转化成Hugo站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll your-jekyll-dir target-dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得益于Hugo代码可读性非常好，原来计划需要几天来完成的功能1天左右的时间就完成了。完整的PR过程请见：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1469&#34;&gt;https://github.com/spf13/hugo/pull/1469&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo-import:9d9792e5f5806aca19497d8888e47a21&#34;&gt;Hugo Import&lt;/h3&gt;

&lt;p&gt;主要实现了将原来的Jeklly网站一键转换为Hugo网站，具体实现了如下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成新的Hugo站点结构。(hugo new site)&lt;/li&gt;
&lt;li&gt;读取Jeklly的_config.yml，相应内容转化到Hugo的config.yaml。&lt;/li&gt;
&lt;li&gt;转换所有MarkDown的文章。（具体转换规则见下文）&lt;/li&gt;
&lt;li&gt;拷贝Jekyll其他目录及文件到Hugo的static目录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;@bep在他的OS X上做了一些测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll qrush.github.com qr2
  Importing...
  Congratulations! 72 posts imported!
  Now, start Hugo by yourself:
  $ git clone https://github.com/spf13/herring-cove.git qr2/themes/herring-cove
  $ cd qr2
  $ hugo server -w --theme=herring-cove
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;markdown文章转换规则:9d9792e5f5806aca19497d8888e47a21&#34;&gt;MarkDown文章转换规则&lt;/h3&gt;

&lt;p&gt;Hugo和Jekyll都是使用MarkDown来写文章的，文章内容基本上是兼容的，除了一些FrontMatter的细节和局部细节。Hugo Import Jekyll主要的转换规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保持原Jekyll文章目录结构及文件名不变，将文章拷贝到了content/post目录下。&lt;/li&gt;
&lt;li&gt;尽量保持原Jekyll文章链接地址不变，在文章的FrontMatter自动填入url字段。&lt;/li&gt;
&lt;li&gt;date字段转换成Hugo要求的time.RFC3339格式。&lt;/li&gt;
&lt;li&gt;draft字段自动生成。&lt;/li&gt;
&lt;li&gt;删除layout字段。&lt;/li&gt;
&lt;li&gt;category字段转换成categories字段。&lt;/li&gt;
&lt;li&gt;excerpt_separator智能替换。(比如： &amp;lt;!--more--&amp;gt;)&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;{% raw %}{% endraw %}&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;替换&lt;code&gt;{% highlight %}{% endhighlight %}&lt;/code&gt;标签为 {{&amp;lt; highlight &amp;gt;}}{{&amp;lt; / highlight &amp;gt;}}&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;代码:9d9792e5f5806aca19497d8888e47a21&#34;&gt;代码&lt;/h3&gt;

&lt;p&gt;import.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;import_test.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import_test.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import_test.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我fork的Hugo Repo（我的最新改动都在这里）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/hugo&#34;&gt;https://github.com/coderzh/hugo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;最后:9d9792e5f5806aca19497d8888e47a21&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;这个功能将会在下个正式版推出，现在需要使用的同学自行pull最新的Hugo代码编译吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get -u -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;欢迎试用，并且提出意见或建议！谢谢！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go语言极速入门手册.go</title>
            <link>http://blog.coderzh.com/2015/09/28/go-tips/</link>
            <pubDate>Mon, 28 Sep 2015 22:43:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/28/go-tips/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/golang.jpg&#34; alt=&#34;golang&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/CodeTips&#34;&gt;https://github.com/coderzh/CodeTips&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
gotips_test.go:
  Golang速学速查速用代码手册

Source: github.com/coderzh/CodeTips/blob/master/gotips_test.go

Author: coderzh(github.com/coderzh)
Blog: http://blog.coderzh.com
参考：《Go语言编程》
*/

package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;math&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
    &amp;quot;regexp&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;testing&amp;quot;
    &amp;quot;time&amp;quot;
)

// 0. 注释
/*
规范：
 1. 命名：骆驼命名法（不要用下划线）

命令:
 go get github.com/coderzh/xxx
 go build calc
 go run xxx.go
 go install calc
*/

// 1. Hello World
func helloWorld() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}

// 2.变量类型
func typeDemo() {
    // 变量声明
    var v1 int
    var (
        v2 int
        v3 string
    )
    //var p *int // 指针类型

    // 变量初始化
    var v4 int = 10
    // 等价于:
    var v5 = 10
    // 一般这样就好
    v6 := 10

    // 赋值，多重赋值
    v1 = 10
    v2, v3 = 20, &amp;quot;test&amp;quot;
    // 匿名变量 _
    _, v4 = v5, v6

    fmt.Println(v1, v2, v3, v4)

    // 常量
    const Pi float64 = 3.1415926
    const MaxPlayer = 10

    // 枚举
    const (
        Sunday = iota // iota从0递增
        Mondy
        Tuesday
        // ...
    )

    // 类型
    // 1. 布尔
    var b1 bool
    b1 = true
    b1 = (1 == 2)

    fmt.Println(b1)

    // 2. 整形
    // int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint uintptr
    var i32 int32
    // 强制转换
    i32 = int32(64)
    // 运算：+, -, *, /, %（求余）
    // 比较：&amp;gt;, &amp;lt;, ==, &amp;gt;=, &amp;lt;=, !=
    // 位运算：x &amp;lt;&amp;lt; y, x &amp;gt;&amp;gt; y, x ^ y, x &amp;amp; y, x | y, ^x （取反）

    fmt.Println(i32)

    // 3. 浮点
    // float32, float64
    var f1 float64 = 1.0001
    var f2 float64 = 1.0002
    // 浮点比较
    isEqual := math.Dim(f1, f2) &amp;lt; 0.0001

    fmt.Println(isEqual)

    // 4. 字符串
    var s1 string
    s1 = &amp;quot;abc&amp;quot;
    // 字符串连接
    s1 = s1 + &amp;quot;ddd&amp;quot;
    // 取长度
    n := len(s1)
    // 取字符
    c1 := s1[0]
    // 反引号，不转义，常用于正则表达式
    s1 = `\w+`

    fmt.Println(c1)

    fmt.Println(strings.HasPrefix(&amp;quot;prefix&amp;quot;, &amp;quot;pre&amp;quot;)) // true
    fmt.Println(strings.HasSuffix(&amp;quot;suffix&amp;quot;, &amp;quot;fix&amp;quot;)) // true

    // 字节遍历
    for i := 0; i &amp;lt; n; i++ {
        ch := s1[i]
        fmt.Println(ch)
    }
    // Unicode字符遍历
    for i, ch := range s1 {
        fmt.Println(i, ch)
    }

    // 5. 数组
    var arr1 [32]int
    //var arr2 [3][8]int // 二维数组
    // 初始化
    arr1 = [32]int{0}
    array := [5]int{1, 2, 3, 4, 5}
    // 临时结构体数组
    structArray := []struct {
        name string
        age  int
    }{{&amp;quot;Tim&amp;quot;, 18}, {&amp;quot;Jim&amp;quot;, 20}}

    // 数组遍历
    for i := 0; i &amp;lt; len(array); i++ {
        fmt.Println(array[i])
    }
    for i, v := range structArray {
        fmt.Println(i, v)
    }
    // 数组是值类型，每次参数传递都是一份拷贝

    // 数组切片Slice
    var mySlice []int = arr1[:2]
    mySlice1 := make([]int, 5)
    mySlice2 := make([]int, 5, 10)

    fmt.Println(&amp;quot;len(mySlice2:&amp;quot;, len(mySlice2)) // 5
    fmt.Println(&amp;quot;cap(mySlice2:&amp;quot;, cap(mySlice2)) // 10

    mySlice3 := append(mySlice, 2, 3, 4)
    mySlice4 := append(mySlice, mySlice1...)

    copy(mySlice3, mySlice4)

    // 6. Map
    var m map[int]string
    m[1] = &amp;quot;ddd&amp;quot;
    m1 := make(map[int]string)
    m2 := map[int]string{
        1: &amp;quot;a&amp;quot;,
        2: &amp;quot;b&amp;quot;,
    }

    delete(m2, 1)

    value, ok := m1[1]
    if ok {
        fmt.Println(value)
    }

    for k, v := range m2 {
        fmt.Println(k, v)
    }

}

// 3. 流程控制
func flowDemo() {
    // if else
    a := 10
    if a &amp;lt; 10 {
        // ..
    } else {
        // ..
    }

    // switch
    switch a {
    case 0:
        fmt.Println(&amp;quot;0&amp;quot;)
    case 10:
        fmt.Println(&amp;quot;10&amp;quot;)
    default:
        fmt.Println(&amp;quot;default&amp;quot;)
    }

    switch {
    case a &amp;lt; 10:
        fmt.Println(&amp;quot;&amp;lt;10&amp;quot;)
    case a &amp;lt; 20:
        fmt.Println(&amp;quot;&amp;lt;20&amp;quot;)
    }

    // 循环
    for i := 0; i &amp;lt; 10; i++ {
    }
    // 无限循环
    sum := 0
    for {
        sum++
        if sum &amp;gt; 10 {
            break
            // 指定break
            // break JLoop
        }
    }

    goto JLoop

JLoop:
    // break to here

}

// 4. 函数
// func 函数名(参数列表)(返回值列表) {
// }
func sum1(value1 int, value2 int) (result int, err error) {
    // err = errors.New(&amp;quot;xxxx&amp;quot;)
    return value1 + value2, nil
}

func sum2(value1, value2 int) int {
    return value1 + value2
}

// 不定参数
// myFunc(1, 2, 3, 4, 5)
func myFunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
    // 传递
    // myFunc2(args...)
    // myFunc2(args[1:]...)
}

// 任意类型的不定参数
func myPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
        case int:
            fmt.Println(arg, &amp;quot;is int&amp;quot;)
        case string:
            fmt.Println(arg, &amp;quot;is string&amp;quot;)
        default:
            fmt.Println(arg, &amp;quot;is unknown&amp;quot;)
        }
    }
}

// 匿名函数
func anonymousFunc() {
    f := func(a, b int) int {
        return a + b
    }

    f(1, 2)
}

// defer
func deferDemo(path string) {
    f, err := os.Open(path)
    if err != nil {
        return
    }

    defer f.Close()
    // or
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf(&amp;quot;Runtime error caught: %v&amp;quot;, r)
        }
    }()
}

// 5. 结构体
type Rect struct {
    // 小写为private
    x, y float64
    // 大写为public
    Width, Height float64
}

// 大写方法为public，小写为private
func (r *Rect) Area() float64 {
    return r.Width * r.Height
}

func netRect(x, y, width, height float64) *Rect {
    // 实例化结构体
    // rect1 := new(Rect)
    // rect2 := &amp;amp;Rect{}
    // rect3 := &amp;amp;Rect{Width:100, Height:200}
    return &amp;amp;Rect{x, y, width, height}
}

// 匿名组合
type Base struct {
    Name string
}

func (base *Base) Foo() {}
func (base *Base) Bar() {}

type Foo struct {
    Base
    *log.Logger
}

func (foo *Foo) Bar() {
    foo.Base.Bar()
    // ...
}

// 非侵入式接口
type IFile interface {
    Read(buf []byte) (n int, err error)
    Write(buf []byte) (n int, err error)
}

type File struct {
}

func (file *File) Read(buf []byte) (n int, err error) {
    return 0, nil
}

func (file *File) Write(buf []byte) (n int, err error) {
    return 0, nil
}

func interfaceDemo() {
    // 只要实现了Read, Write方法即可
    var file IFile = new(File)

    // 接口查询
    // 是否实现了IFile接口
    if file2, ok := file.(IFile); ok {
        file2.Read([]byte{})
    }
    // 实例类型是否是File
    if file3, ok := file.(*File); ok {
        file3.Read([]byte{})
    }

    // 类型查询
    switch v := file.(type) {
    }
}

// 6. 并发编程
func counting(ch chan int) {
    ch &amp;lt;- 1
    fmt.Println(&amp;quot;counting&amp;quot;)
}

func channelDemo() {
    chs := make([]chan int, 10)
    for i := 0; i &amp;lt; len(chs); i++ {
        chs[i] = make(chan int)
        // 带缓冲区大小
        // c: = make(chan int, 1024)
        // for i:= range c {
        // }
        go counting(chs[i])
    }

    for _, ch := range chs {
        &amp;lt;-ch
        // channel select
        /*
            select {
            case &amp;lt;-ch:
                // ...
            case ch &amp;lt;- 1:
            }
        */
    }

    // 单向Channel
    var ch1 chan&amp;lt;- int // 只能写入int
    var ch2 &amp;lt;-chan int // 只能读出int

    // 关闭Channel
    close(ch1)
    _, ok := &amp;lt;-ch2
    if !ok {
        // already closed
    }
}

// 锁
var m sync.Mutex

func lockDemo() {
    m.Lock()
    // do something
    defer m.Unlock()
}

// 全局唯一操作
var once sync.Once

// once.Do(someFunction)

// 7. 网络编程
// import &amp;quot;net&amp;quot;
// net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8080&amp;quot;)

// 8. json处理
// import &amp;quot;encoding/json&amp;quot;
// json.Marshal(obj) 序列化
// json.Unmarshal() 反序列化

// 9. Web开发
// import &amp;quot;net/http&amp;quot;
// 模板
// import &amp;quot;html/template&amp;quot;

// 10. 常用库
// import &amp;quot;os&amp;quot;
// import &amp;quot;io&amp;quot;
// import &amp;quot;flag&amp;quot;
// import &amp;quot;strconv&amp;quot;
// import &amp;quot;crypto/sha1&amp;quot;
// import &amp;quot;crypto/md5&amp;quot;

// 11. 单元测试
// _test结尾的go文件： xxx_test.go
// 函数名以Test开头
func TestDemo(t *testing.T) {
    r := sum2(2, 3)
    if r != 5 {
        t.Errorf(&amp;quot;sum2(2, 3) failed. Got %d, expect 5.&amp;quot;, r)
    }

    assert.Equal(t, 1, 1)
}

// 12. 性能测试
func benchmarkAdd(b *testing.B) {
    b.StopTimer()
    // dosometing
    b.StartTimer()
}

/*
 其他常用的代码片段
*/

// 1. 遍历文件 filepath.Walk
// import &amp;quot;path/filepath&amp;quot;
func doHashWalk(dirPath string) error {

    fullPath, err := filepath.Abs(dirPath)

    if err != nil {
        return err
    }

    callback := func(path string, fi os.FileInfo, err error) error {
        return hashFile(fullPath, path, fi, err)
    }

    return filepath.Walk(fullPath, callback)
}

func hashFile(root string, path string, fi os.FileInfo, err error) error {
    if fi.IsDir() {
        return nil
    }
    rel, err := filepath.Rel(root, path)
    if err != nil {
        return err
    }
    log.Println(&amp;quot;hash rel:&amp;quot;, rel, &amp;quot;abs:&amp;quot;, path)
    return nil
}

// 2. 读取文件
// import &amp;quot;io/ioutil&amp;quot;
func readFileDemo(filename string) {
    content, err := ioutil.ReadFile(filename)
    if err != nil {
        //Do something
    }
    lines := strings.Split(string(content), &amp;quot;\n&amp;quot;)
    fmt.Println(&amp;quot;line count:&amp;quot;, len(lines))
}

// 判断目录或文件是否存在
func existsPathCheck(path string) (bool, error) {
    // 判断不存在
    if _, err := os.Stat(path); os.IsNotExist(err) {
        // 不存在
    }

    // 判断是否存在
    _, err := os.Stat(path)
    if err == nil {
        return true, nil
    }
    if os.IsNotExist(err) {
        return false, nil
    }
    return true, err
}

// 文件目录操作
func fileDirDemo() {
    // 级联创建目录
    os.MkdirAll(&amp;quot;/path/to/create&amp;quot;, 0777)
}

// 拷贝文件
func copyFile(source string, dest string) (err error) {
    sf, err := os.Open(source)
    if err != nil {
        return err
    }
    defer sf.Close()
    df, err := os.Create(dest)
    if err != nil {
        return err
    }
    defer df.Close()
    _, err = io.Copy(df, sf)
    if err == nil {
        si, err := os.Stat(source)
        if err != nil {
            err = os.Chmod(dest, si.Mode())
        }

    }
    return
}

// 拷贝目录
func copyDir(source string, dest string) (err error) {
    fi, err := os.Stat(source)
    if err != nil {
        return err
    }
    if !fi.IsDir() {
        return errors.New(source + &amp;quot; is not a directory&amp;quot;)
    }
    err = os.MkdirAll(dest, fi.Mode())
    if err != nil {
        return err
    }
    entries, err := ioutil.ReadDir(source)
    for _, entry := range entries {
        sfp := filepath.Join(source, entry.Name())
        dfp := filepath.Join(dest, entry.Name())
        if entry.IsDir() {
            err = copyDir(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        } else {
            err = copyFile(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        }

    }
    return nil
}

// 3. 时间处理
// import &amp;quot;time&amp;quot;
func TestTimeDemo(t *testing.T) {
    // Parse
    postDate, err := time.Parse(&amp;quot;2006-01-02 15:04:05&amp;quot;, &amp;quot;2015-09-30 19:19:00&amp;quot;)
    fmt.Println(postDate, err)

    // Format
    assert.Equal(t, &amp;quot;2015/Sep/30 07:19:00&amp;quot;, postDate.Format(&amp;quot;2006/Jan/02 03:04:05&amp;quot;))
    assert.Equal(t, &amp;quot;2015-09-30T19:19:00Z&amp;quot;, postDate.Format(time.RFC3339))
}

// 4. 正则表达式
// import &amp;quot;regexp&amp;quot;
func TestRegexp(t *testing.T) {
    // 查找匹配
    re := regexp.MustCompile(`(\d+)-(\d+)`)
    r := re.FindAllStringSubmatch(&amp;quot;123-666&amp;quot;, -1)

    assert.Equal(t, 1, len(r))
    assert.Equal(t, &amp;quot;123&amp;quot;, r[0][1])
    assert.Equal(t, &amp;quot;666&amp;quot;, r[0][2])

}

func main() {
    helloWorld()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>说说刚入手的程序员键盘神器：HHKB Pro2</title>
            <link>http://blog.coderzh.com/2015/09/26/my-hhkb-pro2/</link>
            <pubDate>Sat, 26 Sep 2015 13:54:33 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/26/my-hhkb-pro2/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/hhkb-types.jpg&#34; alt=&#34;hhkb-types&#34; /&gt;&lt;/p&gt;

&lt;p&gt;几周前，托朋友从日本捎带了一块静电容键盘HHKB（Happy Hacking Keyboard） Pro2，大约RMB1200。整个键盘只有60个键，没有数字小键盘，甚至没有方向键和最上排的F1~F12功能键。大小写切换键替换成了Control键。整个键盘非常小巧紧凑，敲起来非常舒服。&lt;/p&gt;

&lt;p&gt;然而，这个键盘并不适合非程序员使用，因为少了很多按键。即使是程序员，也并不一定适合。因为HHKB主要是为Linux用户设计的，特别是Vim和Emacs党。用这块键盘，可以很方便的敲出常用的快捷键而不用手离键盘。（现在才发现原来学Emacs时为什么感觉小指要按到抽筋了，原来是键盘不对。。）&lt;/p&gt;

&lt;p&gt;我日常使用的是Windows，但我特别喜欢Vim，即使是在IDE里，我也要切换到Vim模式，不然我感觉敲不出代码。在我体验了几周HHKB之后，感觉即使是在Windows环境里，HHKB也是可以很好的使用的。HHKB有一组DIP开关，可以在几种模式下切换。比如HHKB模式和Mac模式，在Mac下使用这块键盘也是不错的选择。&lt;/p&gt;

&lt;p&gt;这块键盘非常的漂亮，由于是静电容键盘，利用电容容量的变化来判断按键的开关，由于无物理接触点就可以实现敲击，因而磨损更小，非常的耐用，据说可以用到传给你孙子，告诉他你爷爷当年就是用这块键盘敲的代码。。。&lt;/p&gt;

&lt;p&gt;这是一块明星级键盘，备受黑客级程序员追捧，比如：GNU之父Richard StallMan&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/StallmanHHKB.jpg&#34; alt=&#34;StallmanHHK&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再比如，C++ 之父 Bjarne Stroustrup&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bjarne_hhkb.jpg&#34; alt=&#34;bjarne_hhkb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HHKB比想象中还小一些，比如和我的Cherry G80-3800放在一起：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/MyHHKB2.JPG-w&#34; alt=&#34;MyHHKB&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我的电脑桌面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/MyDesktop2.JPG-w&#34; alt=&#34;MyDesktop&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK，图晒完了，记录一点实用的。前面讲了HHKB有一组DIP开关，用来切换不同的输入模式。在键盘的背面，有6个DIP开关的说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HHKB-DIP1.png&#34; alt=&#34;HHKB-DIP1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;HHK模式和Lite Ext.模式的区别是，Lite模式可以用Fn+Tab切换大小写（相当于Caps键），以及右边的◇键可以当Windows键或Mac的Command键。所以，一般情况下，Lite模式是更适合的。如果你是Mac，选Macintosh模式是更适合的，因为这种模式下，你可以使用Fn-A,Fn-S,Fn-D,Fn-F等多媒体组合键。&lt;/p&gt;

&lt;p&gt;我目前使用的是SW1 OFF，SW2 OFF，即HHK模式，因为我在想按Alt+Tab切换窗口时，经常误按到左◇+Tab，在Lite模式下直接切换了大小写。。之后适应了不会按错之后再改回来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HHKB-DIP2.png-ws&#34; alt=&#34;HHKB-DIP2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在尝试了不同组合之后，目前我打开的是：SW3，SW4。我觉得这两个对于大多数人来说都是必须的吧，没有退格键是多么不方便。当然，Delete键改成了退格键之后，要删除文件时，就得按Fn+` 键来Delete了。由于F1~F12键我还是需要使用的，所以，Fn键的使用频率会远远大约Alt键，所以，SW5设成OFF，不要交换◇键和Alt键。如果你是Emacs用户，经常需要使用Alt键，可以把SW5设成ON。&lt;/p&gt;

&lt;h4 id=&#34;一些心得:15e5c3c642bde6d107bfd34058e7c128&#34;&gt;一些心得&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;最下排最左右的Alt键正常是不容易按到的。技巧是用直接用小指下面一点的手掌压，突然变得很容易按了：）&lt;/li&gt;
&lt;li&gt;开始会觉得通过Fn移动方向键会非常痛苦，当然现在也是。毕竟小指并没有那么灵活。目前左右移动还稍微习惯一些了。&lt;/li&gt;
&lt;li&gt;Control调到CapsLock键位置之后，Control+s键按的有些别扭，其他的还好。&lt;/li&gt;
&lt;li&gt;感觉最右边的Fn键太远了，按到的频率略少，感觉设计有点不合理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，再说一点，键盘是每天上班或者娱乐时间里对着电脑时用的最多的东西之一了，花点代价买一块称心如意的键盘是非常值得的。再加上静电容键盘或者机械键盘是超长时间耐用的，花些投入绝对是值得的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>关于最近的XcodeGhost事件，我也来说两句</title>
            <link>http://blog.coderzh.com/2015/09/21/xcode-ghost/</link>
            <pubDate>Mon, 21 Sep 2015 00:56:13 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/21/xcode-ghost/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/xcodeghost.jpg-w&#34; alt=&#34;xcodeghost&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近几天讨论的最多的就是XcodeGhost事件了，首先来简要的回顾一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;某个后来自称XcodeGhost作者的程序员，自称本着玩一玩的心态，在苹果的APP开发工具Xcode里嵌入了一段恶意代码。&lt;/li&gt;
&lt;li&gt;该段代码会自动收集用户的信息，发送到一个地址近似苹果的服务器。也有专家分析存在更多的隐患和危害。&lt;/li&gt;
&lt;li&gt;一群苦逼的码农以开发iOS应用为生，发现苹果官方的APP开发工具Xcode下载龟速，于是在网上一顿乱搜，下载到了嵌入恶意代码的Xcode。&lt;/li&gt;
&lt;li&gt;大量这样的APP发布到了AppStore，包括一些大厂的。&lt;/li&gt;
&lt;li&gt;收集信息的恶意代码被发现，然后进一步扩散，称为了社会热点。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个事件有几个值得讨论的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;恶意代码到底危害有多大？&lt;/p&gt;

&lt;p&gt;腾讯的安全团队称，XcodeGhost除了收集APP版本、APP名称、本地语言、iOS版本、设备类型、国家码等设备信息，还可以通过openURL下发伪协议命令，让你的iPhone打开网页，发送短信，打电话，甚至操作具备伪协议能力的第三方APP。XcodeGhost可以让你的iPhone自动弹框，弹框的内容可以在服务端进行控制，而XcodeGhost恶意代码本身又存在安全漏洞，可以被中间人攻击，从而使得你的iPhone可能被更多人控制，成为一个肉鸡。&lt;/p&gt;

&lt;p&gt;看上去挺可怕的。不过也有另外一种观点：基于苹果系统级别的安全限制，恶意代码最多也只能收集一些基本的信息，像iCloud、AppStore的密码是不可能拿到的。而且恶意代码还未造成实质危害就被发现并关闭了，被植入恶意代码的APP也很快被苹果下架，大量APP已经更新了新版并修复了此问题，所以不用太担心。&lt;/p&gt;

&lt;p&gt;上面的说法都是有道理的，如果你还是觉得没有安全感，也可以把常用的密码修改一遍。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么一些大厂也中招？&lt;/p&gt;

&lt;p&gt;在人们的理解中，大厂应该流程比较规范，至少公司内部使用的软件应该都是正版的，为什么这次还是会中招？这里有一个误区，因为Xcode软件本身是免费的，所以根本不存在盗版一说。程序员下载Xcode时，发现苹果官方的下载太慢，于是在其他地方下载到了植入恶意代码的Xcode。&lt;/p&gt;

&lt;p&gt;然而，大厂可以因此推脱责任吗？我觉得不能。稍微懂点iOS开发的同学都知道，一个iOS应用开发完成后，需要编译打包，数字签名等操作，因为权限相关的原因，通常这些操作都会集中到指定的机器上来做，而这样的机器的软件安全性会更加重要的多。即使不是Xcode被植入了恶意代码，就算是系统上有其他恶意程序，也有可能在打包APP时被嵌入一段恶意代码。所以，在这样的机器上，安全性应该提高到另外一个更高的等级。对下载的官方软件，也要再做一次hash比较，检查是否下载到被篡改的软件。&lt;/p&gt;

&lt;p&gt;很多时候，用户是基于信任才使用你的APP，所以，不要因为你的安全意识上的疏忽，失去用户对你的信任。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;苹果为什么也不安全？&lt;/p&gt;

&lt;p&gt;如果你说安卓机不安全，我大概不会反驳。而一直被大家加以信任的苹果，为什么也会有安全隐患，为什么审核的时候没有发现，让这么多有问题的APP顺利的上架？为什么像openURL这样的超级API不能做到更安全？ 这些问题我回答不了，我没有开发过iOS的应用，对iOS的安全性研究不深，但我希望这次事件能更加引起苹果对安全的重视。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这件事件后，我能做什么？&lt;/p&gt;

&lt;p&gt;这件事情被爆出来后，特别是一个大厂的应用也曝光后，我也是第一时间先卸载了手机上的相关的应用。当有人爆出微信也中招时，肯定有很多人和我一样开始非常诧异，难以接受，删了微信我的手机还能干什么？呵呵。然后，你仔细一看，或者别人告诉你，微信6.2.5才有这个问题，最新版已经没有问题了。细心的人马上会发现，微信早在XcodeGhost被爆出来之前就早已发现了这个问题（最早被腾讯安全的团队发现的），然后第一时间加班加点发布了微信6.2.6版本修复了这个问题。&lt;/p&gt;

&lt;p&gt;现在有问题的APP基本已下架，上架的新版本也都修复了这个问题。如果你不放心可以修改一些密码。然而，这次事件之后，我能做什么？或者，给我的启示是什么？这次事件和程序员有关，从写恶意代码的程序员，到下载到含恶意代码的Xcode的程序员，而我刚好也是一名程序员。我能做什么？&lt;/p&gt;

&lt;p&gt;首先，我肯定不会去写恶意代码做坏事，顶多写个脚本抢个票刷个号，也是自己用。然后，在下载软件时，尽量到官方网站下载，对于比较重要的软件，最好下载后校验一下官方的hash。如果是商业付费软件，假如在你的承受范围之内，尽量还是购买正版。在你不断寻找破解补丁的过程中，有无数个包含恶意代码的软件正在向你招手。对于个人开发者，有很多软件都有了Community版本，像Visual Studio，Unity，JetBrains PyCharm等等开发工具，社区版本已经完全够用了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;最后:3500cef42208a15fa70ada140640cf08&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;希望这次事件正如自称XcodeGhost作者声称的那样不会有什么实际危害，同时，我更希望通过这次事件，能引起更多的人或公司关注我们的APP安全。用户信任你的APP，请做好你的APP的安全保护，不要辜负了用户对你的信任。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>博客图片切换到七牛</title>
            <link>http://blog.coderzh.com/2015/09/20/qiuniu/</link>
            <pubDate>Sun, 20 Sep 2015 20:37:42 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/20/qiuniu/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/qiniu.jpg&#34; alt=&#34;qiniu&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;做为一个独立博客，稳定、速度快是非常重要的指标。在博客的运营过程中，经常会不可避免的需要做迁移。比如，从WordPress到Jekyll，从Jekyll到Hugo。迁移之后，文章里的链接还能不能用，图片还能不能访问，是一个比较重要的问题。文章链接地址可以使用域名或者相对地址的方式方便迁移，而图片则稍微复杂一点点。&lt;/p&gt;

&lt;p&gt;假如图片和网页文件都是在服务器上自己管理，迁移时只需要把图片拷贝过去，然后保持访问的路径不变就可以了。自己管理图片有些不好的地方，首先图片可能占用你大量的服务器存储空间，其次访问时也将消耗服务器大量的流量。另外一种方式，是把图片放在一个第三方的地方，然后通过链接直接使用。而“第三方”就显得尤为重要的，假如这个“第三方”哪天突然倒了或者策略变化，导致之前的所有图片都失效了，将是不可接受的。&lt;/p&gt;

&lt;p&gt;正因为存在这样的需求，所以出现一些专业的提供图片托管的服务，俗称图床服务。这些图床服务通常提供这样一些服务：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图床服务是稳定的，不会轻易中断。你就放心吧。&lt;/li&gt;
&lt;li&gt;通过CDN加速，让你的图片访问速度杠杠的。&lt;/li&gt;
&lt;li&gt;支持自定义域名，迁移过来或者迁移走都可以非常方便。&lt;/li&gt;
&lt;li&gt;提供水印等图片处理服务。（算是一个附加功能）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用图床服务还有一个好处，就是一旦当前使用的图床没法用了，只需要把图片都迁到另外一个图床继续使用，代价非常小。就算没有绑定自定义域名，迁移的时候做个简单的地址替换就可以了。&lt;/p&gt;

&lt;p&gt;在对比了国内的图床服务之后，我还是决定选择老东家金山出来的许式伟做的七牛云存储。七牛在上面四点都做的非常好，而且还提供10G免费空间。目前对我来说已经足够了。&lt;/p&gt;

&lt;p&gt;七牛云存储：&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;www.qiniu.com&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>微信公众号开通了原创保护功能</title>
            <link>http://blog.coderzh.com/2015/09/19/mp-new-start/</link>
            <pubDate>Sat, 19 Sep 2015 00:35:48 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/19/mp-new-start/</guid>
            <description>&lt;p&gt;周三非常意外的收到了微信的原创保护功能邀请，之所以说意外，是因为我没想到这么快就给我发了邀请，毕竟我的公众号关注的数量还不多。但我保证了每篇文章都是原汁原味的原创内容，而且目前保持了一周一更的速度。&lt;/p&gt;

&lt;p&gt;这个公众号是从今年2月底开始运营的，非常感谢所有关注了这个公众号的读者！每次我准备写公众号文章时，我都会提醒自己，我的消息会被强制推送出去到你们的手机里，我必须认真写一些有用的内容，不要浪费大家的时间。虽然这么说，文章的实际打开率还是很低的，这也是可以理解的。我也关注了很多订阅号，很多内容也是被我忽略过去，或者根本来不及看就被堆叠了。&lt;/p&gt;

&lt;p&gt;所以，再次感谢经常或者偶尔打开我文章看的同学！这个公众号运营6个多月了，目前有223个关注，其中大部分是看了我的博客关注的，因为那里放了关注的二维码。关注的数量不多，至少保持了稳定的增长。《从0到1》里有说到，初始用户不需要太多，有数百人就可以，如果他们都觉得非常好用就行了。所以，我只需要认真的写，用心的分享，服务好现有的关注者，让你们感觉到我的文章对你有用就行。至于哪天会不会有个爆发式的增长，我希望能有，但也不去奢求，也许现在这样稳定缓慢的增长也挺好。&lt;/p&gt;

&lt;p&gt;开了原创保护功能的同时，也开了评论功能，这是我一直都想要的功能啊。因为我要服务好你们，所以需要和你们更多的沟通和互动啊。&lt;/p&gt;

&lt;p&gt;看到这篇文章后，希望你们能给我一些反馈，说一说当初为什么关注hacker-thinking：一个程序员的思考，或者你更希望从这个公众号了解哪些方面内容的文章，或者，是其他任何的东西。：）&lt;/p&gt;

&lt;p&gt;还没有关注的同学，也关注一下吧：）微信公众号：hacker-thinking&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.coderzh.com/public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;谢谢支持！&lt;/p&gt;

&lt;p&gt;最后上个图，上周刚收到的HHKB :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HHKB.jpg-w&#34; alt=&#34;HHKB&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>坑爹的多说评论</title>
            <link>http://blog.coderzh.com/2015/09/18/holy-shit-duoshuo/</link>
            <pubDate>Fri, 18 Sep 2015 19:38:18 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/18/holy-shit-duoshuo/</guid>
            <description>&lt;p&gt;运用了各种奇技淫巧的黑科技手段，终于把之前旧页面的多说评论全部转过来了。如果再来选择一次的话，我绝不选多说。之后有时间，全部转移到disqus吧。&lt;/p&gt;

&lt;p&gt;多说简直就没人维护啊有木有，居然还那么多人用着。罗列一下多说评论的各种不人性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;残废的评论通知功能&lt;/p&gt;

&lt;p&gt;简直就收不到任何通知啊，有木有，别人回复了根本没有邮件通知，页面右上角的弹框通知也木有啊。直到上周实在不能忍了，在我的VPS上跑了一个多说实时邮件提醒脚本：&lt;a href=&#34;https://gist.github.com/coderzh/bec0eb7e8f0cddba657b&#34;&gt;https://gist.github.com/coderzh/bec0eb7e8f0cddba657b&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;后台管理文章不能翻页&lt;/p&gt;

&lt;p&gt;文章列表只显示第一页，不能翻页，还怎么管理！逼到我使出了绝招，让它能翻页。。。本着大家以后都别用多说的心态，我就不透露具体方法了。如果你真想知道就留个言。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;评论迁移不人性&lt;/p&gt;

&lt;p&gt;网址变了，或者说data-thread-key变了之后，想把评论也迁移到新的地址。只能去后台编辑旧的data-thread-key，改成新的地址的data-thread-key。假如新的data-thread-key文章项已经存在，是修改不了的，这说的过去。假如新的data-thread-key的文章被删除后，旧的文章怎么也改不了data-thread-key成新的。最后只能曲线救国了，想知道的留言。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;垃圾的垃圾评论过滤&lt;/p&gt;

&lt;p&gt;评论后台里，偶然发现“垃圾评论”一项，而且发现里面有东西，明明不像是垃圾评论却被归到那里，而且没有任何通知。更坑爹的是：“(系统将自动清理发表于 30 天前的垃圾评论)”holy shit!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages</title>
            <link>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</link>
            <pubDate>Sun, 13 Sep 2015 08:48:52 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</guid>
            <description>

&lt;p&gt;本文的主要内容如标题所示，通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages。如果你正好有这个需求，看这篇文章正好，可以节省你不少时间。如果不是，了解一下也无妨。&lt;/p&gt;

&lt;p&gt;首先，必须解释一下，为什么需要自动部署，以及为什么需要需要同时部署到GitHub Pages和GitCafe Pages。&lt;/p&gt;

&lt;h3 id=&#34;为什么要自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么要自动部署&lt;/h3&gt;

&lt;p&gt;使用Hugo生成的静态页面是在public文件夹里，部署的时候需要把public文件夹里的内容push到GitHub的gh-pages分支里。每次写完文章，除了push markdown格式的文章，还需要单独push生成的public文件夹里的东西，步骤稍显麻烦。&lt;/p&gt;

&lt;p&gt;之前参照了官方的做法，使用subtree来push public，步骤简化不少。然而，这还是不够简单。因为每次修改文章之后，必须依赖一个脚本才能正确提交和部署。假如你在手机里浏览时，发现一个错别字，顺手就在GitHub的Web界面就把错别字改了，然而这样并不会重新生成静态页面和部署。有些不方便。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面和部署的过程应该让机器自动来完成。&lt;strong&gt;写作应该是一个相对单纯的事情，使用Hugo的人应该更专注于写作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要同时部署到github-pages和gitcafe-pages:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么需要同时部署到GitHub Pages和GitCafe Pages&lt;/h3&gt;

&lt;p&gt;大公司很喜欢的一个词：容灾。GitHub出现不可访问的事情在国内也是常有的，而GitCafe作为国内的代码托管厂商，是否是一个稳定的存在也不好说。所以，将网站同时部署到这两个上面。通过DnsPod里CNAME设置线路“国内”和“国外”，不仅起到了任何一个挂掉，另一个可以继续工作的目的，还起到了CDN就近访问的作用。&lt;/p&gt;

&lt;p&gt;使用GitCafe还有另外一个原因。GitHub Pages拒绝了一切百度的爬虫，所以，百度无法索引到GitHub Pages的网页。对于国内的搜索市场来说，百度的份额还是比较大的，虽然我认为看我的博客的人都不应该使用百度，但现实总是残酷的。如果希望网站被百度收录，就必须放到GitHub以外的地方。GitCafe就是一种比较好的选择。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gitcafe.com&#34;&gt;http://gitcafe.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果，你只是希望使用官方的Hugo自动化部署到GitHub Pages，下面的内容你可以不用看了。你可以直接使用Wercker的服务来自动部署。&lt;/p&gt;

&lt;p&gt;文档见：&lt;a href=&#34;http://gohugo.io/tutorials/automated-deployments/&#34;&gt;
http://gohugo.io/tutorials/automated-deployments/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于Wercker还不支持GitCafe的部署，以及我需要使用特定的修改版本的Hugo来生成静态网页，并且希望这些步骤比较可控，所以，还是自己来折腾整个过程吧。&lt;/p&gt;

&lt;h3 id=&#34;webhook:f7c51a9b685c2720baf98649c3938c48&#34;&gt;webhook&lt;/h3&gt;

&lt;p&gt;webhook是GitHub上提供的Git的一种Hook机制，当代码发生变化时，比如代码被Push到GitHub的Repo时，GitHub会自动请求一个你指定的网页，并且把变更相关的参数都传递过来。入口在Repo的Settings - webhooks &amp;amp; services&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/WebHook.png-w&#34; alt=&#34;webhook&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明文档：&lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;https://developer.github.com/webhooks/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;借助webhook的机制，我们就可实现当有新的文章Push之后，自动通知远程的一台机器执行一个脚本，脚本的内容就是生成静态页面和Push部署到最终的服务器。&lt;/p&gt;

&lt;p&gt;webhook的Server接收webhook通知，然后执行一个脚本。这样的需求太普遍了，以至于完全不需要自己来实现。在GitHub里搜webhook可以搜出来很多。我主要挑选了Go语言的版本。主要有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qiniu/webhook&#34;&gt;https://github.com/qiniu/webhook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adnanh/webhook&#34;&gt;https://github.com/adnanh/webhook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个是七牛写的，代码很简单，用法也很简单。开始打算用七牛的版本。最后调试的时候发现json解析失败，完全不可用啊！有点坑爹。于是换成了第二个，这个Repo有200多个Star。还是靠谱很多，最后部署，调试，非常顺利。&lt;/p&gt;

&lt;p&gt;用法也很简单，首先安装webhook：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/adnanh/webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写一个配置文件hooks.json，里面指定需要执行的脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;redeploy-webhook&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/scripts/redeploy.sh&amp;quot;,
    &amp;quot;command-working-directory&amp;quot;: &amp;quot;/var/webhook&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定端口启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /path/to/webhook -hooks hooks.json -port=9876 -verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后它将接受webhook地址：（把它填到GitHub里的webhook里）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://yourserver:9876/hooks/redeploy-webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;自动部署&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/AutoDeploy.png-w&#34; alt=&#34;AutoDeploy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大致的流程如上图。上图的DigitalOcean是一台VPS服务器，我用了很长时间了，速度和稳定性都不错。需要的同学使用这个链接购买，可以获得10美元的优惠：&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;https://www.digitalocean.com/?refcode=e131e2bba197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整个流程中，复杂度主要是在DigitalOcean的VPS上部署服务和脚本。&lt;/p&gt;

&lt;p&gt;部署的脚本可以在我的GitHub上看到：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要的同学可以参考下，代码见：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&#34;&gt;deploy.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;deploy.py放到你的主工程，也就是你写markdown的Repo下。比如：/var/coderzh-hugo-blog/下&lt;/p&gt;

&lt;p&gt;adnanh-webhook的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;hugo-deploy&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/webhook/hugo-deploy.sh&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hugo-deploy.sh里执行deploy.py：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
 
python /var/coderzh-hugo-blog/deploy.py --auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下的是怎么在DigitalOcean的VPS上把这套东西部署起来。我使用nginx + supervisor搭建webhook的Server。&lt;/p&gt;

&lt;p&gt;关于nginx和supervisor可以参考之前的一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2014/05/19/digitalocean/&#34;&gt;http://blog.coderzh.com/2014/05/19/digitalocean/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;supervisor的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[program:webhook]
command=/root/gocode/bin/webhook -hooks /var/webhook/hooks.json -verbose -port=9876
user=root
directory=/var/webhook
autorestart=true
redirect_stderr=true
environment=HOME=&amp;quot;/root&amp;quot;,USER=&amp;quot;root&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于VPS上SSH Key的设置，见：&lt;a href=&#34;https://help.github.com/articles/generating-ssh-keys/&#34;&gt;https://help.github.com/articles/generating-ssh-keys/&lt;/a&gt;  为了自动部署方便，可以不设置密码。&lt;/p&gt;

&lt;p&gt;当然，还有个大前提，在VPS上安装最新版本的golang。推荐使用gvm来安装。（记得安装1.5之前必须先把1.4先装上）&lt;/p&gt;

&lt;p&gt;golang 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
source ~/.bashrc
gvm version
gvm install go1.4
gvm install go1.5.1
gvm use go1.5.1 --default
go version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，Good Luck！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>周末折腾的各种东西</title>
            <link>http://blog.coderzh.com/2015/09/05/busy-weekend/</link>
            <pubDate>Sat, 05 Sep 2015 23:44:48 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/05/busy-weekend/</guid>
            <description>

&lt;p&gt;这个周末放了3天假，第一天当然是要看盛大的阅兵仪式了，剩下的时间一半多是在折腾博客系统Hugo，剩下的时间在折腾各种工具、IDE，还有学习了一下Unity。&lt;/p&gt;

&lt;h3 id=&#34;折腾hugo:0c17b4d209ef6269100e3287d9d742ad&#34;&gt;折腾Hugo&lt;/h3&gt;

&lt;p&gt;上次给Hugo提了个Pull Request，提供了路径是否转换为小写的配置功能，最后被接受了，走过了一次完整的Pull Request流程，学到不少东西。周末继续折腾Hugo，又发现一个问题，文章的字数统计和70个字的摘要在我的博客里明显是不准确的，而且错的离谱。&lt;/p&gt;

&lt;p&gt;于是看了下Hugo的代码实现，发现字数统计只是简单的根据空格统计单词的总数。而我们中文的语言，哪来那么多空格，文字都是一个挨着一个，按照英文的字数统计方法，一个几千字的文章最后被统计出来只有一百字也是经常的事情。&lt;/p&gt;

&lt;p&gt;还有摘要的功能，如果没有主动使用``作为摘要的分隔符，Hugo会自动截取文章的前70个单词，并且保证截取的文字最后是一个完整的句子。数多少个单词的方法和字数统计是一样的，截取完整句子是往后找，直到找到下一个句号问号之类的。在中文博客里，这样的摘要截取方法常常导致把整篇文章当做了摘要。这也是不可接受的。&lt;/p&gt;

&lt;p&gt;于是，我尝试去修改字数统计和摘要截取算法，让它能适应中文、日文或者其他类似语言。首先是字数统计，比如“Hello 中国”应该被识别为3个词：Hello、中、国。怎么做呢？Golang里unicode/utf8的Package，提供了方法计算有多少个Rune，而Rune并不是Word，只是字符，比如“Hello 中国”调用RuneCountInString的结果会是8。&lt;/p&gt;

&lt;p&gt;于是，我借助utf8库里的一些方法，近似的实现了中英文文字的字数统计和摘要截取算法。说近似，因为实现方法不是很严谨，我不懂其他国家的语言，不知道其他国家语言在这样的算法下是否能保证正确。但我还是抱着试一试的态度，将我的修改给Hugo又提了一个Pull Request。&lt;/p&gt;

&lt;p&gt;在和Hugo主要维护者之一bep多次沟通之后，他提出，我的实现的确不是很严谨，不能保证所有语言都适用。而且，关于字数统计，他之前已经实现过一个类似的方法：RuneCount。于是我又回去把漏看的代码又看了一遍，果然已经有一个RuneCount的方法，用来统计有多个Rune。对，是Rune，不是Word，所以“Hello 中国”RuneCount的结果是7（空格会被忽略）。而我要的结果是3啊。&lt;/p&gt;

&lt;p&gt;后来我仔细一想，我真的这么在意有多少个英文单词和汉字吗？我在意的只是不要简单的根据空格分隔来统计字数，在意的只是说好的70个字的摘要，结果把整篇给做成了摘要。所以，使用RuneCount也OK啊，于是我就把之前的字数统计代码的改动还原了。bep提供了按Rune统计字数，但是没有提供按Rune截取摘要，于是我把之前稍微有些复杂的改动还原，提供了一个简短的按字符截取摘要的方法，并且补充了相应的测试案例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TruncateStringByRune(str string, max int) (string, bool) {
    str = strings.Join(strings.Fields(str), &amp;quot; &amp;quot;)
    count := 0
    for index, rune := range str {
        if count &amp;gt;= max {
            return str[:index], true
        }
        if !IsWhitespace(rune) {
            count++
        }
    }
 
    return str, false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做完这次修改后，继续Pull Request啊，可是现在的Pull Request状态显示我有两次commit，而且前一次已经Push了。于是又学了一招如何将新的commit和之前已经Push的commit合并成一个commit。首先我的修改是在单独分支commit和push的，当前的master是并没有这两次commit，这时就可以通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git rebase -i master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编辑里面的commits，将需要被合并的pick改成squash，保存退出后再重新编辑commit message，然后就变成了一个commit，这时再来个强制push：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git push origin coderzh-hugo -f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是一开始了和挪威程序员bep的多次交涉，他又提出他开始后悔当初提供了RuneCount方法，他认为Hugo提供的方法应该越少越好，干同样一件事情不应该有多个不同的实现版本。而且他不但不认为我又加了一个RuneSummary方法是对的，他还打算把原来的RuneCount方法也删除，并且他十分确信能提供一个统一的版本，既能处理西方文字也能正确的处理中文、日文等其他语言文字。&lt;/p&gt;

&lt;p&gt;我虽然有些沮丧，但还是同意他的，于是我给他回复了我的想法（当然，原回复是英文的）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“我完全同意你的观点。但是我加了个RuneSummary方法也是有我的考虑的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;统计中文类语言的字数和摘要截取需要消耗更多一点的性能。我提供两个版本的实现，可以让英语系的用户还是原来的方法而不会损耗性能。&lt;/li&gt;
&lt;li&gt;摘要截取时，我不认为必须严格按照70个单词以及文字需要保证是一个完整的句子的方式来截取。因为一旦单词或句子很长时，整个摘要内容将会变的很长。而我需要的，仅仅是让所有的摘要都变得一样长，我才不在乎句子被截断。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，我还是完全同意你的观点并且期待你的更好的统一的实现方式。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后bep有点被我说动了，回了一句：Let me think a little about this.&lt;/p&gt;

&lt;p&gt;至少，我的修改版本是适用于我的，所以我自己用着就好啦，至于Hugo官方如何来提供，还是等等吧。&lt;/p&gt;

&lt;h3 id=&#34;visual-studio-2015:0c17b4d209ef6269100e3287d9d742ad&#34;&gt;Visual Studio 2015&lt;/h3&gt;

&lt;p&gt;我之前用Unity开发游戏时的版本记得还是4.6，现在已经出了5.1.3版本了。社区免费版本已经几乎提供了所有功能，学习把玩已经足够了。Unity自带的MonoDevelop是很难用的，还是Visual Studio好用，毕竟是世界上最好的IDE（笑~）。在VS里装个UnityVS简直可以走遍天下了。我之前一直用的是Visual Studio 2013，打开UnityVS的下载地址一看，默认只提供了Visual Studio 2015的UnityVS插件。哦？嘿嘿，趁这个机会，我也升个Visual Studio 2015试试。VS2015同样是Community版本提供了所有我需要的功能，所以完全不需要其他版本和破解序列号了。&lt;/p&gt;

&lt;p&gt;装完VS2015，装好UnityVS插件，还需要安装另外两个神器啊，没有这两个神器，代码还怎么写？！一个是Visual Assist，一个是Viemu。作为一个Vimer，即使在IDE里也是要开启Vim模式的，毕竟，Vim才是世界上最好的编辑器啊（逃~）。&lt;/p&gt;

&lt;p&gt;该装的都装好了，是不是可以愉快的写代码了？字体！对了，听说有一种专门为程序员设置的字体，我一定要试试。于是去下载了&lt;a href=&#34;http://sourcefoundry.org/hack/&#34;&gt;Hack&lt;/a&gt;  字体。果然一使用就爱上了这种字体。如果想看效果，在网页里打开这篇博客，上面的代码高亮部分就是Hack字体。&lt;/p&gt;

&lt;p&gt;最后，终于可以愉快的玩耍了。&lt;/p&gt;

&lt;h3 id=&#34;markdown-here:0c17b4d209ef6269100e3287d9d742ad&#34;&gt;Markdown Here&lt;/h3&gt;

&lt;p&gt;这是另外一个神器，简直要节省我N多N多的编辑排版时间啊。之前我写好的Markdown格式的文章贴到微信公众平台的编辑器里，还要再编辑很久才能达到最终效果。而使用&lt;a href=&#34;https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa/reviews&#34;&gt;Markdown Here&lt;/a&gt;  这个Chrome插件，只需要在我将Markdown格式的文字拷贝到微信公众平台的编辑器里之后，按CTRL+ALT+M，立即会变成排版精良的有格式文字，而且几乎不需要再加工。其他地方的编辑器里也适用哦，谁用谁知道。&lt;/p&gt;

&lt;p&gt;希望我折腾的东西对你有些许帮助，我也心满意足了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>给Hugo提交了一个PR</title>
            <link>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</link>
            <pubDate>Thu, 03 Sep 2015 08:55:31 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</guid>
            <description>&lt;p&gt;给Hugo提交了一个Pull Request，并且通过了，记录一下。PR的内容是在config里增加了disablePathToLower选项，可以配置是否需要阻止Hugo自动将路径转换为小写。在站点从旧的系统里迁移到Hugo中时会非常有用。&lt;/p&gt;

&lt;p&gt;在上一篇博客&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;  里提到，Hugo强制将所有路径都变成了小写。小写路径虽好，但是如果之前你的网站路径不是全小写的，迁移过来路径发生变化，将会导致路径失效，是不可接受的。&lt;/p&gt;

&lt;p&gt;上文提到，我硬改了Hugo代码，让它不要强制转换小写路径。这样的做法不够优雅，假如别人也和我有一样的需求怎么办？我们还是希望Hugo本身就能够提供这样的功能。于是，我决定把代码改的优雅一些，给Hugo作者提交一个Pull Request，将这个功能合并到Hugo代码里。&lt;/p&gt;

&lt;p&gt;于是，我在config文件里增加了一个选项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Do not make the url/path to lowercase
disablePathToLower: true 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加一个开关其实很简单，只需要在command/hugo.go里的LoadDefaultSettings函数里增加一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;viper.SetDefault(&amp;quot;DisablePathToLower&amp;quot;, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开关生效的实现也很简单，找到最终转换为小写的函数，加入disablePathToLower开关的判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MakePathSanitized(s string) string {
    if viper.GetBool(&amp;quot;DisablePathToLower&amp;quot;) {
        return MakePath(s)
    } else {
        return strings.ToLower(MakePath(s))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前的函数名叫MakePathToLower，由于我在内部加了个开关，于是名字不适用了，于是修改为了：MakePathSanitized。&lt;/p&gt;

&lt;p&gt;修改完成之后，需要把测试案例跑一遍，保证你的修改不会破坏原来的逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go test ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也要保证编译是成功的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我修改的第一个版本时，我犯了一个错误，导致测试案例没有通过。原因是第一个版本我增加的配置选项是PathToLower，默认值是true。而有些测试案例是没有去设置PathToLower的，默认读到的会是false，从而导致执行失败的执行结果。所以，config里增加的选项，默认值尽量是false吧，也会好理解一些。于是就有了：disablePathToLower&lt;/p&gt;

&lt;p&gt;提交Pull Request时，有几点需要注意的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将自己的修改合并成一个commit再提交Pull Request。（这样在主Resp里更加规范和整洁）&lt;/li&gt;
&lt;li&gt;commit message里的描述尽量简洁清晰，如果有对应的issue ID，最好加上：See #1234 or Fixes #1234 之类的。这样可以自动关联起来。&lt;/li&gt;
&lt;li&gt;不要在自己的master分支上修改提交PR，而是应该自己开一个单独分支，由该分支提交Pull Request到原Repo的master。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，我提交了这么一个Pull Request：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;add configuration variable: &amp;ldquo;disablePathToLower&amp;rdquo; See #557&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不久后，Hugo的主要维护者之一通过了我的PR，很友善的将我蹩脚的中国式英语的commit message调整了一下合并到了Hugo的master：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoPR.png-w&#34; alt=&#34;HugoPR&#34; /&gt;&lt;/p&gt;

&lt;p&gt;commit: &lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就是开源项目的好处，开源社区的魅力所在：&lt;strong&gt;你可以使用它，修改它，贡献自己的代码，参与其中，让它变好，让所有人受益&lt;/strong&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用hugo搭建个人博客站点</title>
            <link>http://blog.coderzh.com/2015/08/29/hugo/</link>
            <pubDate>Sat, 29 Aug 2015 16:52:15 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/29/hugo/</guid>
            <description>

&lt;p&gt;Hugo是一个用Go语言编写的静态网站生成器，它使用起来非常简单，相对于Jekyll复杂的安装设置来说，Hugo仅需要一个二进制文件hugo(hugo.exe)即可轻松用于本地调试和生成静态页面。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面的效率很高，我的260多篇博客文章生成几乎是瞬间完成的，而之前用Jekyll需要等待10秒左右。&lt;/p&gt;

&lt;p&gt;Hugo自带watch的调试模式，可以在我修改MarkDown文章之后切换到浏览器，页面会检测到更新并且自动刷新，呈现出最终效果，能极大的提高博客书写效率。再加上Hugo是使用Go语言编写，已经没有任何理由不使用Hugo来代替Jekyll作为我的个人博客站点生成器了。&lt;/p&gt;

&lt;h3 id=&#34;静态网站生成器:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;静态网站生成器&lt;/h3&gt;

&lt;p&gt;什么是静态网站生成器？如果追溯到最早的网站形式，那时候的网页都是静态的，即一个内容不变的html文件放在服务器上，人们通过互联网访问浏览的都是这个一成不变的页面。后来，人们发现，需要和网页进行交互，能根据用户的输入动态呈现出相应的内容，这就是动态网站。那，为什么现在又回归使用静态网站呢？特别是对于博客网站这种特殊的形式。我的理解是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问速度提升。静态页面不需要像动态页面那样经常去查询数据库，而是直接将最终页面内容返回。&lt;/li&gt;
&lt;li&gt;搜素引擎友好。便于搜索引擎索引，比如很多动态网站的页面地址是一样的，只是后面传入的参数不一样，容易让搜索引擎误认为是同一个页面。（虽然不会）&lt;/li&gt;
&lt;li&gt;可以完全抛弃数据库，减少复杂度，将最复杂的一步交给静态网站生成器，自己只专注写作、生成、发布三个步骤。&lt;/li&gt;
&lt;li&gt;博客文章可以以文本文件的方式（MarkDown）在本地维护管理，不需要像之前那样在网页的编辑器里提交到网站数据库。你可以方便的使用github管理你的博客文章，不会丢失，又能追溯到每一次的内容变更。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前最流行的静态网站生成器是Jekyll，它是github创始人自己实现的一套ruby的静态网站生成器。一经推出，各个程序哥竞相效仿，一时间使用Jekyll搭建自己的博客变成了一件很高逼格的事情。&lt;/p&gt;

&lt;p&gt;我也是跟风者之一，在Jekyll之前，我主要也是在博客园写文章，同时独立博客这块也尝试过自己实现的博客程序，用GAE写过，后来又用Tornado写过，都是动态网站。自己实现博客程序，总是在开始一段时间内很狂热，当一切实现完成，细节修缮好之后很快就失去了兴趣。因为你的注意力从只是写文章，经常转移到其他地方去。比如网站不好看，需要去改一改网站的风格样式，修复BUG，加一加功能等等。&lt;/p&gt;

&lt;p&gt;所以，如果只是专注于写作，还是找一个稳定一些，提供大量现成皮肤，有稳定专业的组织维护更新的博客系统。使用Jekyll确实让我眼前一亮，原来博客程序可以这么玩。于是利用周末的时间，我将我之前所有的文章，包括博客园的文章，都迁移到了Jekyll上来。自从有了Jekyll，我终于可以开开心心的专注的写文章了，而且使用喜欢的MarkDown格式。：）&lt;/p&gt;

&lt;p&gt;在使用了Jekyll一段时间后，它的问题也逐渐暴露出来：静态页面生成的效率不够高。因为我把以前的文章都导入了过来，一共有260来篇，每次编辑文章后，需要等等10秒，待它将所有页面检查并生成完成之后，才能看到最终的效果。这是我最不能忍受的一点。对于初学者，Jekyll还有很多问题，比如环境搭建非常复杂，导致使用Jekyll的人大都是一些喜欢折腾，不怕折腾的程序哥。&lt;/p&gt;

&lt;p&gt;随着Go1.5版本的发布，让我意识到是时候好好玩一玩Go语言了。使用Go语言实现的静态网站生成器Hugo（雨果）立即吸引了我，它解决了我最大的痛点：生成的效率。文档、社区各方面的支持都不错，使用起来非常简单，各种皮肤直接套用，于是我又开始了Jekyll迁移到Hugo的漫漫长路。（一个周末的时间）&lt;/p&gt;

&lt;p&gt;&lt;del&gt;即使迁移到了Hugo，我还保留着原来的Jekyll博客，只是不会再更新了，用来怀念？还是哪天突然又跳回来也不一定。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我的Jeklly博客：&lt;a href=&#34;http://jekyll.coderzh.com&#34;&gt;http://jekyll.coderzh.com&lt;/a&gt;&lt;/del&gt; Update(2015-09-20): 觉得没啥用了，还是干掉了&lt;/p&gt;

&lt;p&gt;我的Hugo博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;github-pages:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;GitHub Pages&lt;/h3&gt;

&lt;p&gt;使用静态网站生成器生成好静态页面之后，需要把文件放到服务器上供别人浏览。比较传统的方式是租用VPS虚拟服务器，比如：linode、digitalocean。将生成好的静态页面手工上传到服务器上。如果你习惯这种方式部署，推荐你使用&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;digitalocean&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然， 还有更好的方式，就是直接把网站托管到GitHub Pages。你只需要在GitHub上创建一个项目，然后将生成出来的静态页面文件push到这个项目的gh-pages分支，保证根目录有一个index.html文件即可。这样，一个免费、无限流量的博客系统就搭建完成了。同时，通过github你可以方便对博客文章进行管理和追踪。&lt;/p&gt;

&lt;h3 id=&#34;hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hugo&lt;/h3&gt;

&lt;p&gt;前面的铺垫介绍的差不多了，该主角上场了。Hugo是什么？它主要做了什么？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hugo只有一个二进制文件（比如Windows里只是一个hugo.exe）&lt;/li&gt;
&lt;li&gt;Hugo可以将你写好的MarkDown格式的文章自动转换为静态的网页。&lt;/li&gt;
&lt;li&gt;Hugo内置web服务器，可以方便的用于本地调试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hello-hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hello Hugo&lt;/h3&gt;

&lt;p&gt;Hugo官方主页：&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo的安装方式有两种，一种是直接下载编译好的Hugo二进制文件。如果只是使用Hugo推荐用这种方式。另一种方式是获取Hugo的源码，自己编译。由于各种不可预料的网络问题，第二种方式不是那么轻易能成功，虽然最后我还是折腾出来了。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来后，只有一个叫hugo或者hugo.exe的程序，接下来开始生成自己的站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后hugo会自动生成这样一个目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简要介绍一下，config.toml是网站的配置文件，这是一个TOML文件，全称是Tom&amp;rsquo;s Obvious, Minimal Language，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。&lt;/p&gt;

&lt;p&gt;content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。&lt;/p&gt;

&lt;p&gt;进入生成的site目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是博客日志，最好将md文件放在content的post目录里。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+++可以替换为Jekyll一样的---，里面的内容是这篇文章的一些信息。下面就可以开始写你的文章内容，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++

### Hello Hugo

 1. aaa
 1. bbb
 1. ccc

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，刚才的about.md也有内容，该看看最后的效果了。然后你屁颠屁颠的使用hugo server启动，打开浏览器里一看，发现毛都没有！这是肿么了！&lt;/p&gt;

&lt;p&gt;这是Hugo对初学者非常不友好的地方，默认生成的网站是没有任何皮肤模板的。为了看看第一个写的示例，还得去Github上把一个网页模板下载下来。如果你网络够好，网速够快，你可以在刚才的目录将Hugo官方的所有模板都下载下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我尝试过，也失败过，且从未成功一次性将所有的模板下载下来。所以，我们还是老老实实只下载其中一个模板来看看效果吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd themes
$ git clone https://github.com/spf13/hyde.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动本地调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo server --theme=hyde --buildDrafts --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里打开：&lt;a href=&#34;http://127.0.0.1:1313&#34;&gt;http://127.0.0.1:1313&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoFirstPost.png-w&#34; alt=&#34;HugoFirstPost&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ndash;watch或者-w 选项打开的话，将会监控到文章的改动从而自动去刷新浏览器，不需要自己手工去刷新浏览器，非常方便。&lt;/p&gt;

&lt;p&gt;如果你看了上面的说明已经有冲动去试一试Hugo了，我的目的也算达到了，接下来你需要的只是查看官方的说明文档就够了，所以具体的一些设置我就不重复了。&lt;/p&gt;

&lt;p&gt;官方文档：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;皮肤列表：&lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;https://github.com/spf13/hugoThemes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;常用文档：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/overview/configuration/&#34;&gt;Configuring Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/extras/menus/&#34;&gt;Menus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/templates/variables/&#34;&gt;Template Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;遇到的问题:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;遇到的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;默认的ServerSide的代码着色会有问题，有些字的颜色会和背景色一样导致看不见。&lt;br /&gt;
解决方法：使用ClientSide的代码着色方案即可解决。（见：&lt;a href=&#34;https://gohugo.io/extras/highlighting/#client-side:c4210b265c792cac9a6cf6a5f53b671d&#34;&gt;Client-side Syntax Highlighting&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;URL全部被转成了小写，如果是旧博客迁移过来，将是无法接受的。&lt;br /&gt;
解决方法：&lt;del&gt;我是直接改了Hugo的代码，将URL强制转换为小写那段逻辑去掉了，之后考虑在config里提供配置开关，然后给Hugo提一个PR。如果是Windows用户可以直接&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo&#34;&gt;https://github.com/coderzh/ConvertToHugo&lt;/a&gt; 下载到我修改后的版本myhugo.exe。&lt;/del&gt;&lt;br /&gt;
Update(2015-09-03): 已经提交&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;PR&lt;/a&gt;并&lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;commit&lt;/a&gt;到Hugo，最新版本只需要在config里增加：&lt;br /&gt;
&lt;code&gt;disablePathToLower: true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文章的内容里不能像Jekyll一样可以内嵌代码模板了。最终会生成哪些页面，有一套相对固定而复杂的规则，你会发现想创建一个自定义界面会非常的困难。&lt;br /&gt;
解决方法：无，看文档，了解它的规则。博客程序一般也不需要特别的自定义界面。Hugo本身已经支持了类似posts, tags, categories等内容聚合的页面，同时支持rss.xml，404.html等。如果你的博客程序复杂到需要其他的页面，好好想想是否必须吧。&lt;/li&gt;
&lt;li&gt;如何将rss.xml替换为feed.xml？&lt;br /&gt;
解决方法：在config.yaml里加入：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; rssuri: &amp;quot;feed.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jekyll迁移到hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Jekyll迁移到Hugo&lt;/h3&gt;

&lt;p&gt;Jekyll的文章内容迁移到Hugo中，大部分内容是兼容的，但也有一些地方是不兼容的。主要有以下几个地方需要修改：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jekyll文章能从文件名里的日期部分读取到日期，并将剩余的部分当做的页面url的名称，比如：2015-08-29-first.md。而Hugo只认md文件里的date字段，url的名称如果用文件名的话将会使用完整的文件名（不会去除日期部分）。为了兼容，必须在md的Front Matter里写入url字段，用来说明该页面的相对url地址，从而保持兼容。&lt;/li&gt;
&lt;li&gt;tags, categories等字段必须用列表的方式，不像Jekyll中那样随意了。&lt;/li&gt;
&lt;li&gt;{% raw %} {% endraw %}将不需要了。&lt;/li&gt;
&lt;li&gt;{% highlight ruby %} 变成了{{&amp;lt; highlight ruby &amp;gt;}} 。不过我还是推荐使用``` ruby ```形式，然后使用ClientSide的Highlight，这样两边都兼容。&lt;/li&gt;
&lt;li&gt;需要将Jekyll里的public里的文件拷贝到Hugo的static目录里。&lt;/li&gt;
&lt;li&gt;Jekyll的文章必须放到Hugo的content/post目录里。&lt;/li&gt;
&lt;li&gt;Jekyll只需要push文章内容到github，服务器会自动生成静态页面。毕竟是github的亲儿子。而Hugo需要你将生成的public目录里的内容做为gh-pages分支push上去。具体的简便的方法见：&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假如你之前的博客和我一样是Jekyll的，可以尝试使用我写的&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo/blob/master/ConvertToHugo.py&#34;&gt;ConvertToHugo.py&lt;/a&gt; 工具。这个转换工具逻辑相对比较简单和清晰，如果满足不了你的需求你也可以轻易在此基础上做些修改，如果我能收到PR当然是最好了。&lt;/p&gt;

&lt;p&gt;反正，我是完全使用CovertToHugo.py将我原来的Jekyll博客全部转过来了。而且，我找到了一个非常炫酷的主题，并且在此基础稍微修改下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoBlog.jpg&#34; alt=&#34;HugoBlog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Blog地址：&lt;a href=&#34;http://blog.coderzh.com&#34;&gt;http://blog.coderzh.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update(2015-10-08) 国庆在家给Hugo提了个PR，已经将Jekyll迁移功能集成到了Hugo里，pull最新的Hugo代码，编译Hugo，然后可以执行：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll YourJekyllDir TargetDir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将自动把你的Jekyll站点转换成Hugo的站点。欢迎试用并反馈。&lt;/p&gt;

&lt;h3 id=&#34;关于部署:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;关于部署&lt;/h3&gt;

&lt;p&gt;Update(2015-10-08)&lt;/p&gt;

&lt;p&gt;Hugo部署到GitHub，首先在config.yaml(.toml)里设置好baseurl，然后用Hugo生成静态页面（生成的文件全在public文件夹里）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo -v  --cacheDir=&amp;quot;./cache&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将public文件夹里的全部内容都push到你的GitHub的Repo的gh-pages分支即可。&lt;/p&gt;

&lt;p&gt;官方关于在GitHub部署的文档：&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;https://gohugo.io/tutorials/github-pages-blog/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;自动部署的脚本可以参考我的Repo里的&lt;code&gt;deploy.py&lt;/code&gt;脚本：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;全自动化部署到GitHub和GitCafe，见我的另一篇博客：&lt;a href=&#34;http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/&#34;&gt;通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
