<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术文章 on CoderZh Blog</title>
        <link>http://blog.coderzh.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Sat, 21 Nov 2015 17:48:04 CST</updated>
        
        <item>
            <title>Hugo 自动化部署脚本</title>
            <link>http://blog.coderzh.com/2015/11/21/hugo-deploy-script/</link>
            <pubDate>Sat, 21 Nov 2015 17:48:04 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/21/hugo-deploy-script/</guid>
            <description>

&lt;p&gt;之前我写了一个脚本用来自动部署我的 Hugo 博客，今天闲来无事完善了一下这个脚本，使这个脚本更加通用一些。&lt;/p&gt;

&lt;p&gt;脚本路径：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;原理:5dd178ee6323378b401661424ca0e072&#34;&gt;原理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;deploy.py&lt;/code&gt; 会自动执行 hugo 命令生成静态站点，然后将生成的文件拷贝到上层的一个目录里，然后，在那个目录里将文件 push 到你指定的 Git Repository 里。&lt;/p&gt;

&lt;h3 id=&#34;使用方法:5dd178ee6323378b401661424ca0e072&#34;&gt;使用方法&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 &lt;code&gt;deploy.py&lt;/code&gt; 放到你的 Hugo 站点目录。（和 config.yaml 等文件放一起）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑 &lt;code&gt;deploy.py&lt;/code&gt; 文件，修改你要部署到的 Git Repository：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;GIT_REPO = [
    # [别名,   分支名,     Git Repo 路径]
    [&#39;origin&#39;,  &#39;gh-pages&#39;, &#39;git@github.com:coderzh/hugo-blog-deployed.git&#39;],
    [&#39;gitcafe&#39;, &#39;gh-pages&#39;, &#39;git@gitcafe.com:coderzh/coderzh-hugo-blog.git&#39;],
]
# 部署到哪里，相对上一级目录。比如下面的配置，会部署到 ../gh-pages 目录里
DEPLOY_DIR = &#39;gh-pages&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你的网站需要指定皮肤，需要在 config 文件中指定 &lt;code&gt;theme&lt;/code&gt; 。因为我的脚本在生成静态文件时并不会指定皮肤。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;theme: &amp;quot;rapid&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第一次执行，使用 &lt;code&gt;first&lt;/code&gt; 参数，它会做一些初始化的操作。并使用 &lt;code&gt;-t&lt;/code&gt; 表示只是测试一下，并不会真的 push 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py first -t
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间可能需要输入密码，如果是自动化部署，可在 Git Repo 里添加一个没有密码的 SSH Key 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一切正常，切换到 &lt;code&gt;DEPLOY_DIR&lt;/code&gt; 目录，&lt;code&gt;git log&lt;/code&gt; 看看 commit 记录是否正常。如果一切也如你所愿。则可以把 &lt;code&gt;-t&lt;/code&gt; 参数去掉重新执行一遍，执行真的 push 操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py first
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行完成后，应该已经将生成的静态页面自动 push 到了你指定的 &lt;code&gt;GIT_REPO&lt;/code&gt; 里。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后如需再次手工部署，只需要使用 &lt;code&gt;manual&lt;/code&gt; 参数，速度会快很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py manual
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你想通过 &lt;code&gt;webhook&lt;/code&gt; 来自动部署，使用 &lt;code&gt;auto&lt;/code&gt; 参数，这样在执行 deploy.py 时，会使用 Git 自动更新你当前的 Hugo 站点目录 ，然后部署：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python deploy.py auto
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s all, 祝你好运！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：Vue.js</title>
            <link>http://blog.coderzh.com/2015/11/15/front-end-dev-vuejs/</link>
            <pubDate>Sun, 15 Nov 2015 21:53:51 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/15/front-end-dev-vuejs/</guid>
            <description>&lt;p&gt;上一篇中，探讨了前端框架的前世今生，最后还列举了当前比较火的几个前端框架，比如：Google 的 Angular，老牌的 Backbone , Facebook 的 React 等等。今天，我只想介绍一个小而美的前端框架：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;为什么说 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 是一个小而美的前端框架呢？因为它小， min 版本大小是 72K （ gzip 压缩后是23 K），而 min 版本的 Angular 144K，React 132K。说它小而美并不单单指它的体积，因为还有很多体积比它小的框架，小而美主要是它使用起来太 TM 的简单直观了！&lt;/p&gt;

&lt;p&gt;Vue.js 的中文主页：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;http://cn.vuejs.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在主页中，号称“10 秒钟看懂 Vue.js”，的确是这么回事：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;demo&amp;quot;&amp;gt;
  &amp;lt;p&amp;gt;{{message}}&amp;lt;/p&amp;gt;
  &amp;lt;input v-model=&amp;quot;message&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var demo = new Vue({
  el: &#39;#demo&#39;,
  data: {
    message: &#39;Hello Vue.js!&#39;
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子的效果是在 input 里输入任何内容，会自动出现在 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 里。非常简单直观的进行了数据绑定，只要数据发生变化， View 会自动发生变化。这就是数据驱动的。&lt;/p&gt;

&lt;p&gt;并不是每个人都需要或者有机会去开发一个大型的 Web 应用，那些流行的框架又需要一定的学习曲线，而且很多功能并不需要使用到。或者说，你只想干一件简单的事情，但是由于引入了那些框架，使得自己不得不按照框架的规定定义一个又一个东西，最后仅仅是为了实现一个简单的功能。&lt;/p&gt;

&lt;p&gt;所以，&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 非常适合用于一些小型项目（当然，大型项目也适合。），因为可以快速上手，简单的看下它的文档就可以开始动手了。而且， Vue.js 的执行速度也非常的快。&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;https://github.com/lhorie/todomvc-perf-comparison&#34;&gt;TodoMVC Benchmark&lt;/a&gt; 的评测中，得出的综合评价：Mercury, &lt;strong&gt;Vue&lt;/strong&gt; and Mithril are king.&lt;/p&gt;

&lt;p&gt;在 Safari 6.1, OS X 的评测里，Vue.js 的性能直接排到了第一的位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/todomvc-pef-Safari.png&#34; alt=&#34;todomvc-perf-Safari&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以，我现在就有冲动拿 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 来做点东西了，刚好目前要做的一个项目可以用上，这样可以少写很多烦人的 JavaScript 代码了，简直完美。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt;（读音 /vjuː/, 类似于 view），是一个构建数据驱动的 web 界面的库。它的作者是个中国人：尤小右，真名尤雨溪，之前在 Google Creative Lab 工作过。正是目睹了 Angular 、 Ember 框架的笨重不够灵活，Backbone 不支持数据绑定 ， Knockout 和 Ractive 在组件的嵌套和组合上不够理想，于是他决定自己重新设计一个简洁的 MVVM 数据绑定的前端框架。&lt;/p&gt;

&lt;p&gt;在 GitHub 上， &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 已经收集了 9500 多个 Star，为了让更多人参与进来贡献代码，作者坚持保持代码测试的覆盖率为 100% 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/vue-cov.jpg&#34; alt=&#34;vue-cov&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的目标是通过尽可能简单的 API 实现&lt;strong&gt;响应的数据绑定&lt;/strong&gt;和&lt;strong&gt;组合的视图组件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;响应的数据绑定&lt;/strong&gt; 就是数据驱动视图的概念。它让你在写 Web 应用界面时，只需要关注两件事：数据如何展示和数据如何变化。一旦数据发生变化时，比如用户输入，或者 ajax 请求返回后数据发现修改，对应的视图界面会自动的进行更新。（之前的做法是使用 jQuery 手动操作 DOM 更新界面元素。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mvvm.jpg&#34; alt=&#34;mvvm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;定义好数据如何展示，绑定数据后，就只需要关心数据如何变化的事情了，是不是感觉 So Easy ！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合的视图组件&lt;/strong&gt; 是 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的一个重要概念，有了组件系统，可以很好的复用组件，提高效率，从而也为开发一个大型应用提供了很好的技术保证。&lt;/p&gt;

&lt;p&gt;本文并不是要详细介绍 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 的特点及使用方法，因为要学习 Vue.js ，看官方的文档是最好的学习方式。作者是中国人，自带中文文档已经足够方便让你学习起步。本文的目的只是想介绍 Vue.js ，因为我认为它很了不起。&lt;/p&gt;

&lt;p&gt;在如此激烈的前端框架竞争环境下， 凭借作者一己之力，用小而美，精简易用，性能还那么好的 &lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; 直接挑战了像 Google 、 Facebook 这样公司开发的前端框架。作者在设计框架时，时时刻刻遵循简单、精巧、易用的设计哲学让人钦佩。为保证代码的质量，获得更多的开发者的信赖，作者的每一行代码都经过单元测试，体现了作者的严谨性。这就是我从他身上学到的东西。&lt;/p&gt;

&lt;p&gt;最后，再次给出 Vue.js 的链接：&lt;a href=&#34;http://cn.vuejs.org/&#34;&gt;http://cn.vuejs.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;走进前端开发系列：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/&#34;&gt;走进前端开发之：Bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.coderzh.com/2015/11/07/front-end-dev/&#34;&gt;走进前端开发之：框架的演变&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>网站被随机挂广告，疑似被 HTTP 劫持</title>
            <link>http://blog.coderzh.com/2015/11/14/http-dns-hijack/</link>
            <pubDate>Sat, 14 Nov 2015 19:36:38 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/14/http-dns-hijack/</guid>
            <description>

&lt;p&gt;最近发现我的博客网站随机的会在右下角出现一个 google 的广告，郁闷至极，我的博客网站根本没有任何广告。于是今天特意去查了查，这广告到底从何而来。&lt;/p&gt;

&lt;h2 id=&#34;现象:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;首先，广告长这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/blogads.jpg&#34; alt=&#34;blogads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;太可恨了！我的网站是 &lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;， 检查了网站的源文件，没有被修改的痕迹，也根本不会有什么广告代码。所以怀疑是被运营商劫持了！&lt;/p&gt;

&lt;p&gt;我使用的是广州电信100M光纤，被挂广告只有在家里上电信光纤时会出现，连手机里访问也会有广告：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/phoneads.jpg&#34; alt=&#34;phoneads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是如果手机连的是联通4G，就没有一点问题！&lt;/p&gt;

&lt;p&gt;后来在追查过程中，发现遇到这个问题的不止我一个人，比如，云风在他的新浪微博里说到：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://weibo.com/2388714105/D2013qUSo?type=comment#_rnd1447506909896&#34;&gt;http://weibo.com/2388714105/D2013qUSo?type=comment#_rnd1447506909896&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/yunfengads.jpg-ws&#34; alt=&#34;yunfengads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另一个博主也遇到这个问题：&lt;a href=&#34;http://www.lovefcwr.com/20151110-google-ca-pub-8129816473729933&#34;&gt;网站被黑了随机挂ca-pub-8129816473729933的google广告，怎么办？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还有一个用户在 Google Adsens 也举报了这个广告主：&lt;a href=&#34;https://productforums.google.com/forum/#!topic/adsense/qeeYrD7kvUA;context-place=forum/adsense&#34;&gt;Please help us to stop this Google Adsense user &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;初步分析:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;初步分析&lt;/h2&gt;

&lt;p&gt;这个问题出现在最近1，2个月，被插入广告的都属于同一个广告主：ca-pub-8129816473729933 。&lt;/p&gt;

&lt;p&gt;很多网站广告插入的方式和表现是完全一致的。广告隔断时间会出现一次，刷新网页后就消失了。&lt;/p&gt;

&lt;p&gt;我和云风使用的宽带都是广州电信！（我手机换成联通移动 4G 就没问题。）&lt;/p&gt;

&lt;p&gt;所以，不得不怀疑是电信做了手脚，对访问的网站进行了劫持！电信也不是第一次做 &lt;strong&gt;HTTP 劫持&lt;/strong&gt; 这种事。&lt;/p&gt;

&lt;p&gt;于是，我捕捉了一些现场证据，分析了劫持的脚本和基本原理，然后拨通了中国电信 10000 号。&lt;/p&gt;

&lt;h2 id=&#34;10000-号:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;10000 号&lt;/h2&gt;

&lt;p&gt;电信工作人员矢口否认进行了 HTTP 劫持，把原因归咎到电脑是否中毒了，WIFI 路由器被做了手脚等等。我说我的电脑杀过毒并没有问题，不仅电脑，iPhone 手机访问网页也会被嵌入广告，你是说我的 iPhone 也中毒了吗？而且切换成联通 4G 就没有问题，你说和你们没关系？ WIFI 路由器我也试了把 DNS 设置成各种不同的，包括默认的，甚至把路由器恢复出厂设置，通通没用！&lt;/p&gt;

&lt;p&gt;最后他说可能和我拨号分配到的 IP 是内网 IP有关，帮我恢复到公网 IP 试试。 What ! 难道我的网络之前一直属于你们的局域网？？不应该默认就是公网 IP 吗？？&lt;/p&gt;

&lt;p&gt;然而，切换公网 IP 后也并没有什么用！（中间还出现切换出错，导致我几个小时拨号不成功上不了网，哭了~~）&lt;/p&gt;

&lt;p&gt;打 10000 号目前还未解决问题，解决不了去工信部投诉去。&lt;/p&gt;

&lt;h2 id=&#34;深入分析:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;深入分析&lt;/h2&gt;

&lt;p&gt;访问一个网站，网站的内容都是被恶意篡改过的，这多么可怕。&lt;/p&gt;

&lt;p&gt;于是在 Chrome 里 “审查元素”里跟踪了一下，看看到底是如何篡改的。通过查看 Elements ，发现 html 里被嵌入了以下代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/adsjs2.jpg-w&#34; alt=&#34;adjs2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;picturefill.min.js 是我网站使用的一个正常的 js 文件，查看网页源码发现，出现了两条关于 picturefill.min.js 的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;assets/picturefill/picturefill.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;http://blog.coderzh.com/assets/picturefill/picturefill.min.js?_Ax144746802655173=xxA.baidu.com&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再查看请求 picturefill.min.js 时返回了什么：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/fakejs.jpg-w&#34; alt=&#34;fakejs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/rightjs.jpg-w&#34; alt=&#34;rightjs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面显示，请求 picturefill.min.js 时，返回的竟然是被篡改的内容，被篡改的内容里，先是再次请求了一次原版的 picturefill.min.js ，然后就是插入 google 的广告代码。&lt;/p&gt;

&lt;p&gt;从 google 的广告代码看出，广告主的 ID 是：ca-pub-8129816473729933 ， 正是和云风及之前一位博主说到的广告主是同一个！ Google 你还不赶紧查查他！&lt;/p&gt;

&lt;p&gt;最后这段恶意篡改的 js 代码生成出来的嵌入广告是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/adsjs.jpg-w&#34; alt=&#34;adjs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后又试验了多次，总结了进行 HTTP 劫持的基本套路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;劫持任一 js 的请求，返回包含原 js 及恶意代码的假的 js 内容。&lt;/li&gt;
&lt;li&gt;假的 js 通过 DOM 操作，强行在原来的网页内植入广告。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种恶意修改 DOM 的方式，和之前常见的把原网站套入一个 iframe 的方式有所不同。基本很难防范。&lt;/p&gt;

&lt;h2 id=&#34;解决方法:cf9192f47b41efddf17d905ebd43dd9c&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;打 10000 号，投诉，投诉，再投诉。&lt;/p&gt;

&lt;p&gt;工信部投诉地址：&lt;a href=&#34;http://www.chinatcc.gov.cn:8080/cms/shensus/&#34;&gt;http://www.chinatcc.gov.cn:8080/cms/shensus/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了找出哪一层路由做了手脚，大家通过 traceroute ( Windows 里是 tracert ) 看看访问被植入广告的网站到底经过哪些路由。下面是我的 tracert 结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;D:\Code\Go\coderzh-hugo-blog&amp;gt;tracert blog.coderzh.com

通过最多 30 个跃点跟踪
到 github.map.fastly.net [103.245.222.133] 的路由:

  1    &amp;lt;1 毫秒   &amp;lt;1 毫秒   &amp;lt;1 毫秒 192.168.0.1
  2    12 ms     2 ms     1 ms  113.109.112.1
  3     3 ms     3 ms     3 ms  183.56.38.209
  4     5 ms     3 ms     3 ms  183.56.30.21
  5     9 ms     8 ms     8 ms  202.97.34.114
  6     9 ms     8 ms     7 ms  202.97.34.74
  7   156 ms   158 ms   156 ms  202.97.60.214
  8   158 ms   168 ms   166 ms  ae-1.r30.tokyjp05.jp.bb.gin.ntt.net [129.250.2.157]
  9   164 ms   176 ms   175 ms  ae-17.r01.tokyjp03.jp.bb.gin.ntt.net [129.250.6.117]
 10     *        *        *     请求超时。
 11   164 ms   164 ms   163 ms  103.245.222.133

跟踪完成。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你不是对一个网站很熟悉，你压根发现不了这广告根本不是网站主投放的。&lt;/p&gt;

&lt;p&gt;这种强行修改你访问网页的内容来植入广告的方式，非常可怕。使得我们在上网的时候没有一点安全感。如果你访问一个网站，都不能保证获取到的内容是该网站原版的内容，而是被肆意的插入广告，被修改的内容。那么之后他很可能会骗取你的账号密码，偷走你的隐私，拿走你的存款，这是多么可怕和不可接受的事。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：框架的演变</title>
            <link>http://blog.coderzh.com/2015/11/07/front-end-dev/</link>
            <pubDate>Sat, 07 Nov 2015 08:44:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/07/front-end-dev/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/angular-backbone-react-logo.jpg-wt&#34; alt=&#34;angular-backbone-react-logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上周挖了个坑，这周末怎么也得填上。对于大多数前端框架，我都并未用过，但我还是想聊一聊，这些前端框架从何而来，解决了什么问题，又有哪些高明之处。&lt;/p&gt;

&lt;p&gt;认识了解问题，切忌一头扎进去研究而未了解其全貌。为此，我们追溯到20世纪90年代，网景浏览器横空出世，占据了浏览器市场第一的份额。那时的网景浏览器已经搭载了 Cookie、 Frames 和 JavaScript 等功能，可惜好景不长，再后来与微软的“浏览器大战”中败下了阵来。&lt;/p&gt;

&lt;p&gt;于是网景公司将代码开源，创造了 Mozilla ，也就是现在的 Firefox。可以说，浏览器大战从未停止过，Opera 、 Safari 、 Google Chrome …… 当然，还有微软的 Internet Explorer 以及一些其他的浏览器。各浏览器引擎不同，标准不一，苦了的就是我们的主角：前端开发。&lt;/p&gt;

&lt;h3 id=&#34;排版引擎:4349a6351ab7878e819f52676aaa004b&#34;&gt;排版引擎&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/web-kit-renders.jpg-wt&#34; alt=&#34;web-kit-renders&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所有这些浏览器，使用最广泛的无非是这些引擎： &lt;strong&gt;Gecko 、 WebKit 和 Trident&lt;/strong&gt; 。最早的 Netscape 使用的是 Gecko 排版引擎，后来的 Firefox 继承了它的衣钵。微软从 Spyglass 公司买来技术开发了 Internet Explorer ， 使用了 Trident 引擎。苹果开发了 WebKit ，做出了 Safari 浏览器，后来引擎开源， Google 做出了基于 WebKit 的 Chrome 。&lt;/p&gt;

&lt;p&gt;有人会说，那 QQ浏览器、360浏览器、世界之窗、搜狗浏览器之类的，这些浏览器只是套了 Chrome 或 IE 的内核罢了。&lt;/p&gt;

&lt;p&gt;而和前端程序员打交道的，最终就是这三样东西： HTML 、 CSS 、 JavaScript 。&lt;/p&gt;

&lt;h3 id=&#34;javascript:4349a6351ab7878e819f52676aaa004b&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;HTML 负责描述界面的元素结构， CSS 负责描述界面的样式表现， JavaScript 负责界面元素的交互和与后台数据的交互。早期的静态网页，甚至不需要 JavaScript ，因为不需要太多的交互。即使用到 JavaScript ，最多也是用于表单验证、弹弹提示框。&lt;/p&gt;

&lt;p&gt;随着 Web2.0 的概念炒起来，动态网站逐渐成为主流。早期的动态网站，随便的一个数据更新都要刷新整个页面，体验逐渐变得不可接受。于是，局部数据刷新成了当时的热点，这就是当年炒的很热的 Ajax 技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/ajax.jpg&#34; alt=&#34;Ajax&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ajax 的全称是 Asynchronous JavaScript and XML , 即异步 JavaScript 和 XML 技术。当时炒的神乎其神，而其根本本质其实很简单，就是 XMLHttpRequest ，然后配合 DOM 的操作，就可以变化出各种不同的花样出来。 XMLHttpRequest 负责和服务器交互，返回数据后通过 DOM 的操作动态实时的更新界面元素。&lt;/p&gt;

&lt;p&gt;然而，一个简简单单的 Ajax ，各个浏览器的支持却不同。为了兼容不同的浏览器，导致写 Ajax 变得异常痛苦。比如，一个 XmlHttpRequest 的跨浏览器的通用写法就必须写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Provide the XMLHttpRequest class for IE 5.x-6.x:
// Other browsers (including IE 7.x-8.x) ignore this
//   when XMLHttpRequest is predefined
var xmlHttp;
if (typeof XMLHttpRequest != &amp;quot;undefined&amp;quot;) {
    xmlHttp = new XMLHttpRequest();
} else if (window.ActiveXObject) {
    var aVersions = [&amp;quot;Msxml2.XMLHttp.5.0&amp;quot;, &amp;quot;Msxml2.XMLHttp.4.0&amp;quot;, &amp;quot;Msxml2.XMLHttp.3.0&amp;quot;, &amp;quot;Msxml2.XMLHttp&amp;quot;, &amp;quot;Microsoft.XMLHttp&amp;quot;];
    for (var i = 0; i &amp;lt; aVersions.length; i++) {
        try {
            xmlHttp = new ActiveXObject(aVersions[i]);
            break;
        } catch (e) {}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单单一个 XmlHttpRequest 就让前端程序员百苦难辩，更别说跨浏览器的 DOM 选择与操作、 CSS 的差异…… 前端程序员只能默默檫干眼泪，为了解决这些问题， jQuery 横空出世。&lt;/p&gt;

&lt;h3 id=&#34;jquery:4349a6351ab7878e819f52676aaa004b&#34;&gt;jQuery&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/jQuery.jpg&#34; alt=&#34;jQuery&#34; /&gt;&lt;/p&gt;

&lt;p&gt;jQuery 是一套跨浏览器的 JavaScript 库，既然大家都这么痛苦要处理兼容问题，那何不让我一个人来承受。自 jQuery 从 2006 年 1 月发布第一个版本以来，现在已完全占领市场。据统计，全球前10,000个访问最高的网站中，有65%使用了jQuery 。&lt;/p&gt;

&lt;p&gt;jQuery 不仅解决了浏览器兼容的问题，还提供了大量的简便语法，用于选择和操作 DOM 对象、创建动画效果、处理事件以及 Ajax 的支持。&lt;/p&gt;

&lt;p&gt;得麒麟才子者，可得天下。 jQuery 出来后，有种得 jQuery 者可得前端天下的感觉。随后基于 jQuery 的各种 UI 插件、组件层出不穷，如 YUI 等等，也呈现出百花齐放的气象。&lt;/p&gt;

&lt;p&gt;似乎 jQuery 已经解决了所有问题，而我对前端开发的经验，也止于 jQuery 。 jQuery 的确能解决之前的诸多问题，然而互联网在发展，浏览器的地位不断提高，人们对浏览器里的体验的要求也逐渐变高，Web 端的功能越来越重。 Google 甚至认为你的电脑仅仅需要一个浏览器即可。&lt;/p&gt;

&lt;p&gt;需求越来越多，功能越来越复杂，使得 JavaScript 本身的缺点暴露了出来。 JavaScript 过于灵活，代码的组织过于零散，一旦需求变得复杂，这一大坨一大坨的 JavaScript 代码将变得难以维护。特别是如今崇尚的快速开发、快速试错的开发模式，臃肿、难以组织和维护的 JavaScript 代码成了一个需要重要解决的问题。&lt;/p&gt;

&lt;p&gt;于是，如何将 JavaScript 代码有效的组织和分类，如何简化代码的写法成为了研究的重点。就连 1978 年就被提出的 MVC 模式也被应用到了前端开发的框架之中。&lt;/p&gt;

&lt;h3 id=&#34;mvc:4349a6351ab7878e819f52676aaa004b&#34;&gt;MVC&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/mvc.jpg&#34; alt=&#34;MVC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MVC 是一种软件架构分层的思想。将软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（控制器 Controller）- 负责转发请求，对请求进行处理。&lt;/li&gt;
&lt;li&gt;（视图 View） - 界面设计人员进行图形界面设计。&lt;/li&gt;
&lt;li&gt;（模型 Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVC 的优点是将系统进行了分层，单独的分层变得逻辑更加清晰，便于维护，提高了代码的可重用性，由于各司其职，在响应变化时，也能做出快速反应。&lt;/p&gt;

&lt;p&gt;更多关于 MVC 的历史和介绍，可以参考 Martin Fowler 的文章： &lt;a href=&#34;http://www.martinfowler.com/eaaDev/uiArchs.html&#34;&gt;http://www.martinfowler.com/eaaDev/uiArchs.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;应用到前端开发， MVC 里的 Model 、 View 、 Controller 分别对应：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（控制器 Controller）：业务逻辑，URL Router&lt;/li&gt;
&lt;li&gt;（视图 View）：用户界面，DOM 处理。&lt;/li&gt;
&lt;li&gt;（模型 Model）：数据保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了 MVC ，还有 MVP、 MVVM 等模型。然而，这些所谓的概念真的重要吗？黑猫白猫都是好猫，能解决问题的才是好模型好框架。&lt;/p&gt;

&lt;h3 id=&#34;xxx-js:4349a6351ab7878e819f52676aaa004b&#34;&gt;xxx.js&lt;/h3&gt;

&lt;p&gt;后面出来的 xxx.js 我就不太懂了。比如：&lt;strong&gt;Ember.js、Angular.js、Backbone.js、Knockout.js、React.js&lt;/strong&gt; 。直到写这篇文章前，才打开各自的主页，粗略的浏览了一下各自的 Quick Start ， 了解了一点各自的特性。&lt;/p&gt;

&lt;p&gt;首先，我们来对比一下这几个库在 GitHub 上的 关注度 ：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Type&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Ember.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Angular.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Backbone.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Knockout.js&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;React.js&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Watch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1149&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4036&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1676&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;604&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2261&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Star&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;15036&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;43986&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;23349&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;6903&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30894&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fork&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3233&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;19973&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;5230&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1180&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;4833&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从上面的数据可以看出， &lt;strong&gt;Angular.js 、 Backbone.js 、 React.js&lt;/strong&gt; 几乎占据了半壁江山。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;Angular.js&lt;/a&gt; 由 Google 推出，从上面的 Fork 数据看出， Angular 在社区支持和贡献上最为突出。从首页的介绍示例看出， Angular 使用简单，代码逻辑清晰一看就明白，比如数据双向绑定的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&amp;quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;Name:&amp;lt;/label&amp;gt;
      &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;yourName&amp;quot; placeholder=&amp;quot;Enter a name here&amp;quot;&amp;gt;
      &amp;lt;hr&amp;gt;
      &amp;lt;h1&amp;gt;Hello {{yourName}}!&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://backbonejs.org/&#34;&gt;Backbone.js&lt;/a&gt; 是一个老牌的 JavaScript 框架了，据说后来的 JavaScript 框架都受了它的影响。它的特点是简单、灵活，但是很多事情却要你自己来做。我只是不明白，为什么 Backbone.js 的 Getting Started 会写的那么冗长，对于初学者真的好吗？也许真的是应该是老牌框架的原因吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React.js&lt;/a&gt; 由 FaceBook 开发，现在也是火的不行。 React.js 让人为之眼前一亮的功能是 &lt;strong&gt;虚拟 DOM&lt;/strong&gt; 的机制。前面提到，为了能支持局部刷新，就需要通过 DOM 操作局部更新元素，一旦项目变大需求变的复杂，也会变得难以维护。而虚拟 DOM 解决了这一问题，通过虚拟 DOM ，你只需要关注整体的 DOM ，当数据发生变化时， React 会重新构建整个 DOM 树， 然后与上一次的 DOM 树进行对比，自己计算出需要变化的部分。由于虚拟 DOM 都是在内存中操作，所以性能会非常好。&lt;/p&gt;

&lt;p&gt;React 推崇组件化开发，提供了专有的语言 JSX ，不过并非必须。一个简单的 React 组件的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var HelloMessage = React.createClass({
  render: function() {
    return &amp;lt;div&amp;gt;Hello {this.props.name}&amp;lt;/div&amp;gt;;
  }
});

ReactDOM.render(&amp;lt;HelloMessage name=&amp;quot;John&amp;quot; /&amp;gt;, mountNode);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;趋势:4349a6351ab7878e819f52676aaa004b&#34;&gt;趋势&lt;/h3&gt;

&lt;p&gt;关于 Angular.js 、 Backbone.js 、 React.js ， 如果你是这三种的使用者，也许更有发言权一些。我在百度指数里对比了 angularjs , backbone , react 这三个关键字：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/angular-backbone-react.jpg-ws&#34; alt=&#34;angular-backbone-react&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见 Angular 一经推出便先发制人增长迅猛，而 React 开始阶段和 Backbone几乎并列，但从 2015 年开始爆发，增长速度直指 Angular ， 发展不可估量。&lt;/p&gt;

&lt;h3 id=&#34;总结:4349a6351ab7878e819f52676aaa004b&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;未来前端的世界必定会是天翻地覆，过往的发展历史我能力有限也只能提到这么多。虽然前端框架还在一直往前发展，但我回过头来仔细想想，这样的发展方向正确吗？&lt;/p&gt;

&lt;p&gt;即使很多人并不喜欢 JavaScript ， 但是 JavaScript 凭借早期的浏览器奠定了坚不可摧的地位， JavaScript 有诸多缺陷，后续的框架只是在不断的弥补它的缺陷而已。还有关于各浏览器的支持问题，后续的框架也是在不断的填坑。你们有没有想过，是否有一天，我们能从根本上去解决这些问题，而不是一次又一次的背上历史的包袱。&lt;/p&gt;

&lt;p&gt;为了解决 JavaScript 的问题，甚至出现各种替代语言，而这些所谓的替代语言，也只能算是 JavaScript 的预处理语言，最终还是编译成了 JavaScript 代码，你不觉得有点可笑吗？&lt;/p&gt;

&lt;p&gt;比如，&lt;strong&gt;CoffeeScript、 Flow 、 Dart 、 Babel 、 TypeScript&lt;/strong&gt; 。 而说到 &lt;a href=&#34;http://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;，它的作者是鼎鼎大名的 &lt;strong&gt;Anders Hejlsberg&lt;/strong&gt; 。刚才说麒麟之才，这个才真的是麒麟之才！他是 Turbo Pascal 编译器的作者，后来发明了 Delphi ， 加入微软后主导开发了 C# 。现在，他正致力于 TypeScript 的开发。看了最近关于的他的报道，他表示 TypeScript 并不追求替代 JavaScript ， 并不计划直接运行在浏览器或系统里，而仅仅关注如何编译成 JavaScript 。 这是一种妥协吗？ 还是暂时的低调？未来会如何发展，这是留给前端同学的问题。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo中文文档翻译计划</title>
            <link>http://blog.coderzh.com/2015/11/01/hugo-translate/</link>
            <pubDate>Sun, 01 Nov 2015 23:52:31 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/01/hugo-translate/</guid>
            <description>

&lt;p&gt;中文文档：&lt;a href=&#34;http://www.gohugo.org/doc/&#34;&gt;http://www.gohugo.org/doc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;https://github.com/coderzh/gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo-介绍:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;Hugo 介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://spf13.com&#34;&gt;spf13&lt;/a&gt; 对于 Hugo 的英文原版介绍地址在这，就不另行翻译了：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原文大致意思是当前的静态网站生成工具对环境依赖过多，性能较差，于是使用 Go 语言写了一个静态网站生成器 Hugo 。不仅解决了环境依赖、性能较差的问题，还有使用简单、部署方便等诸多优点，通过 Liveload 实时刷新，极大的优化文章的写作体验。&lt;/p&gt;

&lt;h4 id=&#34;hugo-能做什么:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;Hugo 能做什么&lt;/h4&gt;

&lt;p&gt;通过 Hugo 你可以快速搭建你的静态网站，比如博客系统、文档介绍、公司主页、产品介绍等等。相对于其他静态网站生成器来说，Hugo 具备如下特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;极快的页面编译生成速度。（ ~1&amp;nbsp;ms 每页面）&lt;/li&gt;
&lt;li&gt;完全跨平台支持，可以运行在 &lt;i class=&#34;fa fa-apple&#34;&gt;&lt;/i&gt;&amp;nbsp;Mac OS&amp;nbsp;X, &lt;i class=&#34;fa fa-linux&#34;&gt;&lt;/i&gt;&amp;nbsp;Linux, &lt;i class=&#34;fa fa-windows&#34;&gt;&lt;/i&gt;&amp;nbsp;Windows, 以及更多!&lt;/li&gt;
&lt;li&gt;安装方便 &lt;a href=&#34;http://www.gohugo.org/doc/overview/installing/&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本地调试 &lt;a href=&#34;http://www.gohugo.org/doc/overview/usage/&#34;&gt;Usage&lt;/a&gt; 时通过 &lt;a href=&#34;http://www.gohugo.org/doc/extras/livereload/&#34;&gt;LiveReload&lt;/a&gt; 自动即时刷新页面。&lt;/li&gt;
&lt;li&gt;完全的皮肤支持。&lt;/li&gt;
&lt;li&gt;可以部署在任何的支持 HTTP 的服务器上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关于翻译文档:f3862f833759cf589a5fc35c5cf4902d&#34;&gt;关于翻译文档&lt;/h3&gt;

&lt;p&gt;中文翻译文档目的是让 Hugo 在中国能得到更好的推广，让有需要和对 Hugo 感兴趣的人能从此文档中获得微薄帮助。&lt;/p&gt;

&lt;p&gt;此中文文档的英文原版皆从 Hugo 官方 GitHub 上来：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/tree/v0.14.docs&#34;&gt;https://github.com/spf13/hugo/tree/v0.14.docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;取自 v0.14.0 版本，基于 revision: &lt;a href=&#34;https://github.com/spf13/hugo/tree/acd6ad92c181cd7cdb485467cef0e8986911fb02&#34;&gt;acd6ad9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;翻译文档最麻烦的是能否跟上官方文档的更新， Hugo 官方文档目前虽在 v0.14.0 版本，但也经常有些更新，待本文档翻译完成之后，每隔一定的周期，根据本文所记录的 revision 对原文档进行 diff，然后补上更新内容。&lt;/p&gt;

&lt;p&gt;此次翻译我也希望借助社区之力，如果你对此有兴趣，请前往本站的 GitHub &lt;strong&gt;提交一个 Issue，标题注明希望翻译的文档名称&lt;/strong&gt; 即可。&lt;/p&gt;

&lt;p&gt;Issue 提交地址： &lt;a href=&#34;https://github.com/coderzh/gohugo.org/issues&#34;&gt;https://github.com/coderzh/gohugo.org/issues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;待翻译文档路径： &lt;a href=&#34;https://github.com/coderzh/gohugo.org/tree/master/content/doc&#34;&gt;https://github.com/coderzh/gohugo.org/tree/master/content/doc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后 Fork 该 &lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;Repo&lt;/a&gt; ，通过 Pull Request 的方式提交过来便是。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>走进前端开发之：Bootstrap</title>
            <link>http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/</link>
            <pubDate>Sun, 01 Nov 2015 07:37:56 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/11/01/front-end-dev-bootstrap/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bootstrap.jpg-wt&#34; alt=&#34;bootstrap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如今互联网创业热潮此起彼伏，特别是移动互联网，使得前端开发这一职位变得愈加炙手可热。大量公司欲求高端前端开发而不得，进入前端开发浩瀚大军的同学也是日益增多，大家相互厮杀，占领 &lt;code&gt;GitHub&lt;/code&gt; ，只为获得前端开发的一席之地。新技术新框架如雨后春笋，层出不穷，未跟上步伐者也以迅雷不及掩耳之势被取代淘汰。这是一个前端开发百花齐放的时代。&lt;/p&gt;

&lt;p&gt;这段文绉绉的开场白，只为说明一个道理：再不了解学习前端，你就老了。在我们那个年代（好吧，其实也不久），还未有前端开发这样的职位。那时的网站开发同学哪个不是一把辛酸一把泪的不断挑弄着 &lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; ，纵然有一万个草泥马崩腾而过，也只能默默忍受这混乱不堪的一切，在浏览器兼容这一世纪难题面前，心中只能默念：能用就行，习惯就好。除了搬弄前端的 CSS 和 Javascript ，那时的网站开发同学还要兼顾后端。那时的MVC更像是一个整体的概念，而如今随着前端表现日益丰富，重心不断往前端移，后端只需提供类似 &lt;code&gt;Restful&lt;/code&gt; 接口、处理逻辑、存储数据。单单一个前端，已经衍生出各种MVC框架：Embejs、Angular.js、Backbone.js、Knockout.js、React.js……&lt;/p&gt;

&lt;p&gt;然而，这些前端框架我一个也没有用过。我也不是一个前端程序员，所以在写这篇文章时，我也是诚惶诚恐的。毕竟我一个外行，要是让专做前端开发的读者看了，难免班门弄斧贻笑大方，也许还少不了几句点评指责。当然，我也是虚心接受的。“走进前端开发”我打算写成一个系列文章，目的并不是多深入的介绍和学习前端开发，而是“走进”，或者说“走近”、“了解”，站在一个旁观者的角度去观察了解，前端开发到底是怎样一个群体。&lt;/p&gt;

&lt;p&gt;这是第一篇，主角是： &lt;code&gt;Bootstrap&lt;/code&gt; 。我在做 &lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt; 时就使用到了 Bootstrap 。或多或少你也许听过 Bootstrap 的大名，或者“响应式布局”是否在哪里听过？何为“响应式布局”？响应式布局是指，一个网站只需要做一个版本，就能自动适应和兼容各个终端平台，比如：PC、手机、平板，呈现出最好的表现效果。&lt;/p&gt;

&lt;h3 id=&#34;多终端适配:0b0432fd07b093099631d3dfda0706d0&#34;&gt;多终端适配&lt;/h3&gt;

&lt;p&gt;这样又要说到“多终端适配”的问题了。在响应式布局出现之前，人们是怎么处理多终端适配的呢？主要有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;跳转适配&lt;/p&gt;

&lt;p&gt;跳转适配会根据你使用的设备类型跳转到对应的单独地址。比如：你在手机浏览器里输入 163.com ，会自动跳转到 3g.163.com 。实现的方法是在通过 Meta 信息申明，或是 Server 根据 User-Agent 进行跳转。跳转适配需要针对不同设备类型，使用不同的url，做多套界面。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码适配&lt;/p&gt;

&lt;p&gt;代码适配在不同设备中使用同一个 URL ， Server 会根据 User-Agent 的不同生成不同的 HTML 页面。比如在手机里输入： weixin.qq.com ，虽然地址一样，但看到的内容和PC端是完全不一样的。（你会发现找不到“公众平台”的入口）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然，这两种适配方式的维护成本都比较大。因为要针对不同平台维护不同版本，常常会出现移动版和 PC 版不同步的问题。&lt;/p&gt;

&lt;p&gt;接着，就要提到第三种适配方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自适应：同一 URL ，同一套 HTML 界面，根据使用设备（PC、移动设备、平板电脑）的不同，根据屏幕尺寸呈现出不同的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“响应式布局”就是自适应适配的一种布局方式。为了让自适应适配更加方便易用，Bootstrap框架应运而生。&lt;/p&gt;

&lt;h3 id=&#34;bootstrap:0b0432fd07b093099631d3dfda0706d0&#34;&gt;Bootstrap&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://getbootstrap.com/&#34;&gt;Bootstrap&lt;/a&gt; 是 Twitter 推出的一个用于前端开发的开源工具包。它由 Twitter 的设计师 Mark Otto 和 Jacob Thornton 合作开发，是一个 CSS/HTML 框架。通过 Bootstrap ，你可以非常轻松的设计出移动端友好，又能在不同设备适配良好的网站。&lt;/p&gt;

&lt;p&gt;Bootstrap 天生为移动设备而设计，框架由内到外默认都是移动设备优先的。使用 Bootstrap 非常简单，首先将页面设置成 HTML5 文档类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;zh-CN&amp;quot;&amp;gt;
  ...
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 之间添加 viewport 元数据标签：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以设置禁用缩放功能，让你的网站在浏览器里看上去更像一个原生应用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 Bootstrap 最简单快速的方式是直接使用 Bootstrap 中文网提供的 CDN 加速服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 新 Bootstrap 核心 CSS 文件 --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css&amp;quot;&amp;gt;

&amp;lt;!-- 可选的Bootstrap主题文件（一般不用引入） --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css&amp;quot;&amp;gt;

&amp;lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&amp;gt;
&amp;lt;script src=&amp;quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&amp;gt;
&amp;lt;script src=&amp;quot;//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以使用 &lt;code&gt;Bower&lt;/code&gt; 、 &lt;code&gt;npm&lt;/code&gt; 、 &lt;code&gt;Composer&lt;/code&gt; 等工具进行安装。为了更强的定制性，你还可以使用 &lt;code&gt;Less/Sass&lt;/code&gt; 源码进行编译。&lt;/p&gt;

&lt;p&gt;编译？其实就是CSS文件的生成过程。我们知道，CSS 在处理样式时异常灵活，以至于不同人写出来的样式代码五花八门，各种元素之间相互影响相互制约，某处稍一改动就有牵一发而动全身的效果。再加上不同浏览器支持的特性千差万别，使得CSS代码变得非常难以组织和维护。&lt;/p&gt;

&lt;p&gt;由此，CSS 预处理应运而生。通过定义一种新的语言，自动实现浏览器兼容、变量、结构体等功能，还支持逻辑判断和循环，最后通过编译生成最终的 CSS 目标文件。使得代码更加简洁，容易维护。而 Less/Sass 就是目前最流行的CSS预处理器。&lt;/p&gt;

&lt;p&gt;除了上面的方式，你还可以像我这种懒人一样直接下载现成的示例模板，然后再做一些细微的调整。&lt;/p&gt;

&lt;h3 id=&#34;bootstrap-布局:0b0432fd07b093099631d3dfda0706d0&#34;&gt;Bootstrap 布局&lt;/h3&gt;

&lt;p&gt;Bootstrap 提供了一套完整的基础 CSS 模块，预定义了一套简单易用的样式组件，同时结合jQuery 提供了一套基础的方便的 Javascript 交互组件。简直就是提供了 Web 前端的一站式解决方案。&lt;/p&gt;

&lt;p&gt;这里我只介绍一下自适应适配最核心之处： Bootstrap 的栅格布局系统。&lt;/p&gt;

&lt;p&gt;首先，我们要为页面内容和栅格系统包裹一个 &lt;code&gt;.container&lt;/code&gt; 容器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.container&lt;/code&gt; 类用于固定宽度和响应式布局的容器，如果占据 100% 的宽度，使用 &lt;code&gt;.container-fluid&lt;/code&gt; 类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;container-fluid&amp;quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栅格系统会根据屏幕和视口（viewport）的尺寸，将一行分为最多 &lt;strong&gt;12&lt;/strong&gt; 列，通过预设好的栅格类表示需要占多少个列宽度。比如，可以使用 3 个 &lt;code&gt;.col-xs-4&lt;/code&gt; 可以将页面容器分成 3 个等分。使用 1 个 &lt;code&gt;.col-xs-3&lt;/code&gt; 和 1 个 &lt;code&gt;.col-xs-9&lt;/code&gt; ，可以对页面容器进行 3：9 比例分割，实现一个左侧 Sidebar 的效果。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/bootstrap-grid.jpg&#34; alt=&#34;bootstrap-grid&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-8&amp;quot;&amp;gt;.col-md-8&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-4&amp;quot;&amp;gt;.col-md-4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;.col-md-6&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-md-6&amp;quot;&amp;gt;.col-md-6&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了指定宽度，还可以通过指定 &lt;code&gt;.col-md-offset-*&lt;/code&gt; 等进行偏移。回到一个重要的问题，知道了大致如何布局，那如何进行移动适配呢？&lt;/p&gt;

&lt;p&gt;上面的例子我们看到，有 &lt;code&gt;.col-xs-*&lt;/code&gt; 和 &lt;code&gt;.col-md-*&lt;/code&gt; 等等，其实 xs 、 md 等对应的是不同显示设备。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.col-xs-*&lt;/code&gt; ：超小屏幕、手机 (&amp;lt;768px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-sm-*&lt;/code&gt; ：小屏幕 平板 (≥768px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-md-*&lt;/code&gt; ：中等屏幕 桌面显示器 (≥992px)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.col-lg-*&lt;/code&gt; ：大屏幕 大桌面显示器 (≥1200px)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过给 div 定义多个 &lt;code&gt;col-xx-*&lt;/code&gt; 的组合就可以达到不同移动设备进行布局适配的目的。&lt;/p&gt;

&lt;p&gt;比如下面的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;row&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;col-xs-6 col-md-3&amp;quot;&amp;gt;.col-xs-6 .col-md-3&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;col-xs-6 col-md-9&amp;quot;&amp;gt;.col-xs-6 .col-md-9&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将实现在手机端进行 6：6 布局，在中等屏幕的PC端进行 3 : 9 布局。&lt;/p&gt;

&lt;h3 id=&#34;总结:0b0432fd07b093099631d3dfda0706d0&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;如今 Bootstrap 已经被广泛使用，国内外大量网站使用 Bootstrap 数不胜数。如果你需要开发一个移动端友好的网站， Bootstrap 是你的不二选择。本文只是 Bootstrap 的粗浅入门，有兴趣的同学可以找资料进行更加深入的学习。&lt;/p&gt;

&lt;p&gt;Bootstrap 官方网站：&lt;a href=&#34;http://getbootstrap.com/&#34;&gt;http://getbootstrap.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于前端开发的 Bootstrap 这把利器多少有了一些了解，接下来可以去了解了解那些号称1，2周就有大更新，1，2个月就有新冒出来的，3，4个月不学就要落伍的前端框架了。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Hugo中文网站gohugo.org上线</title>
            <link>http://blog.coderzh.com/2015/10/25/gohugo-org/</link>
            <pubDate>Sun, 25 Oct 2015 23:37:16 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/25/gohugo-org/</guid>
            <description>

&lt;p&gt;之前我在博客里写了一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;，之后有很多人给我留言或者邮件，列举了在搭建Hugo时遇到的各种问题，并且提出希望能有一个中文的Hugo网站。&lt;/p&gt;

&lt;p&gt;于是，我利用周末的时间，注册域名（居然注册到了 &lt;code&gt;gohugo.org&lt;/code&gt; 这个域名），用&lt;code&gt;Hugo&lt;/code&gt;本身搭建了这个网站，运行在 &lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;DigitalOcean&lt;/a&gt; 的 &lt;code&gt;VPS&lt;/code&gt; 上。这就是 &lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;gohugo-org:39bef422aa544bc9d53b933146f67273&#34;&gt;gohugo.org&lt;/h3&gt;

&lt;p&gt;网站的地址是：&lt;a href=&#34;http://www.gohugo.org&#34;&gt;http://www.gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网站所有内容都在 &lt;code&gt;GitHub&lt;/code&gt; 开源，地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/gohugo.org&#34;&gt;https://github.com/coderzh/gohugo.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该Repository已经设置了WebHook，只要有push就会自动触发 &lt;code&gt;VPS&lt;/code&gt; 更新部署。如果你感兴趣，可以加入进来，你提的PR一旦被Merged将立即在网站更新出来。&lt;/p&gt;

&lt;h3 id=&#34;截图:39bef422aa544bc9d53b933146f67273&#34;&gt;截图&lt;/h3&gt;

&lt;h4 id=&#34;首页:39bef422aa544bc9d53b933146f67273&#34;&gt;首页&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-index.jpg-w&#34; alt=&#34;gohugo-index&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;文章列表:39bef422aa544bc9d53b933146f67273&#34;&gt;文章列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-post.jpg-w&#34; alt=&#34;gohugo-post&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;皮肤列表:39bef422aa544bc9d53b933146f67273&#34;&gt;皮肤列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-theme.jpg-w&#34; alt=&#34;gohugo-theme&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;示例网站:39bef422aa544bc9d53b933146f67273&#34;&gt;示例网站&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/gohugo-showcase.jpg-w&#34; alt=&#34;gohugo-showcase&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;关于hugo:39bef422aa544bc9d53b933146f67273&#34;&gt;关于Hugo&lt;/h3&gt;

&lt;p&gt;使用Hugo可以快速的制作一个静态站点，同时Hugo还在不断更新和发展中，相信未来会更加易用、功能越来越好。我给Hugo提过几次PR，看过Hugo的代码，从代码的角度来看，Hugo的代码写非常简洁清晰，模块分类非常的清楚，并且配备完善的单元测试。&lt;/p&gt;

&lt;p&gt;对于如此优秀的东西，希望能与更多人分享，通过分享和交流，希望能促进Hugo变得越来越好，让它更加广为人知。&lt;/p&gt;

&lt;p&gt;因此，所有对Hugo感兴趣的朋友欢迎加入贡献内容，同时也欢迎有任何疑问、建议或交流的朋友加入Hugo交流QQ群：512499080。&lt;/p&gt;

&lt;p&gt;或者微信扫一扫关注我的微信公众号：hacker-thinking&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.coderzh.com/public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用Hugo Import一键迁移Jekyll</title>
            <link>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</link>
            <pubDate>Sun, 11 Oct 2015 10:06:11 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/10/11/hugo-import-from-jekyll/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoImportJekyll.png-wt&#34; alt=&#34;HugoImportJekyll&#34; /&gt;&lt;/p&gt;

&lt;p&gt;国庆长假期间，给Hugo提了几个PR，其中最主要的一个是给Hugo增加了内置的Jekyll迁移工具。这样之前的Jekyll用户可以通过一个简单的命令就可以将网站转化成Hugo站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll your-jekyll-dir target-dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得益于Hugo代码可读性非常好，原来计划需要几天来完成的功能1天左右的时间就完成了。完整的PR过程请见：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1469&#34;&gt;https://github.com/spf13/hugo/pull/1469&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo-import:9d9792e5f5806aca19497d8888e47a21&#34;&gt;Hugo Import&lt;/h3&gt;

&lt;p&gt;主要实现了将原来的Jeklly网站一键转换为Hugo网站，具体实现了如下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成新的Hugo站点结构。(hugo new site)&lt;/li&gt;
&lt;li&gt;读取Jeklly的_config.yml，相应内容转化到Hugo的config.yaml。&lt;/li&gt;
&lt;li&gt;转换所有MarkDown的文章。（具体转换规则见下文）&lt;/li&gt;
&lt;li&gt;拷贝Jekyll其他目录及文件到Hugo的static目录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;@bep在他的OS X上做了一些测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll qrush.github.com qr2
  Importing...
  Congratulations! 72 posts imported!
  Now, start Hugo by yourself:
  $ git clone https://github.com/spf13/herring-cove.git qr2/themes/herring-cove
  $ cd qr2
  $ hugo server -w --theme=herring-cove
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;markdown文章转换规则:9d9792e5f5806aca19497d8888e47a21&#34;&gt;MarkDown文章转换规则&lt;/h3&gt;

&lt;p&gt;Hugo和Jekyll都是使用MarkDown来写文章的，文章内容基本上是兼容的，除了一些FrontMatter的细节和局部细节。Hugo Import Jekyll主要的转换规则如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保持原Jekyll文章目录结构及文件名不变，将文章拷贝到了content/post目录下。&lt;/li&gt;
&lt;li&gt;尽量保持原Jekyll文章链接地址不变，在文章的FrontMatter自动填入url字段。&lt;/li&gt;
&lt;li&gt;date字段转换成Hugo要求的time.RFC3339格式。&lt;/li&gt;
&lt;li&gt;draft字段自动生成。&lt;/li&gt;
&lt;li&gt;删除layout字段。&lt;/li&gt;
&lt;li&gt;category字段转换成categories字段。&lt;/li&gt;
&lt;li&gt;excerpt_separator智能替换。(比如： &amp;lt;!--more--&amp;gt;)&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;{% raw %}{% endraw %}&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;替换&lt;code&gt;{% highlight %}{% endhighlight %}&lt;/code&gt;标签为 {{&amp;lt; highlight &amp;gt;}}{{&amp;lt; / highlight &amp;gt;}}&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;代码:9d9792e5f5806aca19497d8888e47a21&#34;&gt;代码&lt;/h3&gt;

&lt;p&gt;import.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;import_test.go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/blob/master/commands/import_test.go&#34;&gt;https://github.com/spf13/hugo/blob/master/commands/import_test.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我fork的Hugo Repo（我的最新改动都在这里）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/coderzh/hugo&#34;&gt;https://github.com/coderzh/hugo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;最后:9d9792e5f5806aca19497d8888e47a21&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;这个功能将会在下个正式版推出，现在需要使用的同学自行pull最新的Hugo代码编译吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get -u -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;欢迎试用，并且提出意见或建议！谢谢！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Go语言极速入门手册.go</title>
            <link>http://blog.coderzh.com/2015/09/28/go-tips/</link>
            <pubDate>Mon, 28 Sep 2015 22:43:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/28/go-tips/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/golang.jpg&#34; alt=&#34;golang&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/CodeTips&#34;&gt;https://github.com/coderzh/CodeTips&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
gotips_test.go:
  Golang速学速查速用代码手册

Source: github.com/coderzh/CodeTips/blob/master/gotips_test.go

Author: coderzh(github.com/coderzh)
Blog: http://blog.coderzh.com
参考：《Go语言编程》
*/

package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;github.com/stretchr/testify/assert&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;math&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;path/filepath&amp;quot;
    &amp;quot;regexp&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;testing&amp;quot;
    &amp;quot;time&amp;quot;
)

// 0. 注释
/*
规范：
 1. 命名：骆驼命名法（不要用下划线）

命令:
 go get github.com/coderzh/xxx
 go build calc
 go run xxx.go
 go install calc
*/

// 1. Hello World
func helloWorld() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}

// 2.变量类型
func typeDemo() {
    // 变量声明
    var v1 int
    var (
        v2 int
        v3 string
    )
    //var p *int // 指针类型

    // 变量初始化
    var v4 int = 10
    // 等价于:
    var v5 = 10
    // 一般这样就好
    v6 := 10

    // 赋值，多重赋值
    v1 = 10
    v2, v3 = 20, &amp;quot;test&amp;quot;
    // 匿名变量 _
    _, v4 = v5, v6

    fmt.Println(v1, v2, v3, v4)

    // 常量
    const Pi float64 = 3.1415926
    const MaxPlayer = 10

    // 枚举
    const (
        Sunday = iota // iota从0递增
        Mondy
        Tuesday
        // ...
    )

    // 类型
    // 1. 布尔
    var b1 bool
    b1 = true
    b1 = (1 == 2)

    fmt.Println(b1)

    // 2. 整形
    // int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint uintptr
    var i32 int32
    // 强制转换
    i32 = int32(64)
    // 运算：+, -, *, /, %（求余）
    // 比较：&amp;gt;, &amp;lt;, ==, &amp;gt;=, &amp;lt;=, !=
    // 位运算：x &amp;lt;&amp;lt; y, x &amp;gt;&amp;gt; y, x ^ y, x &amp;amp; y, x | y, ^x （取反）

    fmt.Println(i32)

    // 3. 浮点
    // float32, float64
    var f1 float64 = 1.0001
    var f2 float64 = 1.0002
    // 浮点比较
    isEqual := math.Dim(f1, f2) &amp;lt; 0.0001

    fmt.Println(isEqual)

    // 4. 字符串
    var s1 string
    s1 = &amp;quot;abc&amp;quot;
    // 字符串连接
    s1 = s1 + &amp;quot;ddd&amp;quot;
    // 取长度
    n := len(s1)
    // 取字符
    c1 := s1[0]
    // 反引号，不转义，常用于正则表达式
    s1 = `\w+`

    fmt.Println(c1)

    fmt.Println(strings.HasPrefix(&amp;quot;prefix&amp;quot;, &amp;quot;pre&amp;quot;)) // true
    fmt.Println(strings.HasSuffix(&amp;quot;suffix&amp;quot;, &amp;quot;fix&amp;quot;)) // true

    // 字节遍历
    for i := 0; i &amp;lt; n; i++ {
        ch := s1[i]
        fmt.Println(ch)
    }
    // Unicode字符遍历
    for i, ch := range s1 {
        fmt.Println(i, ch)
    }

    // 5. 数组
    var arr1 [32]int
    //var arr2 [3][8]int // 二维数组
    // 初始化
    arr1 = [32]int{0}
    array := [5]int{1, 2, 3, 4, 5}
    // 临时结构体数组
    structArray := []struct {
        name string
        age  int
    }{{&amp;quot;Tim&amp;quot;, 18}, {&amp;quot;Jim&amp;quot;, 20}}

    // 数组遍历
    for i := 0; i &amp;lt; len(array); i++ {
        fmt.Println(array[i])
    }
    for i, v := range structArray {
        fmt.Println(i, v)
    }
    // 数组是值类型，每次参数传递都是一份拷贝

    // 数组切片Slice
    var mySlice []int = arr1[:2]
    mySlice1 := make([]int, 5)
    mySlice2 := make([]int, 5, 10)

    fmt.Println(&amp;quot;len(mySlice2:&amp;quot;, len(mySlice2)) // 5
    fmt.Println(&amp;quot;cap(mySlice2:&amp;quot;, cap(mySlice2)) // 10

    mySlice3 := append(mySlice, 2, 3, 4)
    mySlice4 := append(mySlice, mySlice1...)

    copy(mySlice3, mySlice4)

    // 6. Map
    var m map[int]string
    m[1] = &amp;quot;ddd&amp;quot;
    m1 := make(map[int]string)
    m2 := map[int]string{
        1: &amp;quot;a&amp;quot;,
        2: &amp;quot;b&amp;quot;,
    }

    delete(m2, 1)

    value, ok := m1[1]
    if ok {
        fmt.Println(value)
    }

    for k, v := range m2 {
        fmt.Println(k, v)
    }

}

// 3. 流程控制
func flowDemo() {
    // if else
    a := 10
    if a &amp;lt; 10 {
        // ..
    } else {
        // ..
    }

    // switch
    switch a {
    case 0:
        fmt.Println(&amp;quot;0&amp;quot;)
    case 10:
        fmt.Println(&amp;quot;10&amp;quot;)
    default:
        fmt.Println(&amp;quot;default&amp;quot;)
    }

    switch {
    case a &amp;lt; 10:
        fmt.Println(&amp;quot;&amp;lt;10&amp;quot;)
    case a &amp;lt; 20:
        fmt.Println(&amp;quot;&amp;lt;20&amp;quot;)
    }

    // 循环
    for i := 0; i &amp;lt; 10; i++ {
    }
    // 无限循环
    sum := 0
    for {
        sum++
        if sum &amp;gt; 10 {
            break
            // 指定break
            // break JLoop
        }
    }

    goto JLoop

JLoop:
    // break to here

}

// 4. 函数
// func 函数名(参数列表)(返回值列表) {
// }
func sum1(value1 int, value2 int) (result int, err error) {
    // err = errors.New(&amp;quot;xxxx&amp;quot;)
    return value1 + value2, nil
}

func sum2(value1, value2 int) int {
    return value1 + value2
}

// 不定参数
// myFunc(1, 2, 3, 4, 5)
func myFunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
    // 传递
    // myFunc2(args...)
    // myFunc2(args[1:]...)
}

// 任意类型的不定参数
func myPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
        case int:
            fmt.Println(arg, &amp;quot;is int&amp;quot;)
        case string:
            fmt.Println(arg, &amp;quot;is string&amp;quot;)
        default:
            fmt.Println(arg, &amp;quot;is unknown&amp;quot;)
        }
    }
}

// 匿名函数
func anonymousFunc() {
    f := func(a, b int) int {
        return a + b
    }

    f(1, 2)
}

// defer
func deferDemo(path string) {
    f, err := os.Open(path)
    if err != nil {
        return
    }

    defer f.Close()
    // or
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf(&amp;quot;Runtime error caught: %v&amp;quot;, r)
        }
    }()
}

// 5. 结构体
type Rect struct {
    // 小写为private
    x, y float64
    // 大写为public
    Width, Height float64
}

// 大写方法为public，小写为private
func (r *Rect) Area() float64 {
    return r.Width * r.Height
}

func netRect(x, y, width, height float64) *Rect {
    // 实例化结构体
    // rect1 := new(Rect)
    // rect2 := &amp;amp;Rect{}
    // rect3 := &amp;amp;Rect{Width:100, Height:200}
    return &amp;amp;Rect{x, y, width, height}
}

// 匿名组合
type Base struct {
    Name string
}

func (base *Base) Foo() {}
func (base *Base) Bar() {}

type Foo struct {
    Base
    *log.Logger
}

func (foo *Foo) Bar() {
    foo.Base.Bar()
    // ...
}

// 非侵入式接口
type IFile interface {
    Read(buf []byte) (n int, err error)
    Write(buf []byte) (n int, err error)
}

type File struct {
}

func (file *File) Read(buf []byte) (n int, err error) {
    return 0, nil
}

func (file *File) Write(buf []byte) (n int, err error) {
    return 0, nil
}

func interfaceDemo() {
    // 只要实现了Read, Write方法即可
    var file IFile = new(File)

    // 接口查询
    // 是否实现了IFile接口
    if file2, ok := file.(IFile); ok {
        file2.Read([]byte{})
    }
    // 实例类型是否是File
    if file3, ok := file.(*File); ok {
        file3.Read([]byte{})
    }

    // 类型查询
    switch v := file.(type) {
    }
}

// 6. 并发编程
func counting(ch chan int) {
    ch &amp;lt;- 1
    fmt.Println(&amp;quot;counting&amp;quot;)
}

func channelDemo() {
    chs := make([]chan int, 10)
    for i := 0; i &amp;lt; len(chs); i++ {
        chs[i] = make(chan int)
        // 带缓冲区大小
        // c: = make(chan int, 1024)
        // for i:= range c {
        // }
        go counting(chs[i])
    }

    for _, ch := range chs {
        &amp;lt;-ch
        // channel select
        /*
            select {
            case &amp;lt;-ch:
                // ...
            case ch &amp;lt;- 1:
            }
        */
    }

    // 单向Channel
    var ch1 chan&amp;lt;- int // 只能写入int
    var ch2 &amp;lt;-chan int // 只能读出int

    // 关闭Channel
    close(ch1)
    _, ok := &amp;lt;-ch2
    if !ok {
        // already closed
    }
}

// 锁
var m sync.Mutex

func lockDemo() {
    m.Lock()
    // do something
    defer m.Unlock()
}

// 全局唯一操作
var once sync.Once

// once.Do(someFunction)

// 7. 网络编程
// import &amp;quot;net&amp;quot;
// net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8080&amp;quot;)

// 8. json处理
// import &amp;quot;encoding/json&amp;quot;
// json.Marshal(obj) 序列化
// json.Unmarshal() 反序列化

// 9. Web开发
// import &amp;quot;net/http&amp;quot;
// 模板
// import &amp;quot;html/template&amp;quot;

// 10. 常用库
// import &amp;quot;os&amp;quot;
// import &amp;quot;io&amp;quot;
// import &amp;quot;flag&amp;quot;
// import &amp;quot;strconv&amp;quot;
// import &amp;quot;crypto/sha1&amp;quot;
// import &amp;quot;crypto/md5&amp;quot;

// 11. 单元测试
// _test结尾的go文件： xxx_test.go
// 函数名以Test开头
func TestDemo(t *testing.T) {
    r := sum2(2, 3)
    if r != 5 {
        t.Errorf(&amp;quot;sum2(2, 3) failed. Got %d, expect 5.&amp;quot;, r)
    }

    assert.Equal(t, 1, 1)
}

// 12. 性能测试
func benchmarkAdd(b *testing.B) {
    b.StopTimer()
    // dosometing
    b.StartTimer()
}

/*
 其他常用的代码片段
*/

// 1. 遍历文件 filepath.Walk
// import &amp;quot;path/filepath&amp;quot;
func doHashWalk(dirPath string) error {

    fullPath, err := filepath.Abs(dirPath)

    if err != nil {
        return err
    }

    callback := func(path string, fi os.FileInfo, err error) error {
        return hashFile(fullPath, path, fi, err)
    }

    return filepath.Walk(fullPath, callback)
}

func hashFile(root string, path string, fi os.FileInfo, err error) error {
    if fi.IsDir() {
        return nil
    }
    rel, err := filepath.Rel(root, path)
    if err != nil {
        return err
    }
    log.Println(&amp;quot;hash rel:&amp;quot;, rel, &amp;quot;abs:&amp;quot;, path)
    return nil
}

// 2. 读取文件
// import &amp;quot;io/ioutil&amp;quot;
func readFileDemo(filename string) {
    content, err := ioutil.ReadFile(filename)
    if err != nil {
        //Do something
    }
    lines := strings.Split(string(content), &amp;quot;\n&amp;quot;)
    fmt.Println(&amp;quot;line count:&amp;quot;, len(lines))
}

// 判断目录或文件是否存在
func existsPathCheck(path string) (bool, error) {
    // 判断不存在
    if _, err := os.Stat(path); os.IsNotExist(err) {
        // 不存在
    }

    // 判断是否存在
    _, err := os.Stat(path)
    if err == nil {
        return true, nil
    }
    if os.IsNotExist(err) {
        return false, nil
    }
    return true, err
}

// 文件目录操作
func fileDirDemo() {
    // 级联创建目录
    os.MkdirAll(&amp;quot;/path/to/create&amp;quot;, 0777)
}

// 拷贝文件
func copyFile(source string, dest string) (err error) {
    sf, err := os.Open(source)
    if err != nil {
        return err
    }
    defer sf.Close()
    df, err := os.Create(dest)
    if err != nil {
        return err
    }
    defer df.Close()
    _, err = io.Copy(df, sf)
    if err == nil {
        si, err := os.Stat(source)
        if err != nil {
            err = os.Chmod(dest, si.Mode())
        }

    }
    return
}

// 拷贝目录
func copyDir(source string, dest string) (err error) {
    fi, err := os.Stat(source)
    if err != nil {
        return err
    }
    if !fi.IsDir() {
        return errors.New(source + &amp;quot; is not a directory&amp;quot;)
    }
    err = os.MkdirAll(dest, fi.Mode())
    if err != nil {
        return err
    }
    entries, err := ioutil.ReadDir(source)
    for _, entry := range entries {
        sfp := filepath.Join(source, entry.Name())
        dfp := filepath.Join(dest, entry.Name())
        if entry.IsDir() {
            err = copyDir(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        } else {
            err = copyFile(sfp, dfp)
            if err != nil {
                fmt.Println(err)
            }
        }

    }
    return nil
}

// 3. 时间处理
// import &amp;quot;time&amp;quot;
func TestTimeDemo(t *testing.T) {
    // Parse
    postDate, err := time.Parse(&amp;quot;2006-01-02 15:04:05&amp;quot;, &amp;quot;2015-09-30 19:19:00&amp;quot;)
    fmt.Println(postDate, err)

    // Format
    assert.Equal(t, &amp;quot;2015/Sep/30 07:19:00&amp;quot;, postDate.Format(&amp;quot;2006/Jan/02 03:04:05&amp;quot;))
    assert.Equal(t, &amp;quot;2015-09-30T19:19:00Z&amp;quot;, postDate.Format(time.RFC3339))
}

// 4. 正则表达式
// import &amp;quot;regexp&amp;quot;
func TestRegexp(t *testing.T) {
    // 查找匹配
    re := regexp.MustCompile(`(\d+)-(\d+)`)
    r := re.FindAllStringSubmatch(&amp;quot;123-666&amp;quot;, -1)

    assert.Equal(t, 1, len(r))
    assert.Equal(t, &amp;quot;123&amp;quot;, r[0][1])
    assert.Equal(t, &amp;quot;666&amp;quot;, r[0][2])

}

func main() {
    helloWorld()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>博客图片切换到七牛</title>
            <link>http://blog.coderzh.com/2015/09/20/qiuniu/</link>
            <pubDate>Sun, 20 Sep 2015 20:37:42 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/20/qiuniu/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/qiniu.jpg&#34; alt=&#34;qiniu&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;做为一个独立博客，稳定、速度快是非常重要的指标。在博客的运营过程中，经常会不可避免的需要做迁移。比如，从WordPress到Jekyll，从Jekyll到Hugo。迁移之后，文章里的链接还能不能用，图片还能不能访问，是一个比较重要的问题。文章链接地址可以使用域名或者相对地址的方式方便迁移，而图片则稍微复杂一点点。&lt;/p&gt;

&lt;p&gt;假如图片和网页文件都是在服务器上自己管理，迁移时只需要把图片拷贝过去，然后保持访问的路径不变就可以了。自己管理图片有些不好的地方，首先图片可能占用你大量的服务器存储空间，其次访问时也将消耗服务器大量的流量。另外一种方式，是把图片放在一个第三方的地方，然后通过链接直接使用。而“第三方”就显得尤为重要的，假如这个“第三方”哪天突然倒了或者策略变化，导致之前的所有图片都失效了，将是不可接受的。&lt;/p&gt;

&lt;p&gt;正因为存在这样的需求，所以出现一些专业的提供图片托管的服务，俗称图床服务。这些图床服务通常提供这样一些服务：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图床服务是稳定的，不会轻易中断。你就放心吧。&lt;/li&gt;
&lt;li&gt;通过CDN加速，让你的图片访问速度杠杠的。&lt;/li&gt;
&lt;li&gt;支持自定义域名，迁移过来或者迁移走都可以非常方便。&lt;/li&gt;
&lt;li&gt;提供水印等图片处理服务。（算是一个附加功能）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用图床服务还有一个好处，就是一旦当前使用的图床没法用了，只需要把图片都迁到另外一个图床继续使用，代价非常小。就算没有绑定自定义域名，迁移的时候做个简单的地址替换就可以了。&lt;/p&gt;

&lt;p&gt;在对比了国内的图床服务之后，我还是决定选择老东家金山出来的许式伟做的七牛云存储。七牛在上面四点都做的非常好，而且还提供10G免费空间。目前对我来说已经足够了。&lt;/p&gt;

&lt;p&gt;七牛云存储：&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;www.qiniu.com&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages</title>
            <link>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</link>
            <pubDate>Sun, 13 Sep 2015 08:48:52 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</guid>
            <description>

&lt;p&gt;本文的主要内容如标题所示，通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages。如果你正好有这个需求，看这篇文章正好，可以节省你不少时间。如果不是，了解一下也无妨。&lt;/p&gt;

&lt;p&gt;首先，必须解释一下，为什么需要自动部署，以及为什么需要需要同时部署到GitHub Pages和GitCafe Pages。&lt;/p&gt;

&lt;h3 id=&#34;为什么要自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么要自动部署&lt;/h3&gt;

&lt;p&gt;使用Hugo生成的静态页面是在public文件夹里，部署的时候需要把public文件夹里的内容push到GitHub的gh-pages分支里。每次写完文章，除了push markdown格式的文章，还需要单独push生成的public文件夹里的东西，步骤稍显麻烦。&lt;/p&gt;

&lt;p&gt;之前参照了官方的做法，使用subtree来push public，步骤简化不少。然而，这还是不够简单。因为每次修改文章之后，必须依赖一个脚本才能正确提交和部署。假如你在手机里浏览时，发现一个错别字，顺手就在GitHub的Web界面就把错别字改了，然而这样并不会重新生成静态页面和部署。有些不方便。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面和部署的过程应该让机器自动来完成。&lt;strong&gt;写作应该是一个相对单纯的事情，使用Hugo的人应该更专注于写作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要同时部署到github-pages和gitcafe-pages:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么需要同时部署到GitHub Pages和GitCafe Pages&lt;/h3&gt;

&lt;p&gt;大公司很喜欢的一个词：容灾。GitHub出现不可访问的事情在国内也是常有的，而GitCafe作为国内的代码托管厂商，是否是一个稳定的存在也不好说。所以，将网站同时部署到这两个上面。通过DnsPod里CNAME设置线路“国内”和“国外”，不仅起到了任何一个挂掉，另一个可以继续工作的目的，还起到了CDN就近访问的作用。&lt;/p&gt;

&lt;p&gt;使用GitCafe还有另外一个原因。GitHub Pages拒绝了一切百度的爬虫，所以，百度无法索引到GitHub Pages的网页。对于国内的搜索市场来说，百度的份额还是比较大的，虽然我认为看我的博客的人都不应该使用百度，但现实总是残酷的。如果希望网站被百度收录，就必须放到GitHub以外的地方。GitCafe就是一种比较好的选择。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gitcafe.com&#34;&gt;http://gitcafe.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果，你只是希望使用官方的Hugo自动化部署到GitHub Pages，下面的内容你可以不用看了。你可以直接使用Wercker的服务来自动部署。&lt;/p&gt;

&lt;p&gt;文档见：&lt;a href=&#34;http://gohugo.io/tutorials/automated-deployments/&#34;&gt;
http://gohugo.io/tutorials/automated-deployments/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于Wercker还不支持GitCafe的部署，以及我需要使用特定的修改版本的Hugo来生成静态网页，并且希望这些步骤比较可控，所以，还是自己来折腾整个过程吧。&lt;/p&gt;

&lt;h3 id=&#34;webhook:f7c51a9b685c2720baf98649c3938c48&#34;&gt;webhook&lt;/h3&gt;

&lt;p&gt;webhook是GitHub上提供的Git的一种Hook机制，当代码发生变化时，比如代码被Push到GitHub的Repo时，GitHub会自动请求一个你指定的网页，并且把变更相关的参数都传递过来。入口在Repo的Settings - webhooks &amp;amp; services&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/WebHook.png-w&#34; alt=&#34;webhook&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明文档：&lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;https://developer.github.com/webhooks/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;借助webhook的机制，我们就可实现当有新的文章Push之后，自动通知远程的一台机器执行一个脚本，脚本的内容就是生成静态页面和Push部署到最终的服务器。&lt;/p&gt;

&lt;p&gt;webhook的Server接收webhook通知，然后执行一个脚本。这样的需求太普遍了，以至于完全不需要自己来实现。在GitHub里搜webhook可以搜出来很多。我主要挑选了Go语言的版本。主要有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qiniu/webhook&#34;&gt;https://github.com/qiniu/webhook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adnanh/webhook&#34;&gt;https://github.com/adnanh/webhook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个是七牛写的，代码很简单，用法也很简单。开始打算用七牛的版本。最后调试的时候发现json解析失败，完全不可用啊！有点坑爹。于是换成了第二个，这个Repo有200多个Star。还是靠谱很多，最后部署，调试，非常顺利。&lt;/p&gt;

&lt;p&gt;用法也很简单，首先安装webhook：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/adnanh/webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写一个配置文件hooks.json，里面指定需要执行的脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;redeploy-webhook&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/scripts/redeploy.sh&amp;quot;,
    &amp;quot;command-working-directory&amp;quot;: &amp;quot;/var/webhook&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定端口启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /path/to/webhook -hooks hooks.json -port=9876 -verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后它将接受webhook地址：（把它填到GitHub里的webhook里）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://yourserver:9876/hooks/redeploy-webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;自动部署&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/AutoDeploy.png-w&#34; alt=&#34;AutoDeploy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大致的流程如上图。上图的DigitalOcean是一台VPS服务器，我用了很长时间了，速度和稳定性都不错。需要的同学使用这个链接购买，可以获得10美元的优惠：&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;https://www.digitalocean.com/?refcode=e131e2bba197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整个流程中，复杂度主要是在DigitalOcean的VPS上部署服务和脚本。&lt;/p&gt;

&lt;p&gt;部署的脚本可以在我的GitHub上看到：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要的同学可以参考下，代码见：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&#34;&gt;deploy.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;deploy.py放到你的主工程，也就是你写markdown的Repo下。比如：/var/coderzh-hugo-blog/下&lt;/p&gt;

&lt;p&gt;adnanh-webhook的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;hugo-deploy&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/webhook/hugo-deploy.sh&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hugo-deploy.sh里执行deploy.py：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
 
python /var/coderzh-hugo-blog/deploy.py --auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下的是怎么在DigitalOcean的VPS上把这套东西部署起来。我使用nginx + supervisor搭建webhook的Server。&lt;/p&gt;

&lt;p&gt;关于nginx和supervisor可以参考之前的一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2014/05/19/digitalocean/&#34;&gt;http://blog.coderzh.com/2014/05/19/digitalocean/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;supervisor的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[program:webhook]
command=/root/gocode/bin/webhook -hooks /var/webhook/hooks.json -verbose -port=9876
user=root
directory=/var/webhook
autorestart=true
redirect_stderr=true
environment=HOME=&amp;quot;/root&amp;quot;,USER=&amp;quot;root&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于VPS上SSH Key的设置，见：&lt;a href=&#34;https://help.github.com/articles/generating-ssh-keys/&#34;&gt;https://help.github.com/articles/generating-ssh-keys/&lt;/a&gt;  为了自动部署方便，可以不设置密码。&lt;/p&gt;

&lt;p&gt;当然，还有个大前提，在VPS上安装最新版本的golang。推荐使用gvm来安装。（记得安装1.5之前必须先把1.4先装上）&lt;/p&gt;

&lt;p&gt;golang 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
source ~/.bashrc
gvm version
gvm install go1.4
gvm install go1.5.1
gvm use go1.5.1 --default
go version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，Good Luck！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>给Hugo提交了一个PR</title>
            <link>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</link>
            <pubDate>Thu, 03 Sep 2015 08:55:31 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</guid>
            <description>&lt;p&gt;给Hugo提交了一个Pull Request，并且通过了，记录一下。PR的内容是在config里增加了disablePathToLower选项，可以配置是否需要阻止Hugo自动将路径转换为小写。在站点从旧的系统里迁移到Hugo中时会非常有用。&lt;/p&gt;

&lt;p&gt;在上一篇博客&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;  里提到，Hugo强制将所有路径都变成了小写。小写路径虽好，但是如果之前你的网站路径不是全小写的，迁移过来路径发生变化，将会导致路径失效，是不可接受的。&lt;/p&gt;

&lt;p&gt;上文提到，我硬改了Hugo代码，让它不要强制转换小写路径。这样的做法不够优雅，假如别人也和我有一样的需求怎么办？我们还是希望Hugo本身就能够提供这样的功能。于是，我决定把代码改的优雅一些，给Hugo作者提交一个Pull Request，将这个功能合并到Hugo代码里。&lt;/p&gt;

&lt;p&gt;于是，我在config文件里增加了一个选项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Do not make the url/path to lowercase
disablePathToLower: true 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加一个开关其实很简单，只需要在command/hugo.go里的LoadDefaultSettings函数里增加一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;viper.SetDefault(&amp;quot;DisablePathToLower&amp;quot;, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开关生效的实现也很简单，找到最终转换为小写的函数，加入disablePathToLower开关的判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MakePathSanitized(s string) string {
    if viper.GetBool(&amp;quot;DisablePathToLower&amp;quot;) {
        return MakePath(s)
    } else {
        return strings.ToLower(MakePath(s))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前的函数名叫MakePathToLower，由于我在内部加了个开关，于是名字不适用了，于是修改为了：MakePathSanitized。&lt;/p&gt;

&lt;p&gt;修改完成之后，需要把测试案例跑一遍，保证你的修改不会破坏原来的逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go test ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也要保证编译是成功的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我修改的第一个版本时，我犯了一个错误，导致测试案例没有通过。原因是第一个版本我增加的配置选项是PathToLower，默认值是true。而有些测试案例是没有去设置PathToLower的，默认读到的会是false，从而导致执行失败的执行结果。所以，config里增加的选项，默认值尽量是false吧，也会好理解一些。于是就有了：disablePathToLower&lt;/p&gt;

&lt;p&gt;提交Pull Request时，有几点需要注意的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将自己的修改合并成一个commit再提交Pull Request。（这样在主Resp里更加规范和整洁）&lt;/li&gt;
&lt;li&gt;commit message里的描述尽量简洁清晰，如果有对应的issue ID，最好加上：See #1234 or Fixes #1234 之类的。这样可以自动关联起来。&lt;/li&gt;
&lt;li&gt;不要在自己的master分支上修改提交PR，而是应该自己开一个单独分支，由该分支提交Pull Request到原Repo的master。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，我提交了这么一个Pull Request：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;add configuration variable: &amp;ldquo;disablePathToLower&amp;rdquo; See #557&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不久后，Hugo的主要维护者之一通过了我的PR，很友善的将我蹩脚的中国式英语的commit message调整了一下合并到了Hugo的master：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoPR.png-w&#34; alt=&#34;HugoPR&#34; /&gt;&lt;/p&gt;

&lt;p&gt;commit: &lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就是开源项目的好处，开源社区的魅力所在：&lt;strong&gt;你可以使用它，修改它，贡献自己的代码，参与其中，让它变好，让所有人受益&lt;/strong&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用hugo搭建个人博客站点</title>
            <link>http://blog.coderzh.com/2015/08/29/hugo/</link>
            <pubDate>Sat, 29 Aug 2015 16:52:15 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/29/hugo/</guid>
            <description>

&lt;p&gt;Hugo是一个用Go语言编写的静态网站生成器，它使用起来非常简单，相对于Jekyll复杂的安装设置来说，Hugo仅需要一个二进制文件hugo(hugo.exe)即可轻松用于本地调试和生成静态页面。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面的效率很高，我的260多篇博客文章生成几乎是瞬间完成的，而之前用Jekyll需要等待10秒左右。&lt;/p&gt;

&lt;p&gt;Hugo自带watch的调试模式，可以在我修改MarkDown文章之后切换到浏览器，页面会检测到更新并且自动刷新，呈现出最终效果，能极大的提高博客书写效率。再加上Hugo是使用Go语言编写，已经没有任何理由不使用Hugo来代替Jekyll作为我的个人博客站点生成器了。&lt;/p&gt;

&lt;h3 id=&#34;静态网站生成器:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;静态网站生成器&lt;/h3&gt;

&lt;p&gt;什么是静态网站生成器？如果追溯到最早的网站形式，那时候的网页都是静态的，即一个内容不变的html文件放在服务器上，人们通过互联网访问浏览的都是这个一成不变的页面。后来，人们发现，需要和网页进行交互，能根据用户的输入动态呈现出相应的内容，这就是动态网站。那，为什么现在又回归使用静态网站呢？特别是对于博客网站这种特殊的形式。我的理解是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问速度提升。静态页面不需要像动态页面那样经常去查询数据库，而是直接将最终页面内容返回。&lt;/li&gt;
&lt;li&gt;搜素引擎友好。便于搜索引擎索引，比如很多动态网站的页面地址是一样的，只是后面传入的参数不一样，容易让搜索引擎误认为是同一个页面。（虽然不会）&lt;/li&gt;
&lt;li&gt;可以完全抛弃数据库，减少复杂度，将最复杂的一步交给静态网站生成器，自己只专注写作、生成、发布三个步骤。&lt;/li&gt;
&lt;li&gt;博客文章可以以文本文件的方式（MarkDown）在本地维护管理，不需要像之前那样在网页的编辑器里提交到网站数据库。你可以方便的使用github管理你的博客文章，不会丢失，又能追溯到每一次的内容变更。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前最流行的静态网站生成器是Jekyll，它是github创始人自己实现的一套ruby的静态网站生成器。一经推出，各个程序哥竞相效仿，一时间使用Jekyll搭建自己的博客变成了一件很高逼格的事情。&lt;/p&gt;

&lt;p&gt;我也是跟风者之一，在Jekyll之前，我主要也是在博客园写文章，同时独立博客这块也尝试过自己实现的博客程序，用GAE写过，后来又用Tornado写过，都是动态网站。自己实现博客程序，总是在开始一段时间内很狂热，当一切实现完成，细节修缮好之后很快就失去了兴趣。因为你的注意力从只是写文章，经常转移到其他地方去。比如网站不好看，需要去改一改网站的风格样式，修复BUG，加一加功能等等。&lt;/p&gt;

&lt;p&gt;所以，如果只是专注于写作，还是找一个稳定一些，提供大量现成皮肤，有稳定专业的组织维护更新的博客系统。使用Jekyll确实让我眼前一亮，原来博客程序可以这么玩。于是利用周末的时间，我将我之前所有的文章，包括博客园的文章，都迁移到了Jekyll上来。自从有了Jekyll，我终于可以开开心心的专注的写文章了，而且使用喜欢的MarkDown格式。：）&lt;/p&gt;

&lt;p&gt;在使用了Jekyll一段时间后，它的问题也逐渐暴露出来：静态页面生成的效率不够高。因为我把以前的文章都导入了过来，一共有260来篇，每次编辑文章后，需要等等10秒，待它将所有页面检查并生成完成之后，才能看到最终的效果。这是我最不能忍受的一点。对于初学者，Jekyll还有很多问题，比如环境搭建非常复杂，导致使用Jekyll的人大都是一些喜欢折腾，不怕折腾的程序哥。&lt;/p&gt;

&lt;p&gt;随着Go1.5版本的发布，让我意识到是时候好好玩一玩Go语言了。使用Go语言实现的静态网站生成器Hugo（雨果）立即吸引了我，它解决了我最大的痛点：生成的效率。文档、社区各方面的支持都不错，使用起来非常简单，各种皮肤直接套用，于是我又开始了Jekyll迁移到Hugo的漫漫长路。（一个周末的时间）&lt;/p&gt;

&lt;p&gt;&lt;del&gt;即使迁移到了Hugo，我还保留着原来的Jekyll博客，只是不会再更新了，用来怀念？还是哪天突然又跳回来也不一定。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我的Jeklly博客：&lt;a href=&#34;http://jekyll.coderzh.com&#34;&gt;http://jekyll.coderzh.com&lt;/a&gt;&lt;/del&gt; Update(2015-09-20): 觉得没啥用了，还是干掉了&lt;/p&gt;

&lt;p&gt;我的Hugo博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;github-pages:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;GitHub Pages&lt;/h3&gt;

&lt;p&gt;使用静态网站生成器生成好静态页面之后，需要把文件放到服务器上供别人浏览。比较传统的方式是租用VPS虚拟服务器，比如：linode、digitalocean。将生成好的静态页面手工上传到服务器上。如果你习惯这种方式部署，推荐你使用&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;digitalocean&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然， 还有更好的方式，就是直接把网站托管到GitHub Pages。你只需要在GitHub上创建一个项目，然后将生成出来的静态页面文件push到这个项目的gh-pages分支，保证根目录有一个index.html文件即可。这样，一个免费、无限流量的博客系统就搭建完成了。同时，通过github你可以方便对博客文章进行管理和追踪。&lt;/p&gt;

&lt;h3 id=&#34;hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hugo&lt;/h3&gt;

&lt;p&gt;前面的铺垫介绍的差不多了，该主角上场了。Hugo是什么？它主要做了什么？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hugo只有一个二进制文件（比如Windows里只是一个hugo.exe）&lt;/li&gt;
&lt;li&gt;Hugo可以将你写好的MarkDown格式的文章自动转换为静态的网页。&lt;/li&gt;
&lt;li&gt;Hugo内置web服务器，可以方便的用于本地调试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hello-hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hello Hugo&lt;/h3&gt;

&lt;p&gt;Hugo官方主页：&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo的安装方式有两种，一种是直接下载编译好的Hugo二进制文件。如果只是使用Hugo推荐用这种方式。另一种方式是获取Hugo的源码，自己编译。由于各种不可预料的网络问题，第二种方式不是那么轻易能成功，虽然最后我还是折腾出来了。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来后，只有一个叫hugo或者hugo.exe的程序，接下来开始生成自己的站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后hugo会自动生成这样一个目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简要介绍一下，config.toml是网站的配置文件，这是一个TOML文件，全称是Tom&amp;rsquo;s Obvious, Minimal Language，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。&lt;/p&gt;

&lt;p&gt;content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。&lt;/p&gt;

&lt;p&gt;进入生成的site目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是博客日志，最好将md文件放在content的post目录里。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+++可以替换为Jekyll一样的---，里面的内容是这篇文章的一些信息。下面就可以开始写你的文章内容，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++

### Hello Hugo

 1. aaa
 1. bbb
 1. ccc

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，刚才的about.md也有内容，该看看最后的效果了。然后你屁颠屁颠的使用hugo server启动，打开浏览器里一看，发现毛都没有！这是肿么了！&lt;/p&gt;

&lt;p&gt;这是Hugo对初学者非常不友好的地方，默认生成的网站是没有任何皮肤模板的。为了看看第一个写的示例，还得去Github上把一个网页模板下载下来。如果你网络够好，网速够快，你可以在刚才的目录将Hugo官方的所有模板都下载下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我尝试过，也失败过，且从未成功一次性将所有的模板下载下来。所以，我们还是老老实实只下载其中一个模板来看看效果吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd themes
$ git clone https://github.com/spf13/hyde.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动本地调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo server --theme=hyde --buildDrafts --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里打开：&lt;a href=&#34;http://127.0.0.1:1313&#34;&gt;http://127.0.0.1:1313&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoFirstPost.png-w&#34; alt=&#34;HugoFirstPost&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ndash;watch或者-w 选项打开的话，将会监控到文章的改动从而自动去刷新浏览器，不需要自己手工去刷新浏览器，非常方便。&lt;/p&gt;

&lt;p&gt;如果你看了上面的说明已经有冲动去试一试Hugo了，我的目的也算达到了，接下来你需要的只是查看官方的说明文档就够了，所以具体的一些设置我就不重复了。&lt;/p&gt;

&lt;p&gt;官方文档：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;皮肤列表：&lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;https://github.com/spf13/hugoThemes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;常用文档：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/overview/configuration/&#34;&gt;Configuring Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/extras/menus/&#34;&gt;Menus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/templates/variables/&#34;&gt;Template Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;遇到的问题:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;遇到的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;默认的ServerSide的代码着色会有问题，有些字的颜色会和背景色一样导致看不见。&lt;br /&gt;
解决方法：使用ClientSide的代码着色方案即可解决。（见：&lt;a href=&#34;https://gohugo.io/extras/highlighting/#client-side:c4210b265c792cac9a6cf6a5f53b671d&#34;&gt;Client-side Syntax Highlighting&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;URL全部被转成了小写，如果是旧博客迁移过来，将是无法接受的。&lt;br /&gt;
解决方法：&lt;del&gt;我是直接改了Hugo的代码，将URL强制转换为小写那段逻辑去掉了，之后考虑在config里提供配置开关，然后给Hugo提一个PR。如果是Windows用户可以直接&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo&#34;&gt;https://github.com/coderzh/ConvertToHugo&lt;/a&gt; 下载到我修改后的版本myhugo.exe。&lt;/del&gt;&lt;br /&gt;
Update(2015-09-03): 已经提交&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;PR&lt;/a&gt;并&lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;commit&lt;/a&gt;到Hugo，最新版本只需要在config里增加：&lt;br /&gt;
&lt;code&gt;disablePathToLower: true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文章的内容里不能像Jekyll一样可以内嵌代码模板了。最终会生成哪些页面，有一套相对固定而复杂的规则，你会发现想创建一个自定义界面会非常的困难。&lt;br /&gt;
解决方法：无，看文档，了解它的规则。博客程序一般也不需要特别的自定义界面。Hugo本身已经支持了类似posts, tags, categories等内容聚合的页面，同时支持rss.xml，404.html等。如果你的博客程序复杂到需要其他的页面，好好想想是否必须吧。&lt;/li&gt;
&lt;li&gt;如何将rss.xml替换为feed.xml？&lt;br /&gt;
解决方法：在config.yaml里加入：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; rssuri: &amp;quot;feed.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jekyll迁移到hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Jekyll迁移到Hugo&lt;/h3&gt;

&lt;p&gt;Jekyll的文章内容迁移到Hugo中，大部分内容是兼容的，但也有一些地方是不兼容的。主要有以下几个地方需要修改：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jekyll文章能从文件名里的日期部分读取到日期，并将剩余的部分当做的页面url的名称，比如：2015-08-29-first.md。而Hugo只认md文件里的date字段，url的名称如果用文件名的话将会使用完整的文件名（不会去除日期部分）。为了兼容，必须在md的Front Matter里写入url字段，用来说明该页面的相对url地址，从而保持兼容。&lt;/li&gt;
&lt;li&gt;tags, categories等字段必须用列表的方式，不像Jekyll中那样随意了。&lt;/li&gt;
&lt;li&gt;{% raw %} {% endraw %}将不需要了。&lt;/li&gt;
&lt;li&gt;{% highlight ruby %} 变成了{{&amp;lt; highlight ruby &amp;gt;}} 。不过我还是推荐使用``` ruby ```形式，然后使用ClientSide的Highlight，这样两边都兼容。&lt;/li&gt;
&lt;li&gt;需要将Jekyll里的public里的文件拷贝到Hugo的static目录里。&lt;/li&gt;
&lt;li&gt;Jekyll的文章必须放到Hugo的content/post目录里。&lt;/li&gt;
&lt;li&gt;Jekyll只需要push文章内容到github，服务器会自动生成静态页面。毕竟是github的亲儿子。而Hugo需要你将生成的public目录里的内容做为gh-pages分支push上去。具体的简便的方法见：&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假如你之前的博客和我一样是Jekyll的，可以尝试使用我写的&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo/blob/master/ConvertToHugo.py&#34;&gt;ConvertToHugo.py&lt;/a&gt; 工具。这个转换工具逻辑相对比较简单和清晰，如果满足不了你的需求你也可以轻易在此基础上做些修改，如果我能收到PR当然是最好了。&lt;/p&gt;

&lt;p&gt;反正，我是完全使用CovertToHugo.py将我原来的Jekyll博客全部转过来了。而且，我找到了一个非常炫酷的主题，并且在此基础稍微修改下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoBlog.jpg&#34; alt=&#34;HugoBlog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Blog地址：&lt;a href=&#34;http://blog.coderzh.com&#34;&gt;http://blog.coderzh.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update(2015-10-08) 国庆在家给Hugo提了个PR，已经将Jekyll迁移功能集成到了Hugo里，pull最新的Hugo代码，编译Hugo，然后可以执行：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo import jekyll YourJekyllDir TargetDir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将自动把你的Jekyll站点转换成Hugo的站点。欢迎试用并反馈。&lt;/p&gt;

&lt;h3 id=&#34;关于部署:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;关于部署&lt;/h3&gt;

&lt;p&gt;假设你需要部署在 &lt;code&gt;GitHub Pages&lt;/code&gt; 上，首先在GitHub上创建一个Repository，命名为：&lt;code&gt;coderzh.github.io&lt;/code&gt; （coderzh替换为你的github用户名）。&lt;/p&gt;

&lt;p&gt;在站点根目录执行 &lt;code&gt;Hugo&lt;/code&gt; 命令生成最终页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo --theme=hyde --baseUrl=&amp;quot;http://coderzh.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切顺利，所有静态页面都会生成到 &lt;code&gt;public&lt;/code&gt; 目录，将pubilc目录里所有文件 &lt;code&gt;push&lt;/code&gt; 到刚创建的Repository的 &lt;code&gt;master&lt;/code&gt; 分支。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd public
$ git init
$ git remote add origin https://github.com/coderzh/coderzh.github.io.git
$ git add -A
$ git commit -m &amp;quot;first commit&amp;quot;
$ git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里访问：&lt;code&gt;http://coderzh.github.io/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;自动部署的脚本可以参考我的Repo里的&lt;code&gt;deploy.py&lt;/code&gt;脚本：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;全自动化部署到GitHub和GitCafe，见我的另一篇博客：&lt;a href=&#34;http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/&#34;&gt;通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hugo中文文档:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hugo中文文档&lt;/h3&gt;

&lt;p&gt;Hugo中文文档网站：&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;http://www.gohugo.org/&lt;/a&gt; 已上线， 并且在不断完善中，欢迎访问。&lt;/p&gt;

&lt;p&gt;同时，欢迎加入Hugo交流QQ群：512499080&lt;/p&gt;

&lt;p&gt;以及关注微信公众号：hacker-thinking&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.coderzh.com/public/qrcode.jpg&#34; alt=&#34;qrcode&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用Jekyll官方的ReadMore摘要功能</title>
            <link>http://blog.coderzh.com/2015/08/15/JekyllReadMore/</link>
            <pubDate>Sat, 15 Aug 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/15/JekyllReadMore/</guid>
            <description>

&lt;p&gt;今天才发现，Jekyll官方就支持ReadMore摘要功能，记录一下。&lt;/p&gt;

&lt;p&gt;我之前的方法，在index.html中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; {{ post.content ||split:&#39;&#39; | first }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Post里，需要分隔的摘要后面加&lt;code&gt;。&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;摘要内容...

正文内容...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;官方做法-excerpt:b34704c1c1176e970544bf334bae729d&#34;&gt;官方做法: excerpt&lt;/h3&gt;

&lt;p&gt;官方的方法是，在_config.yml里，指定摘要的分隔符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;excerpt_separator:  &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在index.html中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; {{ post.excerpt }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，摘要需要去掉html标签，所以一般这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  {{ post.excerpt | strip_html }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，和前一种方法一样，在摘要后面加``  即可。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用ThreadSanitizer线程检查工具</title>
            <link>http://blog.coderzh.com/2015/08/15/ThreadSanitizer/</link>
            <pubDate>Sat, 15 Aug 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/15/ThreadSanitizer/</guid>
            <description>

&lt;p&gt;ThreadSanitizer又叫TSan，是一个检查线程Data Race的C/C++工具。它集成在新版的gcc和clang中，通过编译时加-fsanitize=thread，可以在运行时检测出Data Race的问题。&lt;/p&gt;

&lt;p&gt;ThreadSanitizer官网：&lt;a href=&#34;https://code.google.com/p/thread-sanitizer&#34;&gt;https://code.google.com/p/thread-sanitizer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;data-race:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;Data Race&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/Data-race.jpg&#34; alt=&#34;DataRace&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Data Race是指多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题。&lt;/p&gt;

&lt;p&gt;Data Race的问题非常难查，Data Race一旦发生，结果是不可预期的，也许直接就Crash了，也许导致执行流程错乱了，也许把内存破坏导致之后某个时刻突然Crash了。&lt;/p&gt;

&lt;h3 id=&#34;环境要求:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;环境要求&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux x86_64，内核版本不要太旧。（经测试，公司旧的开发机Linux内核是2.6.16是跑不了的，新的tlinux内核3.10.0可以）&lt;/li&gt;
&lt;li&gt;gcc 4.8版本以上（clang也集成了，3.2版本以上）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;官方示例:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;官方示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ cat simple_race.cc
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
 
int Global;
 
void *Thread1(void *x) {
  Global++;
  return NULL;
}
 
void *Thread2(void *x) {
  Global--;
  return NULL;
}
 
int main() {
  pthread_t t[2];
  pthread_create(&amp;amp;t[0], NULL, Thread1, NULL);
  pthread_create(&amp;amp;t[1], NULL, Thread2, NULL);
  pthread_join(t[0], NULL);
  pthread_join(t[1], NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在不加锁的情况下，两个线程同时去修改Global变量，从而导致Data Race。使用gcc的-fsanitize=thread 编译，执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ g++ simple_race.cc -fsanitize=thread -fPIE -pie -g
$ ./a.out
==================
WARNING: ThreadSanitizer: data race (pid=26327)
  Write of size 4 at 0x7f89554701d0 by thread T1:
    #0 Thread1(void*) simple_race.cc:8 (exe+0x000000006e66)
 
  Previous write of size 4 at 0x7f89554701d0 by thread T2:
    #0 Thread2(void*) simple_race.cc:13 (exe+0x000000006ed6)
 
  Thread T1 (tid=26328, running) created at:
    #0 pthread_create tsan_interceptors.cc:683 (exe+0x00000001108b)
    #1 main simple_race.cc:19 (exe+0x000000006f39)
 
  Thread T2 (tid=26329, running) created at:
    #0 pthread_create tsan_interceptors.cc:683 (exe+0x00000001108b)
    #1 main simple_race.cc:20 (exe+0x000000006f63)
==================
ThreadSanitizer: reported 1 warnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行程序，如果发生Data Race，错误信息会直接输出出来。如果错误信息比较多，重定向输出流到文件里，慢慢分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a.out &amp;gt;result.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关键要点:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;关键要点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;除了加-fsanitize=thread外，一定要加-fPIE -pie。&lt;/li&gt;
&lt;li&gt;-g 是为了能显示文件名和行号。&lt;/li&gt;
&lt;li&gt;如果分生成obj(-c)和link两个步骤，每一步都加：thread -fPIE -pie -g，并且在link的时候加-ltsan&lt;/li&gt;
&lt;li&gt;只支持64位，最好指定编译64位(-m64)&lt;/li&gt;
&lt;li&gt;如果依赖其他静态库，其他静态库编译时必须指定-fPIC（如果不是请重编）&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
