<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术文章 on CoderZh Blog</title>
        <link>http://blog.coderzh.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</link>
        <language>zh-CN</language>
        <author>CoderZh</author>
        <rights>Copyright (c) 2015, CoderZh; all rights reserved.</rights>
        <updated>Mon, 28 Sep 2015 22:43:26 CST</updated>
        
        <item>
            <title>Go语言极速入门手册.go</title>
            <link>http://blog.coderzh.com/2015/09/28/go-tips/</link>
            <pubDate>Mon, 28 Sep 2015 22:43:26 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/28/go-tips/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/golang.jpg&#34; alt=&#34;golang&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/CodeTips&#34;&gt;https://github.com/coderzh/CodeTips&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
gotips_test.go:
  Golang速学速查速用代码手册

Source: github.com/coderzh/CodeTips/blob/master/gotips_test.go

Author: coderzh(github.com/coderzh)
Blog: http://blog.coderzh.com
参考：《Go语言编程》
*/

package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;sync&amp;quot;
    // &amp;quot;errors&amp;quot;
    &amp;quot;math&amp;quot;
    &amp;quot;testing&amp;quot;
)

// 0. 注释
/*
规范：
 1. 命名：骆驼命名法（不要用下划线）

命令:
 go get github.com/coderzh/xxx
 go build calc
 go run xxx.go
 go install calc
*/

// 1. Hello World
func helloWorld() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}

// 2.变量类型
func typeDemo() {
    // 变量申明
    var v1 int
    var (
        v2 int
        v3 string
    )
    //var p *int // 指针类型

    // 变量初始化
    var v4 int = 10
    // 等价于:
    var v5 = 10
    // 一般这样就好
    v6 := 10

    // 赋值，多重赋值
    v1 = 10
    v2, v3 = 20, &amp;quot;test&amp;quot;
    // 匿名变量 _
    _, v4 = v5, v6

    fmt.Println(v1, v2, v3, v4)

    // 常量
    const Pi float64 = 3.1415926
    const MaxPlayer = 10

    // 枚举
    const (
        Sunday = iota // iota从0递增
        Mondy
        Tuesday
        // ...
    )

    // 类型
    // 1. 布尔
    var b1 bool
    b1 = true
    b1 = (1 == 2)

    fmt.Println(b1)

    // 2. 整形
    // int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint uintptr
    var i32 int32
    // 强制转换
    i32 = int32(64)
    // 运算：+, -, *, /, %（求余）
    // 比较：&amp;gt;, &amp;lt;, ==, &amp;gt;=, &amp;lt;=, !=
    // 位运算：x &amp;lt;&amp;lt; y, x &amp;gt;&amp;gt; y, x ^ y, x &amp;amp; y, x | y, ^x （取反）

    fmt.Println(i32)

    // 3. 浮点
    // float32, float64
    var f1 float64 = 1.0001
    var f2 float64 = 1.0002
    // 浮点比较
    isEqual := math.Dim(f1, f2) &amp;lt; 0.0001

    fmt.Println(isEqual)

    // 4. 字符串
    var s1 string
    s1 = &amp;quot;abc&amp;quot;
    // 字符串连接
    s1 = s1 + &amp;quot;ddd&amp;quot;
    // 取长度
    n := len(s1)
    // 取字符
    c1 := s1[0]

    fmt.Println(c1)

    // 字节遍历
    for i := 0; i &amp;lt; n; i++ {
        ch := s1[i]
        fmt.Println(ch)
    }
    // Unicode字符遍历
    for i, ch := range s1 {
        fmt.Println(i, ch)
    }

    // 5. 数组
    var arr1 [32]int
    //var arr2 [3][8]int // 二维数组
    // 初始化
    arr1 = [32]int{0}
    array := [5]int{1, 2, 3, 4, 5}
    // 数组遍历
    for i := 0; i &amp;lt; len(array); i++ {
        fmt.Println(array[i])
    }
    for i, v := range arr1 {
        fmt.Println(i, v)
    }
    // 数组是值类型，每次参数传递都是一份拷贝

    // 数组切片Slice
    var mySlice []int = array[:2]
    mySlice1 := make([]int, 5)
    mySlice2 := make([]int, 5, 10)

    fmt.Println(&amp;quot;len(mySlice2:&amp;quot;, len(mySlice2)) // 5
    fmt.Println(&amp;quot;cap(mySlice2:&amp;quot;, cap(mySlice2)) // 10

    mySlice3 := append(mySlice, 2, 3, 4)
    mySlice4 := append(mySlice, mySlice1...)

    copy(mySlice3, mySlice4)

    // 6. Map
    var m map[int]string
    m[1] = &amp;quot;ddd&amp;quot;
    m1 := make(map[int]string)
    m2 := map[int]string{
        1: &amp;quot;a&amp;quot;,
        2: &amp;quot;b&amp;quot;,
    }

    delete(m2, 1)

    value, ok := m1[1]
    if ok {
        fmt.Println(value)
    }

    for k, v := range m2 {
        fmt.Println(k, v)
    }

}

// 3. 流程控制
func flowDemo() {
    // if else
    a := 10
    if a &amp;lt; 10 {
        // ..
    } else {
        // ..
    }

    // switch
    switch a {
    case 0:
        fmt.Println(&amp;quot;0&amp;quot;)
    case 10:
        fmt.Println(&amp;quot;10&amp;quot;)
    default:
        fmt.Println(&amp;quot;default&amp;quot;)
    }

    switch {
    case a &amp;lt; 10:
        fmt.Println(&amp;quot;&amp;lt;10&amp;quot;)
    case a &amp;lt; 20:
        fmt.Println(&amp;quot;&amp;lt;20&amp;quot;)
    }

    // 循环
    for i := 0; i &amp;lt; 10; i++ {
    }
    // 无限循环
    sum := 0
    for {
        sum++
        if sum &amp;gt; 10 {
            break
            // 指定break
            // break JLoop
        }
    }

    goto JLoop

JLoop:
    // break to here

}

// 4. 函数
// func 函数名(参数列表)(返回值列表) {
// }
func sum1(value1 int, value2 int) (result int, err error) {
    // err = errors.New(&amp;quot;xxxx&amp;quot;)
    return value1 + value2, nil
}

func sum2(value1, value2 int) int {
    return value1 + value2
}

// 不定参数
// myFunc(1, 2, 3, 4, 5)
func myFunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
    // 传递
    // myFunc2(args...)
    // myFunc2(args[1:]...)
}

// 任意类型的不定参数
func myPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
        case int:
            fmt.Println(arg, &amp;quot; is int&amp;quot;)
        case string:
            fmt.Println(arg, &amp;quot; is string&amp;quot;)
        default:
            fmt.Println(arg, &amp;quot; is unknown&amp;quot;)
        }
    }
}

// 匿名函数
func anonymousFunc() {
    f := func(a, b int) int {
        return a + b
    }

    f(1, 2)
}

// defer
func copyFile(path string) {
    f, err := os.Open(path)
    if err != nil {
        return
    }

    defer f.Close()
    // or
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&amp;quot;Runtime error caught: %v&amp;quot;, r)
        }
    }()
}

// 5. 结构体
type Rect struct {
    // 小写为private
    x, y float64
    // 大写为public
    Width, Height float64
}

// 大写方法为public，小写为private
func (r *Rect) Area() float64 {
    return r.Width * r.Height
}

func netRect(x, y, width, height float64) *Rect {
    // 实例化结构体
    // rect1 := new(Rect)
    // rect2 := &amp;amp;Rect{}
    // rect3 := &amp;amp;Rect{Width:100, Height:200}
    return &amp;amp;Rect{x, y, width, height}
}

// 匿名组合
type Base struct {
    Name string
}

func (base *Base) Foo() {}
func (base *Base) Bar() {}

type Foo struct {
    Base
    *log.Logger
}

func (foo *Foo) Bar() {
    foo.Base.Bar()
    // ...
}

// 非侵入式接口
type IFile interface {
    Read(buf []byte) (n int, err error)
    Write(buf []byte) (n int, err error)
}

type File struct {
}

func (file *File) Read(buf []byte) (n int, err error) {
    return 0, nil
}

func (file *File) Write(buf []byte) (n int, err error) {
    return 0, nil
}

func interfaceDemo() {
    // 只要实现了Read, Write方法即可
    var file IFile = new(File)

    // 接口查询
    // 是否实现了IFile接口
    if file2, ok := file.(IFile); ok {
        file2.Read([]byte{})
    }
    // 实例类型是否是File
    if file3, ok := file.(*File); ok {
        file3.Read([]byte{})
    }

    // 类型查询
    switch v := file.(type) {
    }
}

// 6. 并发编程
func counting(ch chan int) {
    ch &amp;lt;- 1
    fmt.Println(&amp;quot;counting&amp;quot;)
}

func channelDemo() {
    chs := make([]chan int, 10)
    for i := 0; i &amp;lt; len(chs); i++ {
        chs[i] = make(chan int)
        // 带缓冲区大小
        // c: = make(chan int, 1024)
        // for i:= range c {
        // }
        go counting(chs[i])
    }

    for _, ch := range chs {
        &amp;lt;-ch
        // channel select
        /*
            select {
            case &amp;lt;-ch:
                // ...
            case ch &amp;lt;- 1:
            }
        */
    }

    // 单向Channel
    var ch1 chan&amp;lt;- int // 只能写入int
    var ch2 &amp;lt;-chan int // 只能读出int

    // 关闭Channel
    close(ch1)
    _, ok := &amp;lt;-ch2
    if !ok {
        // already closed
    }
}

// 锁
var m sync.Mutex

func lockDemo() {
    m.Lock()
    // do something
    defer m.Unlock()
}

// 全局唯一操作
var once sync.Once

// once.Do(someFunction)

// 7. 网络编程
// import &amp;quot;net&amp;quot;
// net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:8080&amp;quot;)

// 8. json处理
// import &amp;quot;encoding/json&amp;quot;
// json.Marshal(obj) 序列化
// json.Unmarshal() 反序列化

// 9. Web开发
// import &amp;quot;net/http&amp;quot;
// 模板
// import &amp;quot;html/template&amp;quot;

// 10. 常用库
// import &amp;quot;os&amp;quot;
// import &amp;quot;io&amp;quot;
// import &amp;quot;flag&amp;quot;
// import &amp;quot;strconv&amp;quot;
// import &amp;quot;crypto/sha1&amp;quot;
// import &amp;quot;crypto/md5&amp;quot;

// 11. 单元测试
// _test结尾的go文件： xxx_test.go
func testDemo(t *testing.T) {
    r := sum2(2, 3)
    if r != 5 {
        t.Errorf(&amp;quot;sum2(2, 3) failed. Got %d, expect 5.&amp;quot;, r)
    }
}

// 12. 性能测试
func benchmarkAdd(b *testing.B) {
    b.StopTimer()
    // dosometing
    b.StartTimer()
}

func main() {
    helloWorld()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
        <item>
            <title>博客图片切换到七牛</title>
            <link>http://blog.coderzh.com/2015/09/20/qiuniu/</link>
            <pubDate>Sun, 20 Sep 2015 20:37:42 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/20/qiuniu/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/qiniu.jpg&#34; alt=&#34;qiniu&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;做为一个独立博客，稳定、速度快是非常重要的指标。在博客的运营过程中，经常会不可避免的需要做迁移。比如，从WordPress到Jekyll，从Jekyll到Hugo。迁移之后，文章里的链接还能不能用，图片还能不能访问，是一个比较重要的问题。文章链接地址可以使用域名或者相对地址的方式方便迁移，而图片则稍微复杂一点点。&lt;/p&gt;

&lt;p&gt;假如图片和网页文件都是在服务器上自己管理，迁移时只需要把图片拷贝过去，然后保持访问的路径不变就可以了。自己管理图片有些不好的地方，首先图片可能占用你大量的服务器存储空间，其次访问时也将消耗服务器大量的流量。另外一种方式，是把图片放在一个第三方的地方，然后通过链接直接使用。而“第三方”就显得尤为重要的，假如这个“第三方”哪天突然倒了或者策略变化，导致之前的所有图片都失效了，将是不可接受的。&lt;/p&gt;

&lt;p&gt;正因为存在这样的需求，所以出现一些专业的提供图片托管的服务，俗称图床服务。这些图床服务通常提供这样一些服务：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;图床服务是稳定的，不会轻易中断。你就放心吧。&lt;/li&gt;
&lt;li&gt;通过CDN加速，让你的图片访问速度杠杠的。&lt;/li&gt;
&lt;li&gt;支持自定义域名，迁移过来或者迁移走都可以非常方便。&lt;/li&gt;
&lt;li&gt;提供水印等图片处理服务。（算是一个附加功能）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用图床服务还有一个好处，就是一旦当前使用的图床没法用了，只需要把图片都迁到另外一个图床继续使用，代价非常小。就算没有绑定自定义域名，迁移的时候做个简单的地址替换就可以了。&lt;/p&gt;

&lt;p&gt;在对比了国内的图床服务之后，我还是决定选择老东家金山出来的许式伟做的七牛云存储。七牛在上面四点都做的非常好，而且还提供10G免费空间。目前对我来说已经足够了。&lt;/p&gt;

&lt;p&gt;七牛云存储：&lt;a href=&#34;https://portal.qiniu.com/signup?code=3llo7yfu1ib7y&#34;&gt;www.qiniu.com&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages</title>
            <link>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</link>
            <pubDate>Sun, 13 Sep 2015 08:48:52 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/13/use-webhook-automated-deploy-hugo/</guid>
            <description>

&lt;p&gt;本文的主要内容如标题所示，通过webhook将Hugo自动部署至GitHub Pages和GitCafe Pages。如果你正好有这个需求，看这篇文章正好，可以节省你不少时间。如果不是，了解一下也无妨。&lt;/p&gt;

&lt;p&gt;首先，必须解释一下，为什么需要自动部署，以及为什么需要需要同时部署到GitHub Pages和GitCafe Pages。&lt;/p&gt;

&lt;h3 id=&#34;为什么要自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么要自动部署&lt;/h3&gt;

&lt;p&gt;使用Hugo生成的静态页面是在public文件夹里，部署的时候需要把public文件夹里的内容push到GitHub的gh-pages分支里。每次写完文章，除了push markdown格式的文章，还需要单独push生成的public文件夹里的东西，步骤稍显麻烦。&lt;/p&gt;

&lt;p&gt;之前参照了官方的做法，使用subtree来push public，步骤简化不少。然而，这还是不够简单。因为每次修改文章之后，必须依赖一个脚本才能正确提交和部署。假如你在手机里浏览时，发现一个错别字，顺手就在GitHub的Web界面就把错别字改了，然而这样并不会重新生成静态页面和部署。有些不方便。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面和部署的过程应该让机器自动来完成。&lt;strong&gt;写作应该是一个相对单纯的事情，使用Hugo的人应该更专注于写作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;为什么需要同时部署到github-pages和gitcafe-pages:f7c51a9b685c2720baf98649c3938c48&#34;&gt;为什么需要同时部署到GitHub Pages和GitCafe Pages&lt;/h3&gt;

&lt;p&gt;大公司很喜欢的一个词：容灾。GitHub出现不可访问的事情在国内也是常有的，而GitCafe作为国内的代码托管厂商，是否是一个稳定的存在也不好说。所以，将网站同时部署到这两个上面。通过DnsPod里CNAME设置线路“国内”和“国外”，不仅起到了任何一个挂掉，另一个可以继续工作的目的，还起到了CDN就近访问的作用。&lt;/p&gt;

&lt;p&gt;使用GitCafe还有另外一个原因。GitHub Pages拒绝了一切百度的爬虫，所以，百度无法索引到GitHub Pages的网页。对于国内的搜索市场来说，百度的份额还是比较大的，虽然我认为看我的博客的人都不应该使用百度，但现实总是残酷的。如果希望网站被百度收录，就必须放到GitHub以外的地方。GitCafe就是一种比较好的选择。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gitcafe.com&#34;&gt;http://gitcafe.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果，你只是希望使用官方的Hugo自动化部署到GitHub Pages，下面的内容你可以不用看了。你可以直接使用Wercker的服务来自动部署。&lt;/p&gt;

&lt;p&gt;文档见：&lt;a href=&#34;http://gohugo.io/tutorials/automated-deployments/&#34;&gt;
http://gohugo.io/tutorials/automated-deployments/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于Wercker还不支持GitCafe的部署，以及我需要使用特定的修改版本的Hugo来生成静态网页，并且希望这些步骤比较可控，所以，还是自己来折腾整个过程吧。&lt;/p&gt;

&lt;h3 id=&#34;webhook:f7c51a9b685c2720baf98649c3938c48&#34;&gt;webhook&lt;/h3&gt;

&lt;p&gt;webhook是GitHub上提供的Git的一种Hook机制，当代码发生变化时，比如代码被Push到GitHub的Repo时，GitHub会自动请求一个你指定的网页，并且把变更相关的参数都传递过来。入口在Repo的Settings - webhooks &amp;amp; services&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/WebHook.png-w&#34; alt=&#34;webhook&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明文档：&lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;https://developer.github.com/webhooks/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;借助webhook的机制，我们就可实现当有新的文章Push之后，自动通知远程的一台机器执行一个脚本，脚本的内容就是生成静态页面和Push部署到最终的服务器。&lt;/p&gt;

&lt;p&gt;webhook的Server接收webhook通知，然后执行一个脚本。这样的需求太普遍了，以至于完全不需要自己来实现。在GitHub里搜webhook可以搜出来很多。我主要挑选了Go语言的版本。主要有两个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/qiniu/webhook&#34;&gt;https://github.com/qiniu/webhook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/adnanh/webhook&#34;&gt;https://github.com/adnanh/webhook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个是七牛写的，代码很简单，用法也很简单。开始打算用七牛的版本。最后调试的时候发现json解析失败，完全不可用啊！有点坑爹。于是换成了第二个，这个Repo有200多个Star。还是靠谱很多，最后部署，调试，非常顺利。&lt;/p&gt;

&lt;p&gt;用法也很简单，首先安装webhook：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/adnanh/webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写一个配置文件hooks.json，里面指定需要执行的脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;redeploy-webhook&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/scripts/redeploy.sh&amp;quot;,
    &amp;quot;command-working-directory&amp;quot;: &amp;quot;/var/webhook&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定端口启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /path/to/webhook -hooks hooks.json -port=9876 -verbose
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后它将接受webhook地址：（把它填到GitHub里的webhook里）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://yourserver:9876/hooks/redeploy-webhook
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自动部署:f7c51a9b685c2720baf98649c3938c48&#34;&gt;自动部署&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/AutoDeploy.png-w&#34; alt=&#34;AutoDeploy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大致的流程如上图。上图的DigitalOcean是一台VPS服务器，我用了很长时间了，速度和稳定性都不错。需要的同学使用这个链接购买，可以获得10美元的优惠：&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;https://www.digitalocean.com/?refcode=e131e2bba197&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;整个流程中，复杂度主要是在DigitalOcean的VPS上部署服务和脚本。&lt;/p&gt;

&lt;p&gt;部署的脚本可以在我的GitHub上看到：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要的同学可以参考下，代码见：&lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog/blob/master/deploy.py&#34;&gt;deploy.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;deploy.py放到你的主工程，也就是你写markdown的Repo下。比如：/var/coderzh-hugo-blog/下&lt;/p&gt;

&lt;p&gt;adnanh-webhook的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &amp;quot;id&amp;quot;: &amp;quot;hugo-deploy&amp;quot;,
    &amp;quot;execute-command&amp;quot;: &amp;quot;/var/webhook/hugo-deploy.sh&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hugo-deploy.sh里执行deploy.py：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
 
python /var/coderzh-hugo-blog/deploy.py --auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下的是怎么在DigitalOcean的VPS上把这套东西部署起来。我使用nginx + supervisor搭建webhook的Server。&lt;/p&gt;

&lt;p&gt;关于nginx和supervisor可以参考之前的一篇文章：&lt;a href=&#34;http://blog.coderzh.com/2014/05/19/digitalocean/&#34;&gt;http://blog.coderzh.com/2014/05/19/digitalocean/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;supervisor的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[program:webhook]
command=/root/gocode/bin/webhook -hooks /var/webhook/hooks.json -verbose -port=9876
user=root
directory=/var/webhook
autorestart=true
redirect_stderr=true
environment=HOME=&amp;quot;/root&amp;quot;,USER=&amp;quot;root&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于VPS上SSH Key的设置，见：&lt;a href=&#34;https://help.github.com/articles/generating-ssh-keys/&#34;&gt;https://help.github.com/articles/generating-ssh-keys/&lt;/a&gt;  为了自动部署方便，可以不设置密码。&lt;/p&gt;

&lt;p&gt;当然，还有个大前提，在VPS上安装最新版本的golang。推荐使用gvm来安装。（记得安装1.5之前必须先把1.4先装上）&lt;/p&gt;

&lt;p&gt;golang 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
source ~/.bashrc
gvm version
gvm install go1.4
gvm install go1.5.1
gvm use go1.5.1 --default
go version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，Good Luck！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>给Hugo提交了一个PR</title>
            <link>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</link>
            <pubDate>Thu, 03 Sep 2015 08:55:31 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/09/03/a-hugo-pull-request/</guid>
            <description>&lt;p&gt;给Hugo提交了一个Pull Request，并且通过了，记录一下。PR的内容是在config里增加了disablePathToLower选项，可以配置是否需要阻止Hugo自动将路径转换为小写。在站点从旧的系统里迁移到Hugo中时会非常有用。&lt;/p&gt;

&lt;p&gt;在上一篇博客&lt;a href=&#34;http://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;使用hugo搭建个人博客站点&lt;/a&gt;  里提到，Hugo强制将所有路径都变成了小写。小写路径虽好，但是如果之前你的网站路径不是全小写的，迁移过来路径发生变化，将会导致路径失效，是不可接受的。&lt;/p&gt;

&lt;p&gt;上文提到，我硬改了Hugo代码，让它不要强制转换小写路径。这样的做法不够优雅，假如别人也和我有一样的需求怎么办？我们还是希望Hugo本身就能够提供这样的功能。于是，我决定把代码改的优雅一些，给Hugo作者提交一个Pull Request，将这个功能合并到Hugo代码里。&lt;/p&gt;

&lt;p&gt;于是，我在config文件里增加了一个选项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Do not make the url/path to lowercase
disablePathToLower: true 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加一个开关其实很简单，只需要在command/hugo.go里的LoadDefaultSettings函数里增加一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;viper.SetDefault(&amp;quot;DisablePathToLower&amp;quot;, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开关生效的实现也很简单，找到最终转换为小写的函数，加入disablePathToLower开关的判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MakePathSanitized(s string) string {
    if viper.GetBool(&amp;quot;DisablePathToLower&amp;quot;) {
        return MakePath(s)
    } else {
        return strings.ToLower(MakePath(s))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前的函数名叫MakePathToLower，由于我在内部加了个开关，于是名字不适用了，于是修改为了：MakePathSanitized。&lt;/p&gt;

&lt;p&gt;修改完成之后，需要把测试案例跑一遍，保证你的修改不会破坏原来的逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go test ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也要保证编译是成功的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我修改的第一个版本时，我犯了一个错误，导致测试案例没有通过。原因是第一个版本我增加的配置选项是PathToLower，默认值是true。而有些测试案例是没有去设置PathToLower的，默认读到的会是false，从而导致执行失败的执行结果。所以，config里增加的选项，默认值尽量是false吧，也会好理解一些。于是就有了：disablePathToLower&lt;/p&gt;

&lt;p&gt;提交Pull Request时，有几点需要注意的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将自己的修改合并成一个commit再提交Pull Request。（这样在主Resp里更加规范和整洁）&lt;/li&gt;
&lt;li&gt;commit message里的描述尽量简洁清晰，如果有对应的issue ID，最好加上：See #1234 or Fixes #1234 之类的。这样可以自动关联起来。&lt;/li&gt;
&lt;li&gt;不要在自己的master分支上修改提交PR，而是应该自己开一个单独分支，由该分支提交Pull Request到原Repo的master。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，我提交了这么一个Pull Request：&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;add configuration variable: &amp;ldquo;disablePathToLower&amp;rdquo; See #557&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不久后，Hugo的主要维护者之一通过了我的PR，很友善的将我蹩脚的中国式英语的commit message调整了一下合并到了Hugo的master：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoPR.png-w&#34; alt=&#34;HugoPR&#34; /&gt;&lt;/p&gt;

&lt;p&gt;commit: &lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这就是开源项目的好处，开源社区的魅力所在：&lt;strong&gt;你可以使用它，修改它，贡献自己的代码，参与其中，让它变好，让所有人受益&lt;/strong&gt;。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用hugo搭建个人博客站点</title>
            <link>http://blog.coderzh.com/2015/08/29/hugo/</link>
            <pubDate>Sat, 29 Aug 2015 16:52:15 CST</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/29/hugo/</guid>
            <description>

&lt;p&gt;Hugo是一个用Go语言编写的静态网站生成器，它使用起来非常简单，相对于Jekyll复杂的安装设置来说，Hugo仅需要一个二进制文件hugo(hugo.exe)即可轻松用于本地调试和生成静态页面。&lt;/p&gt;

&lt;p&gt;Hugo生成静态页面的效率很高，我的260多篇博客文章生成几乎是瞬间完成的，而之前用Jekyll需要等待10秒左右。&lt;/p&gt;

&lt;p&gt;Hugo自带watch的调试模式，可以在我修改MarkDown文章之后切换到浏览器，页面会检测到更新并且自动刷新，呈现出最终效果，能极大的提高博客书写效率。再加上Hugo是使用Go语言编写，已经没有任何理由不使用Hugo来代替Jekyll作为我的个人博客站点生成器了。&lt;/p&gt;

&lt;h3 id=&#34;静态网站生成器:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;静态网站生成器&lt;/h3&gt;

&lt;p&gt;什么是静态网站生成器？如果追溯到最早的网站形式，那时候的网页都是静态的，即一个内容不变的html文件放在服务器上，人们通过互联网访问浏览的都是这个一成不变的页面。后来，人们发现，需要和网页进行交互，能根据用户的输入动态呈现出相应的内容，这就是动态网站。那，为什么现在又回归使用静态网站呢？特别是对于博客网站这种特殊的形式。我的理解是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;访问速度提升。静态页面不需要像动态页面那样经常去查询数据库，而是直接将最终页面内容返回。&lt;/li&gt;
&lt;li&gt;搜素引擎友好。便于搜索引擎索引，比如很多动态网站的页面地址是一样的，只是后面传入的参数不一样，容易让搜索引擎误认为是同一个页面。（虽然不会）&lt;/li&gt;
&lt;li&gt;可以完全抛弃数据库，减少复杂度，将最复杂的一步交给静态网站生成器，自己只专注写作、生成、发布三个步骤。&lt;/li&gt;
&lt;li&gt;博客文章可以以文本文件的方式（MarkDown）在本地维护管理，不需要像之前那样在网页的编辑器里提交到网站数据库。你可以方便的使用github管理你的博客文章，不会丢失，又能追溯到每一次的内容变更。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前最流行的静态网站生成器是Jekyll，它是github创始人自己实现的一套ruby的静态网站生成器。一经推出，各个程序哥竞相效仿，一时间使用Jekyll搭建自己的博客变成了一件很高逼格的事情。&lt;/p&gt;

&lt;p&gt;我也是跟风者之一，在Jekyll之前，我主要也是在博客园写文章，同时独立博客这块也尝试过自己实现的博客程序，用GAE写过，后来又用Tornado写过，都是动态网站。自己实现博客程序，总是在开始一段时间内很狂热，当一切实现完成，细节修缮好之后很快就失去了兴趣。因为你的注意力从只是写文章，经常转移到其他地方去。比如网站不好看，需要去改一改网站的风格样式，修复BUG，加一加功能等等。&lt;/p&gt;

&lt;p&gt;所以，如果只是专注于写作，还是找一个稳定一些，提供大量现成皮肤，有稳定专业的组织维护更新的博客系统。使用Jekyll确实让我眼前一亮，原来博客程序可以这么玩。于是利用周末的时间，我将我之前所有的文章，包括博客园的文章，都迁移到了Jekyll上来。自从有了Jekyll，我终于可以开开心心的专注的写文章了，而且使用喜欢的MarkDown格式。：）&lt;/p&gt;

&lt;p&gt;在使用了Jekyll一段时间后，它的问题也逐渐暴露出来：静态页面生成的效率不够高。因为我把以前的文章都导入了过来，一共有260来篇，每次编辑文章后，需要等等10秒，待它将所有页面检查并生成完成之后，才能看到最终的效果。这是我最不能忍受的一点。对于初学者，Jekyll还有很多问题，比如环境搭建非常复杂，导致使用Jekyll的人大都是一些喜欢折腾，不怕折腾的程序哥。&lt;/p&gt;

&lt;p&gt;随着Go1.5版本的发布，让我意识到是时候好好玩一玩Go语言了。使用Go语言实现的静态网站生成器Hugo（雨果）立即吸引了我，它解决了我最大的痛点：生成的效率。文档、社区各方面的支持都不错，使用起来非常简单，各种皮肤直接套用，于是我又开始了Jekyll迁移到Hugo的漫漫长路。（一个周末的时间）&lt;/p&gt;

&lt;p&gt;&lt;del&gt;即使迁移到了Hugo，我还保留着原来的Jekyll博客，只是不会再更新了，用来怀念？还是哪天突然又跳回来也不一定。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我的Jeklly博客：&lt;a href=&#34;http://jekyll.coderzh.com&#34;&gt;http://jekyll.coderzh.com&lt;/a&gt;&lt;/del&gt; Update(2015-09-20 ): 觉得没啥用了，还是干掉了&lt;/p&gt;

&lt;p&gt;我的Hugo博客：&lt;a href=&#34;http://blog.coderzh.com/&#34;&gt;http://blog.coderzh.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;github-pages:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;GitHub Pages&lt;/h3&gt;

&lt;p&gt;使用静态网站生成器生成好静态页面之后，需要把文件放到服务器上供别人浏览。比较传统的方式是租用VPS虚拟服务器，比如：linode、digitalocean。将生成好的静态页面手工上传到服务器上。如果你习惯这种方式部署，推荐你使用&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;digitalocean&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然， 还有更好的方式，就是直接把网站托管到GitHub Pages。你只需要在GitHub上创建一个项目，然后将生成出来的静态页面文件push到这个项目的gh-pages分支，保证根目录有一个index.html文件即可。这样，一个免费、无限流量的博客系统就搭建完成了。同时，通过github你可以方便对博客文章进行管理和追踪。&lt;/p&gt;

&lt;h3 id=&#34;hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hugo&lt;/h3&gt;

&lt;p&gt;前面的铺垫介绍的差不多了，该主角上场了。Hugo是什么？它主要做了什么？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hugo只有一个二进制文件（比如Windows里只是一个hugo.exe）&lt;/li&gt;
&lt;li&gt;Hugo可以将你写好的MarkDown格式的文章自动转换为静态的网页。&lt;/li&gt;
&lt;li&gt;Hugo内置web服务器，可以方便的用于本地调试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;hello-hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Hello Hugo&lt;/h3&gt;

&lt;p&gt;Hugo官方主页：&lt;a href=&#34;https://gohugo.io/&#34;&gt;https://gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hugo的安装方式有两种，一种是直接下载编译好的Hugo二进制文件。如果只是使用Hugo推荐用这种方式。另一种方式是获取Hugo的源码，自己编译。由于各种不可预料的网络问题，第二种方式不是那么轻易能成功，虽然最后我还是折腾出来了。&lt;/p&gt;

&lt;p&gt;Hugo二进制下载地址：&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载下来后，只有一个叫hugo或者hugo.exe的程序，接下来开始生成自己的站点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new site /path/to/site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后hugo会自动生成这样一个目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  ▸ archetypes/
  ▸ content/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简要介绍一下，config.toml是网站的配置文件，这是一个TOML文件，全称是Tom&amp;rsquo;s Obvious, Minimal Language，这是它的作者GitHub联合创始人Tom Preston-Werner 觉得YAML不够优雅，捣鼓出来的一个新格式。如果你不喜欢这种格式，你可以将config.toml替换为YAML格式的config.yaml，或者json格式的config.json。hugo都支持。&lt;/p&gt;

&lt;p&gt;content目录里放的是你写的markdown文章，layouts目录里放的是网站的模板文件，static目录里放的是一些图片、css、js等资源。&lt;/p&gt;

&lt;p&gt;创建一个页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是博客日志，最好将md文件放在content的post目录里。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new post/first.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完后，会在content/post目录自动生成一个MarkDown格式的first.md文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+++可以替换为Jekyll一样的---，里面的内容是这篇文章的一些信息。下面就可以开始写你的文章内容，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-01-08T08:36:54-07:00&amp;quot;
draft = true
title = &amp;quot;first&amp;quot;
 
+++

### Hello Hugo

 1. aaa
 1. bbb
 1. ccc

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，刚才的about.md也有内容，该看看最后的效果了。然后你屁颠屁颠的使用hugo server启动，打开浏览器里一看，发现毛都没有！这是肿么了！&lt;/p&gt;

&lt;p&gt;这是Hugo对初学者非常不友好的地方，默认生成的网站是没有任何皮肤模板的。为了看看第一个写的示例，还得去Github上把一个网页模板下载下来。如果你网络够好，网速够快，你可以在刚才的目录将Hugo官方的所有模板都下载下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我尝试过，也失败过，且从未成功一次性将所有的模板下载下来。所以，我们还是老老实实只下载其中一个模板来看看效果吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd themes
$ git clone https://github.com/spf13/hyde.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动本地调试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo server --theme=hyde --buildDrafts --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里打开：&lt;a href=&#34;http://127.0.0.1:1313&#34;&gt;http://127.0.0.1:1313&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoFirstPost.png-w&#34; alt=&#34;HugoFirstPost&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ndash;watch或者-w 选项打开的话，将会监控到文章的改动从而自动去刷新浏览器，不需要自己手工去刷新浏览器，非常方便。&lt;/p&gt;

&lt;p&gt;如果你看了上面的说明已经有冲动去试一试Hugo了，我的目的也算达到了，接下来你需要的只是查看官方的说明文档就够了，所以具体的一些设置我就不重复了。&lt;/p&gt;

&lt;p&gt;官方文档：&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;https://gohugo.io/overview/introduction/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;皮肤列表：&lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;https://github.com/spf13/hugoThemes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;常用文档：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/overview/configuration/&#34;&gt;Configuring Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/extras/menus/&#34;&gt;Menus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/templates/variables/&#34;&gt;Template Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;遇到的问题:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;遇到的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;默认的ServerSide的代码着色会有问题，有些字的颜色会和背景色一样导致看不见。&lt;br /&gt;
解决方法：使用ClientSide的代码着色方案即可解决。（见：&lt;a href=&#34;https://gohugo.io/extras/highlighting/#client-side:c4210b265c792cac9a6cf6a5f53b671d&#34;&gt;Client-side Syntax Highlighting&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;URL全部被转成了小写，如果是旧博客迁移过来，将是无法接受的。&lt;br /&gt;
解决方法：&lt;del&gt;我是直接改了Hugo的代码，将URL强制转换为小写那段逻辑去掉了，之后考虑在config里提供配置开关，然后给Hugo提一个PR。如果是Windows用户可以直接&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo&#34;&gt;https://github.com/coderzh/ConvertToHugo&lt;/a&gt; 下载到我修改后的版本myhugo.exe。&lt;/del&gt;&lt;br /&gt;
Update(2015-09-03): 已经提交&lt;a href=&#34;https://github.com/spf13/hugo/pull/1392&#34;&gt;PR&lt;/a&gt;并&lt;a href=&#34;https://github.com/spf13/hugo/commit/52d94fa67578f6b63035e73b236ca8abd40d0006&#34;&gt;commit&lt;/a&gt;到Hugo，最新版本只需要在config里增加：&lt;br /&gt;
&lt;code&gt;disablePathToLower: true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文章的内容里不能像Jekyll一样可以内嵌代码模板了。最终会生成哪些页面，有一套相对固定而复杂的规则，你会发现想创建一个自定义界面会非常的困难。&lt;br /&gt;
解决方法：无，看文档，了解它的规则。博客程序一般也不需要特别的自定义界面。Hugo本身已经支持了类似posts, tags, categories等内容聚合的页面，同时支持rss.xml，404.html等。如果你的博客程序复杂到需要其他的页面，好好想想是否必须吧。&lt;/li&gt;
&lt;li&gt;如何将rss.xml替换为feed.xml？&lt;br /&gt;
解决方法：在config.yaml里加入：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; rssuri: &amp;quot;feed.xml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;jekyll迁移到hugo:826b8fbf4b1c9d49ecec9c1552f05b58&#34;&gt;Jekyll迁移到Hugo&lt;/h3&gt;

&lt;p&gt;Jekyll的文章内容迁移到Hugo中，大部分内容是兼容的，但也有一些地方是不兼容的。主要有以下几个地方需要修改：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jekyll文章能从文件名里的日期部分读取到日期，并将剩余的部分当做的页面url的名称，比如：2015-08-29-first.md。而Hugo只认md文件里的date字段，url的名称如果用文件名的话将会使用完整的文件名（不会去除日期部分）。为了兼容，必须在md的Front Matter里写入url字段，用来说明该页面的相对url地址，从而保持兼容。&lt;/li&gt;
&lt;li&gt;tags, categories等字段必须用列表的方式，不像Jekyll中那样随意了。&lt;/li&gt;
&lt;li&gt;{% raw %} {% endraw %}将不需要了。&lt;/li&gt;
&lt;li&gt;{% highlight ruby %} 变成了{{&amp;lt; highlight ruby &amp;gt;}} 。不过我还是推荐使用``` ruby ```形式，然后使用ClientSide的Highlight，这样两边都兼容。&lt;/li&gt;
&lt;li&gt;需要将Jekyll里的public里的文件拷贝到Hugo的static目录里。&lt;/li&gt;
&lt;li&gt;Jekyll的文章必须放到Hugo的content/post目录里。&lt;/li&gt;
&lt;li&gt;Jekyll只需要push文章内容到github，服务器会自动生成静态页面。毕竟是github的亲儿子。而Hugo需要你将生成的public目录里的内容做为gh-pages分支push上去。具体的简便的方法见：&lt;a href=&#34;https://gohugo.io/tutorials/github-pages-blog/&#34;&gt;Hosting on GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;假如你之前的博客和我一样是Jekyll的，可以尝试使用我写的&lt;a href=&#34;https://github.com/coderzh/ConvertToHugo/blob/master/ConvertToHugo.py&#34;&gt;ConvertToHugo.py&lt;/a&gt; 工具。这个转换工具逻辑相对比较简单和清晰，如果满足不了你的需求你也可以轻易在此基础上做些修改，如果我能收到PR当然是最好了。&lt;/p&gt;

&lt;p&gt;反正，我是完全使用CovertToHugo.py将我原来的Jekyll博客全部转过来了。而且，我找到了一个非常炫酷的主题，并且在此基础稍微修改下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/HugoBlog.jpg&#34; alt=&#34;HugoBlog&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Blog地址：&lt;a href=&#34;http://blog.coderzh.com&#34;&gt;http://blog.coderzh.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/coderzh/coderzh-hugo-blog&#34;&gt;https://github.com/coderzh/coderzh-hugo-blog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用Jekyll官方的ReadMore摘要功能</title>
            <link>http://blog.coderzh.com/2015/08/15/JekyllReadMore/</link>
            <pubDate>Sat, 15 Aug 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/15/JekyllReadMore/</guid>
            <description>

&lt;p&gt;今天才发现，Jekyll官方就支持ReadMore摘要功能，记录一下。&lt;/p&gt;

&lt;p&gt;我之前的方法，在index.html中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; {{ post.content ||split:&#39;&#39; | first }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Post里，需要分隔的摘要后面加&lt;code&gt;。&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;摘要内容...

正文内容...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;官方做法-excerpt:b34704c1c1176e970544bf334bae729d&#34;&gt;官方做法: excerpt&lt;/h3&gt;

&lt;p&gt;官方的方法是，在_config.yml里，指定摘要的分隔符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;excerpt_separator:  &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在index.html中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt; {{ post.excerpt }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，摘要需要去掉html标签，所以一般这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  {{ post.excerpt | strip_html }} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，和前一种方法一样，在摘要后面加``  即可。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>使用ThreadSanitizer线程检查工具</title>
            <link>http://blog.coderzh.com/2015/08/15/ThreadSanitizer/</link>
            <pubDate>Sat, 15 Aug 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/08/15/ThreadSanitizer/</guid>
            <description>

&lt;p&gt;ThreadSanitizer又叫TSan，是一个检查线程Data Race的C/C++工具。它集成在新版的gcc和clang中，通过编译时加-fsanitize=thread，可以在运行时检测出Data Race的问题。&lt;/p&gt;

&lt;p&gt;ThreadSanitizer官网：&lt;a href=&#34;https://code.google.com/p/thread-sanitizer&#34;&gt;https://code.google.com/p/thread-sanitizer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;data-race:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;Data Race&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/Data-race.jpg&#34; alt=&#34;DataRace&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Data Race是指多个线程在没有正确加锁的情况下，同时访问同一块数据，并且至少有一个线程是写操作，对数据的读取和修改产生了竞争，从而导致各种不可预计的问题。&lt;/p&gt;

&lt;p&gt;Data Race的问题非常难查，Data Race一旦发生，结果是不可预期的，也许直接就Crash了，也许导致执行流程错乱了，也许把内存破坏导致之后某个时刻突然Crash了。&lt;/p&gt;

&lt;h3 id=&#34;环境要求:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;环境要求&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Linux x86_64，内核版本不要太旧。（经测试，公司旧的开发机Linux内核是2.6.16是跑不了的，新的tlinux内核3.10.0可以）&lt;/li&gt;
&lt;li&gt;gcc 4.8版本以上（clang也集成了，3.2版本以上）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;官方示例:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;官方示例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ cat simple_race.cc
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
 
int Global;
 
void *Thread1(void *x) {
  Global++;
  return NULL;
}
 
void *Thread2(void *x) {
  Global--;
  return NULL;
}
 
int main() {
  pthread_t t[2];
  pthread_create(&amp;amp;t[0], NULL, Thread1, NULL);
  pthread_create(&amp;amp;t[1], NULL, Thread2, NULL);
  pthread_join(t[0], NULL);
  pthread_join(t[1], NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在不加锁的情况下，两个线程同时去修改Global变量，从而导致Data Race。使用gcc的-fsanitize=thread 编译，执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$ g++ simple_race.cc -fsanitize=thread -fPIE -pie -g
$ ./a.out
==================
WARNING: ThreadSanitizer: data race (pid=26327)
  Write of size 4 at 0x7f89554701d0 by thread T1:
    #0 Thread1(void*) simple_race.cc:8 (exe+0x000000006e66)
 
  Previous write of size 4 at 0x7f89554701d0 by thread T2:
    #0 Thread2(void*) simple_race.cc:13 (exe+0x000000006ed6)
 
  Thread T1 (tid=26328, running) created at:
    #0 pthread_create tsan_interceptors.cc:683 (exe+0x00000001108b)
    #1 main simple_race.cc:19 (exe+0x000000006f39)
 
  Thread T2 (tid=26329, running) created at:
    #0 pthread_create tsan_interceptors.cc:683 (exe+0x00000001108b)
    #1 main simple_race.cc:20 (exe+0x000000006f63)
==================
ThreadSanitizer: reported 1 warnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行程序，如果发生Data Race，错误信息会直接输出出来。如果错误信息比较多，重定向输出流到文件里，慢慢分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a.out &amp;gt;result.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关键要点:ee3062e1786be8171e5aa95e9b33a1dc&#34;&gt;关键要点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;除了加-fsanitize=thread外，一定要加-fPIE -pie。&lt;/li&gt;
&lt;li&gt;-g 是为了能显示文件名和行号。&lt;/li&gt;
&lt;li&gt;如果分生成obj(-c)和link两个步骤，每一步都加：thread -fPIE -pie -g，并且在link的时候加-ltsan&lt;/li&gt;
&lt;li&gt;只支持64位，最好指定编译64位(-m64)&lt;/li&gt;
&lt;li&gt;如果依赖其他静态库，其他静态库编译时必须指定-fPIC（如果不是请重编）&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>Cocos2d-x3.6 Android编译问题</title>
            <link>http://blog.coderzh.com/2015/06/06/Cocos2dx36/</link>
            <pubDate>Sat, 06 Jun 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/06/06/Cocos2dx36/</guid>
            <description>&lt;p&gt;在Cocod2d-x论坛上看到越来越多人吐槽新版本更新太快，改动太大，而且经常有BUG导致升级要折腾很久很久。。但我就是喜欢折腾，喜欢升级到最新版本，看看有了哪些新功能，哪些改进。为此也折腾了不少，遇到一点就记录一点吧。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;3.5版本之后，Android编译的build_native.py改成了直接调用cocos compile，我把所有都升级到了最新版本还是编译不成功，只好放弃，也许是我打开方式不对，还是先使用旧的build_native.py编译吧。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;出现提示找不到“org.cocos2dx.lib.Cocos2dxActivity“， Cocos2dxAcitivy明明在link的libcocos2d里啊，怎么还说找不到。
解决方法：干脆把libcocos2d删了，重新自己手工添加一个，右键BuildPath-&amp;gt;Link Source&amp;hellip; 添加一次即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CCImage.cpp突然编译不过了，提示找不到uint32，JSAMPROW。
解决办法：uint32依赖tiff，JSAMPROW依赖jpeg，而之前我为了省一点点包大小，通过-DCC_USE_TIFF=0 -DCC_USE_JPEG=0把这两个东东禁掉了。所以把tiff和jpeg打开就好了。别省了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开eclipse工程后，出现&amp;rdquo;serializing cdt project settings&amp;rdquo;
解决方法：见 &lt;a href=&#34;http://blog.csdn.net/djvc/article/details/41117677&#34;&gt;http://blog.csdn.net/djvc/article/details/41117677&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开eclipse工程后，出现“Lint Error Checking&amp;rdquo;
解决方法：Windows -&amp;gt; perferences -&amp;gt; Android -&amp;gt; Lint Error Checking，把左边的When saving files,check for errors复选框去掉&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>OpenWrt资料汇总</title>
            <link>http://blog.coderzh.com/2015/04/18/OpenWrt/</link>
            <pubDate>Sat, 18 Apr 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/04/18/OpenWrt/</guid>
            <description>

&lt;p&gt;上周末折腾了一下OpenWrt，打算把Facebook的网络模拟工具部署到上面，最终以失败告终。上github看，发现已经有人给作者提了issue，作者表示部署在OpenWrt上会很有用，但确实在OpenWrt上跑ATC会很困难。&lt;/p&gt;

&lt;p&gt;见：&lt;a href=&#34;https://github.com/facebook/augmented-traffic-control/issues/54&#34;&gt;https://github.com/facebook/augmented-traffic-control/issues/54&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;openwrt:80e8efd1348c6d65716736b932ab53c4&#34;&gt;OpenWrt&lt;/h3&gt;

&lt;p&gt;OpenWrt是适合于嵌入式设备的一个Linux发行版。它减小轻便，我安装完整个系统，初始大小只有10M，但是看上去五脏俱全。是现在主流路由器固件之一（OpenWrt，dd-wrt，tomato）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/openwrt.png&#34; alt=&#34;opnwrt&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是折腾过程中看的一些参考文章，记录一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://downloads.openwrt.org&#34;&gt;OpenWrt Downloads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sqzr.cc/blog/2013/11/09/openwrt-opkgwu-fa-lian-wang-xia-zai-jie-jue-ban-fa/&#34;&gt;openwrt opkg无法联网下载解决办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.openwrt.org.cn/bbs/forum.php?mod=viewthread&amp;amp;tid=60&amp;amp;extra=page%3D1&#34;&gt;OpenWrt系列教程汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/phodal/article/details/8521712&#34;&gt;Openwrt python,openwrt上使用Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scola.github.io/deploy-goagent-on-openwrt-tplink-703n/&#34;&gt;在openwrt-tplink703n路由器上成功部署GoAgent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpgao.com/xiaomi_router_python.html&#34;&gt;小米路由器mini折腾之Python篇(OpenWRT,Pandorabox,官方)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.openwrt.org/zh-cn/doc/howto/usb.storage&#34;&gt;挂载USB存储设备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_53689eaf0100xksw.html&#34;&gt;VirtualBox扩展虚拟机硬盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/xianfangloveyangmei/p/3675385.html&#34;&gt;刷openwrt 挂载u盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jyd.me/linux/pip-install-to-different-home/&#34;&gt;pip安装到指定目录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>C&#43;&#43;开源代码覆盖率工具OpenCppCoverage介绍(Windows)</title>
            <link>http://blog.coderzh.com/2015/04/10/OpenCppCoverage/</link>
            <pubDate>Fri, 10 Apr 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/04/10/OpenCppCoverage/</guid>
            <description>&lt;p&gt;Windows平台下开源的C++代码覆盖率工具，使用简单，功能齐全而强大。2014年才推出的，只恨没有早点发现。&lt;/p&gt;

&lt;p&gt;关于代码覆盖率统计工具，Linux平台下，gcc内置支持gcov，通过编译时加参数选项，进行代码插桩，从而实现代码覆盖率。在Windows平台下，早在几年前，我还没找到特别好用又开源的覆盖率工具，所以以前公司是自己实现了一套，使用起来也不是很方便。&lt;/p&gt;

&lt;p&gt;最近又遇到同样的问题，不过非常幸运的是，一款开源的Windows平台的C++代码覆盖率工具出现了在我的面前：OpenCppCoverage。使用起来非常简单，它不需要在编译时插桩，只需要有pdb文件，运行时插桩，通过OpenCppCoverage启动进程即可。&lt;/p&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://opencppcoverage.codeplex.com/&#34;&gt;https://opencppcoverage.codeplex.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;功能也比较全，主要特点有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不需要重新编译被测程序，只需要使用OpenCppCoverage运行程序。&lt;/li&gt;
&lt;li&gt;性能开销比较小。&lt;/li&gt;
&lt;li&gt;按模块、代码路径过滤。&lt;/li&gt;
&lt;li&gt;自动生成html覆盖率结果报告。&lt;/li&gt;
&lt;li&gt;支持多个覆盖率结果合并。&lt;/li&gt;
&lt;li&gt;集成Jenkins&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用起来不要太简单，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OpenCppCoverage.exe --sources MySourcePath -- YourProgram.exe arg1 arg2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用文档：&lt;a href=&#34;https://opencppcoverage.codeplex.com/documentation&#34;&gt;https://opencppcoverage.codeplex.com/documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jenkins集成：&lt;a href=&#34;https://opencppcoverage.codeplex.com/wikipage?title=Jenkins&#34;&gt;https://opencppcoverage.codeplex.com/wikipage?title=Jenkins&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;覆盖率详细结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/codecoverage.png&#34; alt=&#34;codecoverage&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jenkins集成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/JenkinsModuleCoverage_thumb.jpg&#34; alt=&#34;JenkinsOpenCppCoverage&#34; /&gt;&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>Facebook网络模拟测试工具ATC使用</title>
            <link>http://blog.coderzh.com/2015/03/29/AugmentedTrafficControl/</link>
            <pubDate>Sun, 29 Mar 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/03/29/AugmentedTrafficControl/</guid>
            <description>&lt;p&gt;就在上周，Facebook在其工程博客（&lt;a href=&#34;https://code.facebook.com/posts/1561127100804165/augmented-traffic-control-a-tool-to-simulate-network-conditions/&#34;&gt;原文&lt;/a&gt;）上宣布开源移动网络测试工具Augmented Traffic Control（&lt;a href=&#34;https://github.com/facebook/augmented-traffic-control&#34;&gt;ATC&lt;/a&gt;），我迅速试用了一番，非常不错，对手游或者其他APP的调试和测试都非常有帮助，介绍给大家。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/ATC.jpg-w&#34; alt=&#34;ATC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在已经是APP时代了，由于手机网络的特殊性，移动APP需要面临更加复杂的网络环境。在设计之初就要考虑如何应对各种网络环境，比如很高的延迟，经常丢包，频繁的断线。特别是手游，断线重连机制设计的好坏直接影响到游戏的体验。&lt;/p&gt;

&lt;p&gt;所以，在开发过程中模拟各种网络环境进行测试变得越来越重要。在ATC出来之前，微软曾经有一个网络模拟工具NEWT（Network Emulator for Windows Toolkit），使用起来也是方便。（NEWT的诞生也蛮有意思，见：&lt;a href=&#34;http://blog.sina.com.cn/s/blog_4caedc7a0100g9y6.html&#34;&gt;NEWT的前世今生&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/NEWT.jpg-w&#34; alt=&#34;NEWT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么，对比NEWT，ATC有些什么特点呢？&lt;/p&gt;

&lt;p&gt;ATC有两个最吸引人的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在手机上通过Web界面就可以随时切换不同的网络环境。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多个手机可以连接到同一个WIFI下，相互之间模拟的网络环境各不影响。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以想象一下这个场景：一群程序猿和测试猴子热火朝天的在办公室忙活着，这时有一个叫ATC WiFi的热点，任何人都可以将手机连接上去，通过Web界面随意切换到各种不同的网络环境下进行调试和测试……&lt;/p&gt;

&lt;p&gt;想想都有点小激动呢，接下来就来试用一把，感受一下ATC的威力。&lt;/p&gt;

&lt;p&gt;ATC只能运行在Linux上，所以搭建部署稍显麻烦一些。本文将介绍在虚拟机里如何搭建ATC环境。大致有以下几个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;VMWare装个Ubuntu系统吧（以前我常用VirtualBox，各种兼容性问题被坑惨了不敢用了）。&lt;/li&gt;
&lt;li&gt;除非你的机器有无线网卡，不然找一个USB无线网卡，用来设置WIFI热点。&lt;/li&gt;
&lt;li&gt;部署ATC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ubuntu中设置WiFi热点功能，在系统自带的工具里可以直接开启。但是，由于是Ad-hoc模式，Android手机根本搜不到信号。所以必须设置AP模式才能让Android手机搜到。我折腾了好一阵，最后发现这篇文章最靠谱：&lt;a href=&#34;http://my.oschina.net/eechen/blog/227230&#34;&gt;http://my.oschina.net/eechen/blog/227230&lt;/a&gt;，照着设置一般就OK了。&lt;/p&gt;

&lt;p&gt;接下来是部署ATC，其实也很简单，官方文档上写的也很清楚：&lt;a href=&#34;https://github.com/facebook/augmented-traffic-control&#34;&gt;https://github.com/facebook/augmented-traffic-control&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，必须安装Python2.7以上版本，然后安装pip：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-pip python-dev build-essential）
sudo pip install --upgrade pip 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，使用pip直接安装好ATC所有组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来部署Django的web工程，提供手机访问并用来配置和切换网络用的。&lt;/p&gt;

&lt;p&gt;1.使用django-admin生成一个新的django工程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-admin startproject atcui
cd atcui
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.修改atcui/settings.py，加入ATC相关的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;INSTALLED_APPS = (
    ...
    # Django ATC API
    &#39;rest_framework&#39;,
    &#39;atc_api&#39;,
    # Django ATC Demo UI
    &#39;bootstrap_themes&#39;,
    &#39;django_static_jquery&#39;,
    &#39;atc_demo_ui&#39;,
    # Django ATC Profile Storage
    &#39;atc_profile_storage&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.修改atcui/urls.py，urlpatterns 中加入atc的url页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;...
...
from django.views.generic.base import RedirectView
 
urlpatterns = patterns(&#39;&#39;,
    ...
    # Django ATC API
    url(r&#39;^api/v1/&#39;, include(&#39;atc_api.urls&#39;)),
    # Django ATC Demo UI
    url(r&#39;^atc_demo_ui/&#39;, include(&#39;atc_demo_ui.urls&#39;)),
    # Django ATC profile storage
    url(r&#39;^api/v1/profiles/&#39;, include(&#39;atc_profile_storage.urls&#39;)),
    url(r&#39;^$&#39;, RedirectView.as_view(url=&#39;/atc_demo_ui/&#39;, permanent=False)),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.更新一下数据库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;万事俱备，就差启动了……&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面设置WiFI热点时，你还记得设置的无线网卡的名字吗？嗯，就是wlan0，这个很重要。接下来要启动网络控制的核心组件atcd，需要通过参数指定提供Wifi热点的内网用的网卡名字，外网访问的网卡名默认是eth0（如果不是也需要通过&amp;ndash;atcd-wan指定）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo atcd --atcd-lan wlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，启动Django的工程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python manage.py runserver 0.0.0.0:8000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用手机连接上去试试吧。看看虚拟机的IP，比如我设置的是192.168.6.1，手机浏览器里访问：&lt;a href=&#34;http://192.168.6.1:8000&#34;&gt;http://192.168.6.1:8000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/ATCWeb.jpg-w&#34; alt=&#34;ATCWeb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在手机的界面里，你可以分别对网络上行下行进行设置，主要设置的参数有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网络带宽（bandwidth）&lt;/li&gt;
&lt;li&gt;延迟（latency）&lt;/li&gt;
&lt;li&gt;丢包率（packet loss）&lt;/li&gt;
&lt;li&gt;错包率（corrupted packets）&lt;/li&gt;
&lt;li&gt;乱序率（packets ordering）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过设置上面的参数，可以模拟出各种常用的网络环境，比如：2G，3G，4G，WiFi等等，同时也可以模拟一些异常情况，比如信号很差，延迟很大，丢包率高的情况。具体有哪些场景和参数设置，欢迎大家一起交流交流，下面是&lt;a href=&#34;https://github.com/tylertreat/Comcast&#34;&gt;Comcast&lt;/a&gt;提供的一份参数配置（国外的网络和国内的很不一样吧，仅供参考，欢迎大家修正和补充）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latency&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Bandwidth&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Packet-loss&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;GPRS (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;EDGE (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;250&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3G/HSDPA (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;250&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;750&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;DIAL-UP (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;185&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;DSL (poor)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;70&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;DSL (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;WIFI (good)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;30000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Satellite&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1500&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        
        <item>
            <title>为什么心跳包(HeartBeat)是必须的？</title>
            <link>http://blog.coderzh.com/2015/03/05/WhyHeartBeatNeeded/</link>
            <pubDate>Thu, 05 Mar 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/03/05/WhyHeartBeatNeeded/</guid>
            <description>

&lt;p&gt;&lt;img src=&#34;http://7xlx3k.com1.z0.glb.clouddn.com/Heartbeats.jpg-w&#34; alt=&#34;HeartBeat&#34; /&gt;&lt;/p&gt;

&lt;p&gt;几乎所有的网游服务端都有心跳包(HeartBeat或Ping)的设计，在最近开发手游服务端时，也用到了心跳包。思考思考，心跳包是必须的吗？为什么需要心跳包？TCP没有提供断线检测的方法吗？TCP提供的KeepAlive机制可以替代HeartBeat吗？&lt;/p&gt;

&lt;p&gt;由于连接丢失时，TCP不会立即通知应用程序。比如说，客户端程序断线了，服务端的TCP连接不会检测到断线，而是一直处于连接状态。这就带来了很大的麻烦，明明客户端已经断了，服务端还维护着客户端的连接，照常执行着该玩家的游戏逻辑……&lt;/p&gt;

&lt;p&gt;心跳包就是用来及时检测是否断线的一种机制，通过每间隔一定时间发送心跳数据，来检测对方是否连接。是属于应用程序协议的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题1： TCP为什么不自己提供断线检测？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，断线检测需要轮询发送检测报文，会消耗一定的网络带宽和暂用一定的网络资源。如果把它做成TCP的底层默认功能，那些不需要断线检测的应用程序将会浪费不必要的带宽资源。&lt;/p&gt;

&lt;p&gt;另外，TCP不提供连接丢失及时通知的最重要原因与其主要设计目的目标之一有关：出现网络故障时维护通信的能力。TCP是美国国防部赞助研究的，一种即使发生战争或自然灾害这种严重网络损坏情况下，也能维护可靠网络通信的网络协议。通常，网络故障只是暂时的，有时路由器会在TCP临时连接丢失后默默的重新连上。所以，TCP本身并不提供那么及时的断线检测。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题2： TCP的KeepAlive机制可以用来及时检测连接状态吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP有个KeepAlive开关，打开后可以用来检测死连接。通常默认是2小时，可以自己设置。但是注意，这是TCP的全局设置。假如为了能更及时的检测出断开的连接，把&lt;code&gt;tcp_keepalive_time&lt;/code&gt;和&lt;code&gt;tcp_keepalive_intvl&lt;/code&gt;的时间改小（参考：&lt;a href=&#34;http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html&#34;&gt;Link&lt;/a&gt;），该机器上所有应用程序的KeepAlive检测间隔都会变小，显然是不能接受的。因为不同应用程序的需求是不一样的。&lt;/p&gt;

&lt;p&gt;(在某些平台的Socket实现已经支持为每条连接单独设置KeepAlive参数)&lt;/p&gt;

&lt;p&gt;KeepAlive本质上来说，是用来检测长时间不活跃的连接的。所以，不适合用来及时检测连接的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题3：心跳包（HeartBeat）为什么是好的方式及时检测连接状态？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;具有更大的灵活性，可以自己控制检测的间隔，检测的方式等等。&lt;/li&gt;
&lt;li&gt;心跳包同时适用于TCP和UDP，在切换TCP和UDP时，上层的心跳包功能都适用。（其实这种情况很少遇到）&lt;/li&gt;
&lt;li&gt;有些情况下，心跳包可以附带一些其他信息，定时在服务端和客户端之间同步。（比如帧数同步）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;结论:f76865b2306592b0f5c605a6c67f5afe&#34;&gt;结论&lt;/h3&gt;

&lt;p&gt;需要及时检测TCP连接状态，心跳包(HeartBeat)还是必须的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>skynet Windows开发方式：VirtualBox中共享文件夹</title>
            <link>http://blog.coderzh.com/2015/01/14/SkynetUbuntuVirtualBox/</link>
            <pubDate>Wed, 14 Jan 2015 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2015/01/14/SkynetUbuntuVirtualBox/</guid>
            <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/cloudwu/skynet&#34;&gt;skynet&lt;/a&gt;是一个c和lua实现的轻量级actor模型服务端框架。看了所有文档，对skynet有了大致的了解。还需进一步考察看是否合适做为手游mmo服务端框架。&lt;/p&gt;

&lt;p&gt;由于skynet只有linux版本，如果开发平台是windows就会比较麻烦。于是打算使用虚拟机执行skynet程序，lua脚本放在虚拟机的共享目录里。于是lua可以方便的在Windows中编写，在Linux虚拟机里执行。&lt;/p&gt;

&lt;h3 id=&#34;virtualbox:d257e2f4020594dc6ae603b9b5c8c284&#34;&gt;VirtualBox&lt;/h3&gt;

&lt;p&gt;开始我用了个老版本的VirtualBox，增强功能插件总是安装不上，提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;grep: /lib/modules/3.13.0-24-generic/build/include/linux/version.h: No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后通过下面的帖子才发现，安装个最新版本的VirtualBox就解决问题了。(&lt;a href=&#34;http://ubuntuforums.org/showthread.php?t=2231775&#34;&gt;http://ubuntuforums.org/showthread.php?t=2231775&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;安装增强功能-install-guest-additions:d257e2f4020594dc6ae603b9b5c8c284&#34;&gt;安装增强功能(Install Guest Additions)&lt;/h3&gt;

&lt;p&gt;直接挂载共享目录，报错：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;unknown filesystem type vboxsf.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原因是没安装VirtualBox增强功能插件，点击菜单挂载iso：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.stack.imgur.com/ZAIEt.png&#34; alt=&#34;Insall Guest Additions&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虚拟机中安装依赖的编译环境套件:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$sudo apt-get install build-essential&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;执行:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;uname -r&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看装的是哪个kernel type，然后选择性的安装下面3个之一：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{something}-generic-pae = sudo apt-get install linux-headers-generic-pae
{something}-generic = sudo apt-get install linux-headers-generic
{something}-server = sudo apt-get install linux-headers-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂载光驱&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$sudo mount /dev/cdrom /media/cdrom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装增强功能，如果出现以下错误是因为Server未安装图形界面，不影响使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Installing the Window System drivers ...fail!
#(Could not find the X.Org or XFree86 Window System.)
$sudo /media/cdrom/VBoxLinuxAdditions.run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;卸载cdrom&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$sudo umount /media/cdrom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将共享文件夹(share)挂载到mnt下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$sudo mount -t vboxsf share /mnt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;其他问题:d257e2f4020594dc6ae603b9b5c8c284&#34;&gt;其他问题&lt;/h3&gt;

&lt;p&gt;在mount目录里，sudo执行脚本，总是Read-only file system。google了一会，发现原来是在mount的盘里去写系统路径下的文件就会出这个错。所以，不要执行mount目录的脚本就行了。（拷出来外面执行）&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>自豪的使用上了WordPress</title>
            <link>http://blog.coderzh.com/2014/09/09/wordpress/</link>
            <pubDate>Tue, 09 Sep 2014 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2014/09/09/wordpress/</guid>
            <description>&lt;p&gt;自从购买了DigitalOcean的VPS，就一直在上面折腾着。首当其冲的，是把我的博客转移到VPS中来，实现自己的独立博客。开始打算的是一切自己DIY，并且我之前也写过一套博客程序，用Python+Tornado+mongodb实现的。虽然很久没有维护，但还是可用的状态。&lt;/p&gt;

&lt;p&gt;最终，我还是放弃了自己写的NancyBlog(&lt;a href=&#34;http://code.google.com/p/nancyblog/)，而是选择了大名鼎鼎的WordPress，原因如下：&#34;&gt;http://code.google.com/p/nancyblog/)，而是选择了大名鼎鼎的WordPress，原因如下：&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我只是博客的使用者，应该把博客程序的开发交给更加有经验和经历的人。&lt;/li&gt;
&lt;li&gt;我自己的博客，要换个皮肤比较自己DIY很久。而WordPress有大量的皮肤，随意你切换。&lt;/li&gt;
&lt;li&gt;WordPress有大量的插件支持，比如使用MarkDown编写博文。能完全满足我写博客的需求。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开始我是打算把博客园里的博客导入过来的，毕竟我在博客园写博客已经有7年的时间了，积累了不少的文章。网上搜寻了导入的方法，找到一篇文章：将博客园(cnblogs.com)数据导入到wordpress(&lt;a href=&#34;http://levi.cg.am/archives/163)。我安装插件后导入毫无反应，应该是这个插件太久没有更新了，已经不能解析最新的博客园备份文章了。无奈只好先放一放，之后有时间自己实现个导入功能。当然，新的博客，一切从头开始，也未必不是一件好事。&#34;&gt;http://levi.cg.am/archives/163)。我安装插件后导入毫无反应，应该是这个插件太久没有更新了，已经不能解析最新的博客园备份文章了。无奈只好先放一放，之后有时间自己实现个导入功能。当然，新的博客，一切从头开始，也未必不是一件好事。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创业艰难，坚持不易，思考和总结不能停，博文还是得继续。给自己加油吧！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>DigitalOcean上使用Tornado&#43;MongoDB&#43;Nginx&#43;Supervisor&#43;DnsPod快速搭建个人博客</title>
            <link>http://blog.coderzh.com/2014/05/19/digitalocean/</link>
            <pubDate>Mon, 19 May 2014 00:00:00 UTC</pubDate>
            <author>CoderZh</author>
            <guid>http://blog.coderzh.com/2014/05/19/digitalocean/</guid>
            <description>

&lt;h3 id=&#34;digitalocean:51858cffc176cb478720d9c052e82245&#34;&gt;DigitalOcean&lt;/h3&gt;

&lt;p&gt;之前买了个便宜的VPS并且在上面搭建了我自己写的博客程序，后来VPS里运行MongoDB经常自己挂掉就索性没理了。直到现在VPS已经过期，服务器被强制关掉了。周末在家索性想着把这个博客程序重新搭建起来。&lt;/p&gt;

&lt;p&gt;选择Linode还是云主机（阿里云等等）？阿里云貌似有些贵，而且还有一堆备案的流程。Linode最近推出SSD服务，20刀/月的价格，加量不加价，很是吸引人。但无奈还是花的有些心疼。忽然另外一个VPS服务&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;DigitalOcean&lt;/a&gt;(链接含refcode喔)被我无意发现。DigitalOcean是一家IaaS服务提供商，其特色就是提供快速的固态硬盘服务器，该公司宣称可在55秒之内搭建好一台云服务器，所有的服务器均拥有1G的网络接口，每月基础套餐为1TB，最低套餐费用仅为5美元/月。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://images.cnitblog.com/blog/16913/201405/190032003752557.jpg&#34; alt=&#34;DigitalOcean&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个月20刀的配置和Linode的20刀的配置几乎一样。但是DigitalOcean提供了最低5美元/月的配置，而且如果使用优惠码注册，还能免费送10美元。相当于免费使用2个月。于是我选择了5美元的配置，Google了一把优惠码，并且非常顺利的找到了能用的。Google搜索：digitalocean coupon。我是在这里找到： &lt;a href=&#34;http://www.retailmenot.com/view/digitalocean.com&#34;&gt;http://www.retailmenot.com/view/digitalocean.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注册，填入优惠码，选择5$的主机类型，主机位置我选了旧金山（美国西部，据说比其他的稳定），操作系统选择了Ubuntu 14.04 x64。一切都非常顺利，正如他们的广告所说的，55秒内，一台热乎乎的VPS送到了我的手上。&lt;/p&gt;

&lt;p&gt;有兴趣的同学可以用我的推荐链接注册哦，我也能得到一些好处。注册链接：&lt;a href=&#34;https://www.digitalocean.com/?refcode=e131e2bba197&#34;&gt;DigitalOcean&lt;/a&gt;
用到哪天不想用了，DigitalOcean还提供了生成一个镜像(Image)的功能，然后你取消掉VPS服务器(Droplets)，之后将不收取费用。哪天忽然又想用了再开通它，用之前的镜像一还原，马上就恢复了之前的环境，很是方便。&lt;/p&gt;

&lt;h3 id=&#34;vps安装必要的软件:51858cffc176cb478720d9c052e82245&#34;&gt;VPS安装必要的软件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install git
sudo apt-get install python-pip
sudo apt-get install nginx
sudo apt-get install supervisor
sudo pip install tornado
sudo pip install pymongo
sudo pip install beautifulsoup4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（我安装了beautifulsoup是因为我做了个工具把博客园的博客导入过来。）
mongodb 安装：&lt;a href=&#34;http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/&#34;&gt;http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;博客程序:51858cffc176cb478720d9c052e82245&#34;&gt;博客程序&lt;/h3&gt;

&lt;p&gt;之前我用python+tornado+pymongo写了一套博客程序，只是给我自己使用，所以我放在了私有仓库&lt;a href=&#34;http://bitbucket.org&#34;&gt;bitbucket&lt;/a&gt;上。
网站程序一般放在/var/www目录里。所以我用git clone把我的代码放到了/var/www/coderzh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir /var/www
cd /var/www
git clone https://xxxxx.xxxx.xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mongodb:51858cffc176cb478720d9c052e82245&#34;&gt;MongoDB&lt;/h3&gt;

&lt;p&gt;由于我的程序没有使用MongoDB默认的端口27017，所以我需要修改端口的设置。找到MongoDB的配置文件，修改port字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /etc/mongodb.conf
#修改port=27017部分 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;停止和重启mongodb：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service mongodb stop
sudo service mongodb start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行博客程序:51858cffc176cb478720d9c052e82245&#34;&gt;运行博客程序&lt;/h3&gt;

&lt;p&gt;博客程序运行需要的环境已经基本配置好，这时运行博客程序看是否能正常起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo python /var/www/coderzh/main.py --port 8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器试试能不能访问: &lt;code&gt;http://服务器IP:8001&lt;/code&gt;   OK，太棒了，一起正常。&lt;/p&gt;

&lt;h3 id=&#34;supervisor:51858cffc176cb478720d9c052e82245&#34;&gt;Supervisor&lt;/h3&gt;

&lt;p&gt;停掉刚才的main.py，这时候要上一个好东西。它就是Supervisor，它是一个进程监控守护程序。它负责开机时自动启动你配置好的程序，并且在你的程序莫名其妙挂掉时，Supervisor会自动去重启他们。可以说，它是网站稳定运行的后勤保障啊。&lt;/p&gt;

&lt;p&gt;新建一个Supervisor配置文件，放到/ect/supervisor/conf.d目录下，因为/etc/supervisor/supervisord.conf里配置了自动读取conf.d目录下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim /ect/supervisor/conf.d/coderzh.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑coderzh.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[program:coderzh]
command=python /var/www/coderzh/main.py --port=8001
directory=/var/www/coderzh
autorestart=true
redirect_stderr=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重载配置，重启Supervisior：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;supervisorctl reload 
supervisorctl start all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次访问: &lt;code&gt;http://服务器IP:8001&lt;/code&gt;   试试，嗯，一起正常。Supervisor工作了。&lt;/p&gt;

&lt;h3 id=&#34;nginx:51858cffc176cb478720d9c052e82245&#34;&gt;Nginx&lt;/h3&gt;

&lt;p&gt;接下来上Nginx，它是一个HTTP和反向代理服务器。最终网站的访问经过域名解析到服务器后，都要通过Nginx将访问请求转到main.py中处理。理解Nginx的配置文件很重要，好吧，说实话，我当初摸Nginx，Apache之类的东西时都是一头雾水的。Nginx的主要配置文件路径在：/etc/nginx/nginx.conf&lt;/p&gt;

&lt;p&gt;为了让Nginx支持多域名，多Web服务。我修改/etc/nginx/nginx.conf 内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user www-data;
worker_processes 4;
pid /run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    types_hash_max_size 2048;
    server_names_hash_bucket_size 64;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;
 
    access_log /var/log/nginx/access.log;
 
    keepalive_timeout 65;
    proxy_read_timeout 200;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    gzip on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain application/x-javascript text/css application/xml; 

    include /etc/nginx/conf.d/*;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意最后一行：include /etc/nginx/conf.d/*，所以在conf.d目录里，可以为每个网站都配置一个.conf文件。我为博客程序生产的配置：vim /etc/nginx/conf.d/coderzh.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream coderzh {
    server 127.0.0.1:8001;
}

server {
    listen 80;
    server_name coderzh.com www.coderzh.com;

    location = /favicon.ico {
        rewrite (.*) /static/favicon.ico;
    }
    location = /robots.txt {
        rewrite (.*) /static/robots.txt;
    }

    location / {
        proxy_pass_header Server;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;
        proxy_pass http://coderzh;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新启动nginx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service nginx restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时已经可以用80端口访问了。&lt;/p&gt;

&lt;h3 id=&#34;dnspod:51858cffc176cb478720d9c052e82245&#34;&gt;DnsPod&lt;/h3&gt;

&lt;p&gt;接下来就是通过DnsPod将域名解析到这台VPS服务器。应该不是什么问题，有问题可以查看DnsPod帮助。&lt;/p&gt;

&lt;h3 id=&#34;部署完成:51858cffc176cb478720d9c052e82245&#34;&gt;部署完成&lt;/h3&gt;

&lt;p&gt;执行导入工具，将博客园的博客导入进来。访问：&lt;a href=&#34;http://www.coderzh.com&#34;&gt;http://www.coderzh.com&lt;/a&gt;。HOHO，大功告成。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
